# -*- coding: utf-8 -*-
"""Daiy Trader

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tXcbOmCAgpxrUJinsfyosdHnW-xSKC5H
"""

!pip install yfinance robin_stocks pandas numpy

# Step 1: Import robin_stocks library for connecting to Robinhood
import robin_stocks.robinhood as rh

# Step 2: Set your Robinhood login credentials here
username = 'rmah5078@my.msmc.edu'  # Replace with your Robinhood username
password = 'Lucky1313!'  # Replace with your Robinhood password

# Step 3: Login to Robinhood
login = rh.login(username, password)

# Print a success message to confirm you're logged in
print("Logged in successfully!")

import yfinance as yf
import pandas as pd

# Step 1: Define a list of 25 stock tickers (e.g., 'AAPL', 'MSFT', 'GOOGL', etc.)
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META', 'BRK-B', 'JPM', 'V',
           'JNJ', 'WMT', 'PG', 'UNH', 'HD', 'MA', 'DIS', 'PYPL', 'INTC', 'NFLX',
           'CSCO', 'PEP', 'KO', 'ADBE', 'XOM']

# Step 2: Create an empty dictionary to store stock data for each ticker
stock_data = {}

# Step 3: Loop through each stock ticker and fetch the last day's minute-by-minute data
for ticker in tickers:
    stock_data[ticker] = yf.download(ticker, period='1d', interval='1m')

# Step 4: Print the last few rows of data for one of the stocks (e.g., 'AAPL') to verify
print(stock_data['AAPL'].tail())

import numpy as np

# Define a simple moving average crossover strategy
def moving_average_strategy(data, short_window=40, long_window=100):
    # Step 1: Calculate the short-term and long-term moving averages
    data['short_mavg'] = data['Close'].rolling(window=short_window, min_periods=1).mean()
    data['long_mavg'] = data['Close'].rolling(window=long_window, min_periods=1).mean()

    # Step 2: Generate buy/sell signals based on the moving averages
    data['signal'] = 0.0
    data['signal'][short_window:] = np.where(data['short_mavg'][short_window:] > data['long_mavg'][short_window:], 1.0, 0.0)

    # Step 3: Calculate positions (1 = buy, -1 = sell)
    data['positions'] = data['signal'].diff()
    return data

# Apply the strategy to each stock in the list of 25 stocks
for ticker in stock_data:
    stock_data[ticker] = moving_average_strategy(stock_data[ticker])

# Print the last few rows of AAPL data with the strategy applied
print(stock_data['AAPL'][['Close', 'short_mavg', 'long_mavg', 'signal', 'positions']].tail())

# Initialize total P&L and set daily loss limit
total_pnl = 0.0  # Tracks total profit and loss for the day
daily_loss_limit = -50.0  # Stop trading if losses exceed $50

# Modified function to place orders and track P&L
def place_order(ticker, quantity, buy=True):
    global total_pnl

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    if buy:
        # Place a market buy order
        rh.orders.order_buy_market(ticker, quantity)
        print(f"Buying {quantity} shares of {ticker} at ${current_price}")

        # Track cost of buy (for calculating P&L when sold)
        stock_data[ticker]['buy_price'] = current_price
    else:
        # Place a market sell order
        rh.orders.order_sell_market(ticker, quantity)
        print(f"Selling {quantity} shares of {ticker} at ${current_price}")

        # Calculate profit/loss from this trade
        buy_price = stock_data[ticker]['buy_price']
        trade_pnl = (current_price - buy_price) * quantity
        total_pnl += trade_pnl  # Add the profit/loss to the total P&L

        print(f"Trade P&L for {ticker}: ${trade_pnl}")
        print(f"Total P&L for the day: ${total_pnl}")

        # Stop trading if total losses exceed $50
        if total_pnl <= daily_loss_limit:
            print("Daily loss limit reached. Stopping trading.")
            return False  # Stop further trading

    return True  # Continue trading if loss limit not reached

# Function to execute trades with P&L tracking
def execute_trades_with_pnl():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            if not place_order(ticker, quantity=1, buy=True):
                break  # Stop if loss limit is hit
        elif last_position == -1.0:  # Sell signal
            if not place_order(ticker, quantity=1, buy=False):
                break  # Stop if loss limit is hit

# Execute trades with the new P&L system
execute_trades_with_pnl()

# Initialize variables to track total capital used
total_capital_used = 0.0  # Track how much capital has been invested during the day
daily_capital_limit = 200.0  # Set a maximum of $200 for daily trading

# Modify the place_order function to include the $200 daily limit
def place_order_with_limit(ticker, quantity, buy=True):
    global total_capital_used, total_pnl

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]
    order_value = current_price * quantity  # Calculate how much the order will cost

    if buy:
        # Check if there's enough capital left to place the trade
        if total_capital_used + order_value > daily_capital_limit:
            print(f"Cannot buy {quantity} shares of {ticker}. Capital limit of ${daily_capital_limit} reached.")
            return False  # Do not place the order if it exceeds the capital limit

        # Place a market buy order
        rh.orders.order_buy_market(ticker, quantity)
        total_capital_used += order_value  # Add the order value to the total capital used
        print(f"Buying {quantity} shares of {ticker} at ${current_price}, total capital used: ${total_capital_used}")

        # Track cost of buy for calculating P&L when sold
        stock_data[ticker]['buy_price'] = current_price
    else:
        # Place a market sell order
        rh.orders.order_sell_market(ticker, quantity)
        print(f"Selling {quantity} shares of {ticker} at ${current_price}")

        # Calculate profit/loss from this trade
        buy_price = stock_data[ticker]['buy_price']
        trade_pnl = (current_price - buy_price) * quantity
        total_pnl += trade_pnl  # Add the profit/loss to the total P&L

        # Adjust total_capital_used by removing the amount reinvested from profits
        total_capital_used = max(0.0, total_capital_used - trade_pnl)
        print(f"Trade P&L for {ticker}: ${trade_pnl}")
        print(f"Total P&L for the day: ${total_pnl}, total capital used: ${total_capital_used}")

        # Stop trading if total losses exceed $50
        if total_pnl <= daily_loss_limit:
            print("Daily loss limit reached. Stopping trading.")
            return False  # Stop further trading

    return True  # Continue trading if within limits

# Function to execute trades with the $200 limit
def execute_trades_with_limit():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy
            pass # Or some other action you want to perform when last_position is 1.0

# Initialize variables for simulation
total_pnl_simulation = 0.0  # P&L for the simulated environment
total_capital_used_simulation = 0.0  # Track capital usage for the day

# Simulated function to place orders (instead of real trades)
def simulate_order(ticker, quantity, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]
    order_value = current_price * quantity  # Calculate the order cost

    if buy:
        # Simulate buy order if within the $200 limit
        if total_capital_used_simulation + order_value > daily_capital_limit:
            print(f"Simulation: Cannot buy {quantity} shares of {ticker}. Capital limit of ${daily_capital_limit} reached.")
            return False  # Stop the simulated order

        # Simulate the buy order
        total_capital_used_simulation += order_value
        print(f"Simulation: Buying {quantity} shares of {ticker} at ${current_price}, total capital used: ${total_capital_used_simulation}")

        # Track the buy price for calculating simulated P&L
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        # Simulate the sell order
        print(f"Simulation: Selling {quantity} shares of {ticker} at ${current_price}")

        # Calculate the profit or loss from this simulated trade
        buy_price_sim = stock_data[ticker].get('buy_price_sim', current_price)
        trade_pnl_sim = (current_price - buy_price_sim) * quantity
        total_pnl_simulation += trade_pnl_sim  # Add the trade P&L to the total simulated P&L

        # Adjust capital used for reinvesting profits
        total_capital_used_simulation = max(0.0, total_capital_used_simulation - trade_pnl_sim)
        print(f"Simulation Trade P&L for {ticker}: ${trade_pnl_sim}")
        print(f"Simulation Total P&L for the day: ${total_pnl_simulation}, total capital used: ${total_capital_used_simulation}")

        # Stop if the total simulated loss reaches $50
        if total_pnl_simulation <= daily_loss_limit:
            print("Simulation: Daily loss limit reached. Stopping simulated trading.")
            return False  # Stop further trades in the simulation

    return True  # Continue trading in the simulation

# Function to simulate trades with the $200 limit
def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            if not simulate_order(ticker, quantity=1, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            if not simulate_order(ticker, quantity=1, buy=False):
                break  # Stop if capital or loss limit is hit in simulation

# Run the simulation to test the bot without real trades
simulate_trades()

# Initialize variables for simulation
total_pnl_simulation = 0.0  # P&L for the simulated environment
total_capital_used_simulation = 0.0  # Track capital usage for the day

# Simulated function to place orders with $20 per trade limit
def simulate_order(ticker, fixed_amount=20, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]
    quantity = fixed_amount // current_price  # Calculate how many shares can be bought with $20

    if quantity < 1:
        print(f"Simulation: Not enough to buy 1 share of {ticker} with ${fixed_amount}.")
        return False  # Skip this trade if $20 is not enough to buy 1 share

    order_value = current_price * quantity  # Calculate the total cost of the order

    if buy:
        # Check if there's enough capital left to place the trade
        if total_capital_used_simulation + order_value > daily_capital_limit:
            print(f"Simulation: Cannot buy {quantity} shares of {ticker}. Capital limit of ${daily_capital_limit} reached.")
            return False  # Stop the simulated order if capital limit is hit

        # Simulate the buy order
        total_capital_used_simulation += order_value
        print(f"Simulation: Buying {quantity} shares of {ticker} at ${current_price}, total capital used: ${total_capital_used_simulation}")

        # Track the buy price for calculating simulated P&L
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        # Simulate the sell order
        print(f"Simulation: Selling {quantity} shares of {ticker} at ${current_price}")

        # Calculate the profit or loss from this simulated trade
        buy_price_sim = stock_data[ticker].get('buy_price_sim', current_price)
        trade_pnl_sim = (current_price - buy_price_sim) * quantity
        total_pnl_simulation += trade_pnl_sim  # Add the trade P&L to the total simulated P&L

        # Adjust capital used for reinvesting profits
        total_capital_used_simulation = max(0.0, total_capital_used_simulation - trade_pnl_sim)
        print(f"Simulation Trade P&L for {ticker}: ${trade_pnl_sim}")
        print(f"Simulation Total P&L for the day: ${total_pnl_simulation}, total capital used: ${total_capital_used_simulation}")

        # Stop if the total simulated loss reaches $50
        if total_pnl_simulation <= daily_loss_limit:
            print("Simulation: Daily loss limit reached. Stopping simulated trading.")
            return False  # Stop further trades in the simulation

    return True

# Function to simulate trades with the $20 per trade and $200 daily limit
def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            if not simulate_order(ticker, fixed_amount=20, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            if not simulate_order(ticker, fixed_amount=20, buy=False):
                break  # Stop if capital or loss limit is hit in simulation

# Run the simulation to test the bot with $20 per trade and $200 daily limit
simulate_trades()

# Initialize variables for simulation
total_pnl_simulation = 0.0  # P&L for the simulated environment
total_capital_used_simulation = 0.0  # Track capital usage for the day

# Simulated function to place orders with $5 per trade limit
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]
    quantity = fixed_amount // current_price  # Calculate how many shares can be bought with $5

    if quantity < 1:
        print(f"Simulation: Not enough to buy 1 share of {ticker} with ${fixed_amount}.")
        return False  # Skip this trade if $5 is not enough to buy 1 share

    order_value = current_price * quantity  # Calculate the total cost of the order

    if buy:
        # Check if there's enough capital left to place the trade
        if total_capital_used_simulation + order_value > daily_capital_limit:
            print(f"Simulation: Cannot buy {quantity} shares of {ticker}. Capital limit of ${daily_capital_limit} reached.")
            return False  # Stop the simulated order if capital limit is hit

        # Simulate the buy order
        total_capital_used_simulation += order_value
        print(f"Simulation: Buying {quantity} shares of {ticker} at ${current_price}, total capital used: ${total_capital_used_simulation}")

        # Track the buy price for calculating simulated P&L
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        # Simulate the sell order
        print(f"Simulation: Selling {quantity} shares of {ticker} at ${current_price}")

        # Calculate the profit or loss from this simulated trade
        buy_price_sim = stock_data[ticker].get('buy_price_sim', current_price)
        trade_pnl_sim = (current_price - buy_price_sim) * quantity
        total_pnl_simulation += trade_pnl_sim  # Add the trade P&L to the total simulated P&L

        # Adjust capital used for reinvesting profits
        total_capital_used_simulation = max(0.0, total_capital_used_simulation - trade_pnl_sim)
        print(f"Simulation Trade P&L for {ticker}: ${trade_pnl_sim}")
        print(f"Simulation Total P&L for the day: ${total_pnl_simulation}, total capital used: ${total_capital_used_simulation}")

        # Stop if the total simulated loss reaches $50
        if total_pnl_simulation <= daily_loss_limit:
            print("Simulation: Daily loss limit reached. Stopping simulated trading.")
            return False  # Stop further trades in the simulation

    return True

# Function to simulate trades with the $5 per trade and $200 daily limit
def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation

# Run the simulation to test the bot with $5 per trade and $200 daily limit
simulate_trades()

# Initialize variables for simulation
total_pnl_simulation = 0.0  # P&L for the simulated environment
total_capital_used_simulation = 0.0  # Track capital usage for the day

# Simulated function to place orders with $5 per trade limit (fractional shares)
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    order_value = current_price * quantity  # Calculate the total cost of the order

    if buy:
        # Check if there's enough capital left to place the trade
        if total_capital_used_simulation + order_value > daily_capital_limit:
            print(f"Simulation: Cannot buy ${fixed_amount} worth of {ticker}. Capital limit of ${daily_capital_limit} reached.")
            return False  # Stop the simulated order if capital limit is hit

        # Simulate the buy order
        total_capital_used_simulation += order_value
        print(f"Simulation: Buying ${fixed_amount} worth of {ticker} (fractional shares = {quantity}), total capital used: ${total_capital_used_simulation}")

        # Track the buy price for calculating simulated P&L
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        # Simulate the sell order
        print(f"Simulation: Selling {quantity} fractional shares of {ticker} at ${current_price}")

        # Calculate the profit or loss from this simulated trade
        buy_price_sim = stock_data[ticker].get('buy_price_sim', current_price)
        trade_pnl_sim = (current_price - buy_price_sim) * quantity
        total_pnl_simulation += trade_pnl_sim  # Add the trade P&L to the total simulated P&L

        # Adjust capital used for reinvesting profits
        total_capital_used_simulation = max(0.0, total_capital_used_simulation - trade_pnl_sim)
        print(f"Simulation Trade P&L for {ticker}: ${trade_pnl_sim}")
        print(f"Simulation Total P&L for the day: ${total_pnl_simulation}, total capital used: ${total_capital_used_simulation}")

        # Stop if the total simulated loss reaches $50
        if total_pnl_simulation <= daily_loss_limit:
            print("Simulation: Daily loss limit reached. Stopping simulated trading.")
            return False  # Stop further trades in the simulation

    return True

# Function to simulate trades with the $5 per trade and $200 daily limit (fractional shares)
def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation

# Run the simulation to test the bot with $5 per trade and $200 daily limit (fractional shares)
simulate_trades()

# Clear all previously set variables to start fresh
total_pnl_simulation = 0.0  # Reset total P&L
total_capital_used_simulation = 0.0  # Reset total capital used
stock_data = {}  # If the stock data is already loaded, you can clear it here if needed

print("Variables reset. Ready for a fresh simulation.")

# Function to simulate trades with $5 per trade and $200 daily limit (fractional shares)
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    order_value = current_price * quantity  # Calculate the total cost of the order

    if buy:
        # Check if there's enough capital left to place the trade
        if total_capital_used_simulation + order_value > daily_capital_limit:
            print(f"Simulation: Cannot buy ${fixed_amount} worth of {ticker}. Capital limit of ${daily_capital_limit} reached.")
            return False  # Stop the simulated order if capital limit is hit

        # Simulate the buy order
        total_capital_used_simulation += order_value
        print(f"Simulation: Buying ${fixed_amount} worth of {ticker} (fractional shares = {quantity}), total capital used: ${total_capital_used_simulation}")

        # Track the buy price for calculating simulated P&L
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        # Simulate the sell order
        print(f"Simulation: Selling {quantity} fractional shares of {ticker} at ${current_price}")

        # Calculate the profit or loss from this simulated trade
        buy_price_sim = stock_data[ticker].get('buy_price_sim', current_price)
        trade_pnl_sim = (current_price - buy_price_sim) * quantity
        total_pnl_simulation += trade_pnl_sim  # Add the trade P&L to the total simulated P&L

        # Adjust capital used for reinvesting profits
        total_capital_used_simulation = max(0.0, total_capital_used_simulation - trade_pnl_sim)
        print(f"Simulation Trade P&L for {ticker}: ${trade_pnl_sim}")
        print(f"Simulation Total P&L for the day: ${total_pnl_simulation}, total capital used: ${total_capital_used_simulation}")

        # Stop if the total simulated loss reaches $50
        if total_pnl_simulation <= daily_loss_limit:
            print("Simulation: Daily loss limit reached. Stopping simulated trading.")
            return False  # Stop further trades in the simulation

    return True

# Function to simulate trades for $5 per trade and $200 daily limit
def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

# Initialize variables for simulation
total_pnl_simulation = 0.0  # P&L for the simulated environment
total_capital_used_simulation = 0.0  # Track capital usage for the day

# Simulated function to place orders with $5 per trade limit (fractional shares)
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    order_value = current_price * quantity  # Calculate the total cost of the order

    if buy:
        # Check if there's enough capital left to place the trade
        if total_capital_used_simulation + order_value > daily_capital_limit:
            print(f"Simulation: Cannot buy ${fixed_amount} worth of {ticker}. Capital limit of ${daily_capital_limit} reached.")
            return False  # Stop the simulated order if capital limit is hit

        # Simulate the buy order
        total_capital_used_simulation += order_value
        print(f"Simulation: Buying ${fixed_amount} worth of {ticker} (fractional shares = {quantity}), total capital used: ${total_capital_used_simulation}")

        # Track the buy price for calculating simulated P&L
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        # Simulate the sell order
        print(f"Simulation: Selling {quantity} fractional shares of {ticker} at ${current_price}")

        # Calculate the profit or loss from this simulated trade
        buy_price_sim = stock_data[ticker].get('buy_price_sim', current_price)
        trade_pnl_sim = (current_price - buy_price_sim) * quantity
        total_pnl_simulation += trade_pnl_sim  # Add the trade P&L to the total simulated P&L

        # Print the exact P&L for this trade
        print(f"Simulation Trade P&L for {ticker}: ${trade_pnl_sim:.2f}")
        print(f"Total P&L for the day so far: ${total_pnl_simulation:.2f}, total capital used: ${total_capital_used_simulation:.2f}")

        # Adjust capital used for reinvesting profits
        total_capital_used_simulation = max(0.0, total_capital_used_simulation - trade_pnl_sim)

        # Stop if the total simulated loss reaches $50
        if total_pnl_simulation <= daily_loss_limit:
            print("Simulation: Daily loss limit reached. Stopping simulated trading.")
            return False  # Stop further trades in the simulation

    return True

# Function to simulate trades with $5 per trade and $200 daily limit (fractional shares)
def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation

    # Print the total profit or loss at the end of the simulation
    print(f"Simulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation to test the bot with $5 per trade and $200 daily limit (fractional shares)
simulate_trades()

def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            print(f"Buy signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            print(f"Sell signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation
        else:
            print(f"No signal for {ticker} at the moment.")

    # Print the total profit or loss at the end of the simulation
    print(f"Simulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Initialize variables for simulation
total_pnl_simulation = 0.0  # P&L for the simulated environment
total_capital_used_simulation = 0.0  # Track capital usage for the day

# Simulated function to place orders with $5 per trade limit (fractional shares)
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    order_value = current_price * quantity  # Calculate the total cost of the order

    if buy:
        # Simulate the buy order
        total_capital_used_simulation += order_value
        print(f"Simulation: Buying ${fixed_amount} worth of {ticker} at ${current_price:.2f}. Fractional shares: {quantity:.6f}")

        # Track the buy price for calculating simulated P&L
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        # Get the buy price (handle missing buy price gracefully)
        buy_price_sim = stock_data[ticker].get('buy_price_sim', None)

        if buy_price_sim is None:
            print(f"Error: No buy price found for {ticker} before selling. Skipping sell.")
            return False

        # Simulate the sell order
        print(f"Simulation: Selling {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f}. Previous buy price: ${buy_price_sim:.2f}")

        # Calculate the profit or loss from this simulated trade
        trade_pnl_sim = (current_price - buy_price_sim) * quantity
        total_pnl_simulation += trade_pnl_sim  # Add the trade P&L to the total simulated P&L

        # Print the exact P&L for this trade
        print(f"Simulation Trade P&L for {ticker}: ${trade_pnl_sim:.2f}")
        print(f"Total P&L for the day so far: ${total_pnl_simulation:.2f}, total capital used: ${total_capital_used_simulation:.2f}")

        # Adjust capital used for reinvesting profits
        total_capital_used_simulation = max(0.0, total_capital_used_simulation - trade_pnl_sim)

        # Stop if the total simulated loss reaches $50
        if total_pnl_simulation <= daily_loss_limit:
            print("Simulation: Daily loss limit reached. Stopping simulated trading.")
            return False  # Stop further trades in the simulation

    return True

# Function to simulate trades with $5 per trade and $200 daily limit (fractional shares)
def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            print(f"Buy signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            print(f"Sell signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation
        else:
            print(f"No signal for {ticker} at the moment.")

    # Print the total profit or loss at the end of the simulation
    print(f"Simulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation to test the bot with $5 per trade and $200 daily limit (fractional shares)
simulate_trades()

# Initialize variables for simulation
total_pnl_simulation = 0.0  # P&L for the simulated environment
total_capital_used_simulation = 0.0  # Track capital usage for the day

# Simulated function to place orders with $5 per trade limit (fractional shares)
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    order_value = current_price * quantity  # Calculate the total cost of the order

    if buy:
        # Simulate the buy order
        total_capital_used_simulation += order_value
        print(f"Simulation: Buying ${fixed_amount} worth of {ticker} at ${current_price:.2f}. Fractional shares: {quantity:.6f}")

        # Track the buy price for calculating simulated P&L
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        # Get the buy price (handle missing buy price gracefully)
        buy_price_sim = stock_data[ticker].get('buy_price_sim', None)

        if buy_price_sim is None:
            print(f"Error: No buy price found for {ticker} before selling. Skipping sell.")
            return False

        # Simulate the sell order
        print(f"Simulation: Selling {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f}. Previous buy price: ${buy_price_sim:.2f}")

        # Calculate the price movement
        price_change = current_price - buy_price_sim
        print(f"Price movement for {ticker}: ${price_change:.2f}")

        # Calculate the profit or loss from this simulated trade
        trade_pnl_sim = price_change * quantity
        total_pnl_simulation += trade_pnl_sim  # Add the trade P&L to the total simulated P&L

        # Print the exact P&L for this trade
        print(f"Simulation Trade P&L for {ticker}: ${trade_pnl_sim:.2f}")
        print(f"Total P&L for the day so far: ${total_pnl_simulation:.2f}, total capital used: ${total_capital_used_simulation:.2f}")

        # Adjust capital used for reinvesting profits
        total_capital_used_simulation = max(0.0, total_capital_used_simulation - trade_pnl_sim)

        # Stop if the total simulated loss reaches $50
        if total_pnl_simulation <= daily_loss_limit:
            print("Simulation: Daily loss limit reached. Stopping simulated trading.")
            return False  # Stop further trades in the simulation

    return True

# Function to simulate trades with $5 per trade and $200 daily limit (fractional shares)
def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            print(f"Buy signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            print(f"Sell signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation
        else:
            print(f"No signal for {ticker} at the moment.")

    # Print the total profit or loss at the end of the simulation
    print(f"Simulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation to test the bot with $5 per trade and $200 daily limit (fractional shares)
simulate_trades()

import yfinance as yf

# Define the ticker you want to fetch data for (e.g., 'AAPL')
ticker = 'AAPL'

# Fetch historical stock data for the last day (with 1-minute intervals)
historical_data = yf.download(ticker, period='1d', interval='1m')

# Print the last few rows of data to check
print(historical_data.tail())

# Function to simulate trades on historical data
def simulate_historical_trades(historical_data):
    for time, row in historical_data.iterrows():
        current_price = row['Close']
        print(f"Simulated current price of {ticker} at {time}: ${current_price:.2f}")

        # Use your signal generation logic here (RSI, moving average, etc.)
        # For example, let's simulate a basic buy/sell signal based on price movement
        if current_price < historical_data['Close'].rolling(window=40).mean().iloc[-1]:  # Example buy signal
            print(f"Simulated BUY for {ticker} at ${current_price:.2f}")
        elif current_price > historical_data['Close'].rolling(window=40).mean().iloc[-1]:  # Example sell signal
            print(f"Simulated SELL for {ticker} at ${current_price:.2f}")

    # Simulate total P&L and display it
    print(f"Simulation completed using historical data for {ticker}.")

# Run the historical simulation
simulate_historical_trades(historical_data)

# Initialize variables for simulation
total_pnl_simulation = 0.0  # P&L for the simulated environment
total_capital_used_simulation = 0.0  # Track capital usage for the day
trade_history = []  # To store P&L for each trade

# Simulated function to place orders with $5 per trade limit (fractional shares)
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    order_value = current_price * quantity  # Calculate the total cost of the order

    if buy:
        # Simulate the buy order
        total_capital_used_simulation += order_value
        print(f"Simulation: Buying ${fixed_amount} worth of {ticker} at ${current_price:.2f}. Fractional shares: {quantity:.6f}")

        # Track the buy price for calculating simulated P&L
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        # Get the buy price (handle missing buy price gracefully)
        buy_price_sim = stock_data[ticker].get('buy_price_sim', None)

        if buy_price_sim is None:
            print(f"Error: No buy price found for {ticker} before selling. Skipping sell.")
            return False

        # Simulate the sell order
        print(f"Simulation: Selling {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f}. Previous buy price: ${buy_price_sim:.2f}")

        # Calculate the price movement
        price_change = current_price - buy_price_sim
        print(f"Price movement for {ticker}: ${price_change:.2f}")

        # Calculate the profit or loss from this simulated trade
        trade_pnl_sim = price_change * quantity
        total_pnl_simulation += trade_pnl_sim  # Add the trade P&L to the total simulated P&L

        # Print the exact P&L for this trade
        print(f"Simulation Trade P&L for {ticker}: ${trade_pnl_sim:.2f}")
        print(f"Total P&L for the day so far: ${total_pnl_simulation:.2f}, total capital used: ${total_capital_used_simulation:.2f}")

        # Store the trade result in the history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

        # Adjust capital used for reinvesting profits
        total_capital_used_simulation = max(0.0, total_capital_used_simulation - trade_pnl_sim)

        # Stop if the total simulated loss reaches $50
        if total_pnl_simulation <= daily_loss_limit:
            print("Simulation: Daily loss limit reached. Stopping simulated trading.")
            return False  # Stop further trades in the simulation

    return True

# Function to simulate trades with $5 per trade and $200 daily limit (fractional shares)
def simulate_trades():
    for ticker, data in stock_data.items():
        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            print(f"Buy signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            print(f"Sell signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation
        else:
            print(f"No signal for {ticker} at the moment.")

    # Print the total profit or loss at the end of the simulation
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

    # Print a summary of each trade
    print("\n--- Trade History ---")
    for trade in trade_history:
        print(f"{trade['ticker']}: Bought at ${trade['buy_price']:.2f}, Sold at ${trade['sell_price']:.2f}, P&L: ${trade['trade_pnl']:.2f}")

# Run the simulation to test the bot with $5 per trade and $200 daily limit (fractional shares)
simulate_trades()

def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    order_value = current_price * quantity  # Calculate the total cost of the order

    if buy:
        print(f"Attempting to BUY ${fixed_amount} worth of {ticker} at ${current_price:.2f}")
        total_capital_used_simulation += order_value
        stock_data[ticker]['buy_price_sim'] = current_price
    else:
        buy_price_sim = stock_data[ticker].get('buy_price_sim', None)

        if buy_price_sim is None:
            print(f"Error: No buy price found for {ticker} before selling. Skipping sell.")
            return False

        print(f"Attempting to SELL {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f}. Previous buy price: ${buy_price_sim:.2f}")

        # Calculate the price movement
        price_change = current_price - buy_price_sim
        print(f"Price movement for {ticker}: ${price_change:.2f}")

        trade_pnl_sim = price_change * quantity
        total_pnl_simulation += trade_pnl_sim

        print(f"Trade P&L for {ticker}: ${trade_pnl_sim:.2f}")
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

def rsi_strategy(data):
    data = calculate_rsi(data)

    # Make the bot more aggressive by adjusting RSI thresholds
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 40, 1.0, data['signal'])  # Buy when RSI < 40
    data['signal'] = np.where(data['RSI'] > 60, -1.0, data['signal'])  # Sell when RSI > 60

    data['positions'] = data['signal'].diff()
    return data

def rsi_strategy(data):
    data = calculate_rsi(data)

    # Adjust RSI thresholds for more frequent trades
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 40, 1.0, data['signal'])  # Buy when RSI < 40
    data['signal'] = np.where(data['RSI'] > 60, -1.0, data['signal'])  # Sell when RSI > 60

    data['positions'] = data['signal'].diff()

    # Log signal generation
    if data['positions'].iloc[-1] == 1.0:
        print(f"Buy signal generated for {ticker}")
    elif data['positions'].iloc[-1] == -1.0:
        print(f"Sell signal generated for {ticker}")
    else:
        print(f"No signal for {ticker} at the moment")

    return data

def simulate_trades():
    for ticker, data in stock_data.items():
        print(f"Checking {ticker} for signals...")

        # Get the most recent signal (buy/sell decision)
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            print(f"Buy signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            print(f"Sell signal detected for {ticker}.")
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation
        else:
            print(f"No signal for {ticker} at the moment.")

    # Print the total profit or loss at the end of the simulation
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Check the data for each stock
for ticker, data in stock_data.items():
    print(f"Data for {ticker}:")
    print(data.head())  # Print the first few rows of the data

# Adjusting the RSI thresholds to trade more frequently
def rsi_strategy(data):
    data = calculate_rsi(data)

    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 50, 1.0, data['signal'])  # Buy when RSI < 50 (instead of 40)
    data['signal'] = np.where(data['RSI'] > 50, -1.0, data['signal'])  # Sell when RSI > 50 (instead of 60)

    data['positions'] = data['signal'].diff()
    return data

# Initialize variables for simulation
total_pnl_simulation = 0.0  # Total P&L for the day
total_capital_used_simulation = 0.0  # Capital usage for the day
trade_history = []  # To store the history of each trade

# Simulated function to place orders
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    order_value = current_price * quantity  # Calculate total cost of the order

    if buy:
        # Simulate buy order
        print(f"Simulating BUY: ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        total_capital_used_simulation += order_value
        stock_data[ticker]['buy_price_sim'] = current_price  # Save the buy price
    else:
        # Get buy price (error handling for missing buy price)
        buy_price_sim = stock_data[ticker].get('buy_price_sim', None)

        if buy_price_sim is None:
            print(f"Error: No buy price found for {ticker} before selling. Skipping sell.")
            return False

        # Simulate sell order
        print(f"Simulating SELL: {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f} per share.")
        price_change = current_price - buy_price_sim
        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade

        total_pnl_simulation += trade_pnl_sim  # Update total P&L
        print(f"Profit/Loss for this trade: ${trade_pnl_sim:.2f}")

        # Store the trade in history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

# Function to simulate trades with detailed logging and profit tracking
def simulate_trades():
    for ticker, data in stock_data.items():
        # Check for buy/sell signals
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation

    # Print a summary of each trade
    print("\n--- Trade History ---")
    for trade in trade_history:
        print(f"{trade['ticker']}: Bought at ${trade['buy_price']:.2f}, Sold at ${trade['sell_price']:.2f}, P&L: ${trade['trade_pnl']:.2f}")

    # Print the total profit or loss for the day
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation to test the bot with $5 per trade and $200 daily limit
simulate_trades()

def rsi_strategy(data):
    data = calculate_rsi(data)

    # Adjust RSI thresholds if needed
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 40, 1.0, data['signal'])  # Buy when RSI < 40
    data['signal'] = np.where(data['RSI'] > 60, -1.0, data['signal'])  # Sell when RSI > 60

    data['positions'] = data['signal'].diff()

    # Log the generated signals
    if data['positions'].iloc[-1] == 1.0:
        print(f"Buy signal generated for {ticker}")
    elif data['positions'].iloc[-1] == -1.0:
        print(f"Sell signal generated for {ticker}")
    else:
        print(f"No signal generated for {ticker}")

    return data

if buy:
    print(f"Simulating BUY: ${fixed_amount} worth of {ticker} at ${current_price:.2f}.")
else:
    print(f"Simulating SELL: {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f}. Previous buy price: ${buy_price_sim:.2f}")

# Initialize variables for simulation
total_pnl_simulation = 0.0  # Total P&L for the day
total_capital_used_simulation = 0.0  # Capital usage for the day
trade_history = []  # To store the history of each trade
buy_prices = {}  # Dictionary to track buy prices for each stock

# Simulated function to place orders
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    order_value = current_price * quantity  # Calculate total cost of the order

    if buy:
        # Simulate buy order
        print(f"Simulating BUY: ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        total_capital_used_simulation += order_value
        buy_prices[ticker] = current_price  # Save the buy price in the dictionary
    else:
        # Get buy price (error handling for missing buy price)
        buy_price_sim = buy_prices.get(ticker, None)

        if buy_price_sim is None:
            print(f"Error: No buy price found for {ticker} before selling. Skipping sell.")
            return False

        # Simulate sell order
        print(f"Simulating SELL: {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f} per share. Previous buy price: ${buy_price_sim:.2f}")
        price_change = current_price - buy_price_sim
        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade

        total_pnl_simulation += trade_pnl_sim  # Update total P&L
        print(f"Profit/Loss for this trade: ${trade_pnl_sim:.2f}")

        # Store the trade in history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

# Function to simulate trades with detailed logging and profit tracking
def simulate_trades():
    for ticker, data in stock_data.items():
        # Check for buy/sell signals
        last_position = data['positions'].iloc[-1]

        if last_position == 1.0:  # Buy signal
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation

    # Print a summary of each trade
    print("\n--- Trade History ---")
    for trade in trade_history:
        print(f"{trade['ticker']}: Bought at ${trade['buy_price']:.2f}, Sold at ${trade['sell_price']:.2f}, P&L: ${trade['trade_pnl']:.2f}")

    # Print the total profit or loss for the day
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation to test the bot with $5 per trade and $200 daily limit
simulate_trades()

import yfinance as yf

# Define the ticker (Tesla, TSLA)
ticker = 'TSLA'

# Fetch historical stock data for the last day with 1-minute intervals
historical_data = yf.download(ticker, period='1d', interval='1m')

# Print the last few rows of data to check
print(historical_data.tail())

import yfinance as yf

# Define the ticker (Tesla, TSLA)
ticker = 'TSLA'

# Fetch historical stock data for the last day with 1-minute intervals
historical_data = yf.download(ticker, period='1d', interval='1m')

# Print the last few rows of data to check
print(historical_data.tail())

# Prepare the stock_data dictionary for simulation
stock_data = {
    ticker: historical_data.assign(positions=0)  # Add 'positions' column for buy/sell signals
}

# Log the data to ensure it is structured properly
print(stock_data[ticker].head())

import yfinance as yf

# Define the ticker (Tesla, TSLA)
ticker = 'TSLA'

# Fetch historical stock data for the last day with 1-minute intervals
historical_data = yf.download(ticker, period='1d', interval='1m')

# Check the structure of the data to ensure it has the necessary columns
print(historical_data.tail())

# Ensure it includes 'Close' price and set up the 'positions' column for signals
historical_data['positions'] = 0  # Placeholder for buy/sell signals

import numpy as np

# Example RSI calculation function (simplified)
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    data['RSI'] = rsi
    return data

# RSI strategy for generating buy/sell signals
def rsi_strategy(data):
    data = calculate_rsi(data)

    # Set thresholds for buy/sell signals
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 40, 1.0, data['signal'])  # Buy when RSI < 40
    data['signal'] = np.where(data['RSI'] > 60, -1.0, data['signal'])  # Sell when RSI > 60
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

# Apply the RSI strategy to the historical data
historical_data = rsi_strategy(historical_data)

# Confirm the signals were generated properly
print(historical_data[['Close', 'RSI', 'signal', 'positions']].tail())

# Function to simulate trades using buy/sell signals from the 'positions' column
def simulate_trades():
    for index, row in historical_data.iterrows():
        ticker = 'TSLA'  # Since we're using TSLA data
        current_price = row['Close']
        last_position = row['positions']  # Use generated signals for each row (timestamp)

        if last_position == 1.0:  # Buy signal
            if not simulate_order(ticker, fixed_amount=5, buy=True):
                break  # Stop if capital or loss limit is hit in simulation
        elif last_position == -1.0:  # Sell signal
            if not simulate_order(ticker, fixed_amount=5, buy=False):
                break  # Stop if capital or loss limit is hit in simulation

    # Print a summary of trades
    print("\n--- Trade History ---")
    for trade in trade_history:
        print(f"{trade['ticker']}: Bought at ${trade['buy_price']:.2f}, Sold at ${trade['sell_price']:.2f}, P&L: ${trade['trade_pnl']:.2f}")
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation
simulate_trades()

def rsi_strategy(data):
    data = calculate_rsi(data)

    # Set thresholds for buy/sell signals
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 40, 1.0, data['signal'])  # Buy when RSI < 40
    data['signal'] = np.where(data['RSI'] > 60, -1.0, data['signal'])  # Sell when RSI > 60
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    # Logging signal generation
    print(f"Generated signals for {data.shape[0]} rows")
    print(data[['Close', 'RSI', 'signal', 'positions']].tail())  # Show the last few rows

    return data

def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    if buy:
        # Log the buy order details
        print(f"Buying ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        stock_data[ticker]['buy_price_sim'] = current_price  # Save the buy price
    else:
        buy_price_sim = stock_data[ticker].get('buy_price_sim', None)

        if buy_price_sim is None:
            print(f"Error: No buy price found for {ticker}. Skipping sell.")
            return False

        # Log the sell order and price movement
        print(f"Selling {quantity:.6f} shares of {ticker} at ${current_price:.2f} per share.")
        price_change = current_price - buy_price_sim
        print(f"Price change for {ticker}: ${price_change:.2f}")

        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade
        total_pnl_simulation += trade_pnl_sim  # Update total P&L

        # Log P&L for the trade
        print(f"Profit/Loss for this trade: ${trade_pnl_sim:.2f}")

    return True

import yfinance as yf

# Fetch historical data for Tesla (TSLA)
ticker = 'TSLA'
historical_data = yf.download(ticker, period='1d', interval='1m')

# Add the positions column for signals
historical_data['positions'] = 0  # Placeholder for buy/sell signals

# Apply RSI strategy to generate signals
historical_data = rsi_strategy(historical_data)

# Simulate trades using the historical data
stock_data = {'TSLA': historical_data}  # Store data for simulation
simulate_trades()  # Run the simulation

# Initialize variables for simulation
total_pnl_simulation = 0.0  # Total P&L for the day
total_capital_used_simulation = 0.0  # Capital usage for the day
trade_history = []  # To store the history of each trade
buy_prices = {}  # Dictionary to track buy prices for each stock

# Simulated function to place orders
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    if buy:
        # Simulate buy order
        print(f"Simulating BUY: ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        total_capital_used_simulation += (current_price * quantity)
        buy_prices[ticker] = current_price  # Save the buy price for this ticker
    else:
        # Get the previously stored buy price for the ticker
        buy_price_sim = buy_prices.get(ticker, None)

        if buy_price_sim is None:
            print(f"Error: No buy price found for {ticker}. Skipping sell.")
            return False

        # Simulate sell order
        print(f"Simulating SELL: {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f} per share.")
        price_change = current_price - buy_price_sim

        # Log the price change
        print(f"Price change from buy to sell for {ticker}: ${price_change:.2f}")

        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade
        total_pnl_simulation += trade_pnl_sim  # Update total P&L

        # Log P&L for the trade
        print(f"Profit/Loss for this trade: ${trade_pnl_sim:.2f}")

        # Store the trade in history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

# Function to simulate trades using buy/sell signals from the 'positions' column
def simulate_trades():
    for ticker, data in stock_data.items():
        print(f"Simulating trades for {ticker}...")

        # Apply the signal strategy (if not already applied)
        data = rsi_strategy(data)

        for index, row in data.iterrows():
            current_price = row['Close']
            last_position = row['positions']  # Use generated signals for each row (timestamp)

            if last_position == 1.0:  # Buy signal
                if not simulate_order(ticker, fixed_amount=5, buy=True):
                    break  # Stop if capital or loss limit is hit in simulation
            elif last_position == -1.0:  # Sell signal
                if not simulate_order(ticker, fixed_amount=5, buy=False):
                    break  # Stop if capital or loss limit is hit in simulation

    # Print a summary of trades
    print("\n--- Trade History ---")
    for trade in trade_history:
        print(f"{trade['ticker']}: Bought at ${trade['buy_price']:.2f}, Sold at ${trade['sell_price']:.2f}, P&L: ${trade['trade_pnl']:.2f}")

    # Print the total profit or loss for the day
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation
simulate_trades()

def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    if buy:
        # Log the buy order details
        print(f"Simulating BUY: ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        total_capital_used_simulation += (current_price * quantity)
        buy_prices[ticker] = current_price  # Save the buy price for this ticker
    else:
        # Get the previously stored buy price for the ticker
        buy_price_sim = buy_prices.get(ticker, None)

        if buy_price_sim is None:
            print(f"Error: No buy price found for {ticker}. Skipping sell.")
            return False

        # Simulate sell order
        print(f"Simulating SELL: {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f} per share.")
        price_change = current_price - buy_price_sim

        # Log the price movement
        print(f"Price movement for {ticker}: Buy at ${buy_price_sim:.2f}, Sell at ${current_price:.2f}. Change: ${price_change:.2f}")

        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade
        total_pnl_simulation += trade_pnl_sim  # Update total P&L

        # Log P&L for the trade
        print(f"Profit/Loss for this trade: ${trade_pnl_sim:.2f}")

        # Store the trade in history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

def rsi_strategy(data):
    data = calculate_rsi(data)

    # Adjust RSI thresholds for more frequent trades
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 50, 1.0, data['signal'])  # Buy when RSI < 50
    data['signal'] = np.where(data['RSI'] > 50, -1.0, data['signal'])  # Sell when RSI > 50
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

import yfinance as yf

# Fetch historical data for Tesla (TSLA)
ticker = 'TSLA'
historical_data = yf.download(ticker, period='1d', interval='1m')

# Add the positions column for signals
historical_data['positions'] = 0  # Placeholder for buy/sell signals

# Apply RSI strategy to generate signals
historical_data = rsi_strategy(historical_data)

# Simulate trades using the historical data
stock_data = {'TSLA': historical_data}  # Store data for simulation
simulate_trades()  # Run the simulation

def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    if buy:
        # Simulate buy order and log the action
        print(f"[BUY] ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        total_capital_used_simulation += (current_price * quantity)
        buy_prices[ticker] = current_price  # Save the buy price for this ticker
        print(f"[BUY] Saved buy price for {ticker}: ${buy_prices[ticker]:.2f}")
    else:
        # Get the previously stored buy price for the ticker
        buy_price_sim = buy_prices.get(ticker, None)

        if buy_price_sim is None:
            print(f"[ERROR] No buy price found for {ticker}. Skipping sell.")
            return False

        # Simulate sell order and log the action
        print(f"[SELL] {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f} per share.")
        price_change = current_price - buy_price_sim

        # Log the price change and P&L
        print(f"[SELL] Price movement for {ticker}: Buy at ${buy_price_sim:.2f}, Sell at ${current_price:.2f}. Change: ${price_change:.2f}")

        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade
        total_pnl_simulation += trade_pnl_sim  # Update total P&L
        print(f"[SELL] Profit/Loss for this trade: ${trade_pnl_sim:.2f}")
        print(f"[SELL] Total P&L so far: ${total_pnl_simulation:.2f}")

        # Store the trade in history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

def rsi_strategy(data):
    data = calculate_rsi(data)

    # Adjust RSI thresholds for more frequent trades
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 50, 1.0, data['signal'])  # Buy when RSI < 50
    data['signal'] = np.where(data['RSI'] > 50, -1.0, data['signal'])  # Sell when RSI > 50
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    # Log buy/sell signals
    print(f"[RSI STRATEGY] Signals generated for {data.shape[0]} rows")
    print(data[['Close', 'RSI', 'signal', 'positions']].tail())  # Log the last few rows

    return data

import yfinance as yf

# Fetch historical data for Tesla (TSLA)
ticker = 'TSLA'
historical_data = yf.download(ticker, period='1d', interval='1m')

# Add the positions column for signals
historical_data['positions'] = 0  # Placeholder for buy/sell signals

# Apply RSI strategy to generate signals
historical_data = rsi_strategy(historical_data)

# Simulate trades using the historical data
stock_data = {'TSLA': historical_data}  # Store data for simulation
simulate_trades()  # Run the simulation

# Initialize variables for simulation
total_pnl_simulation = 0.0  # Total P&L for the day
total_capital_used_simulation = 0.0  # Capital usage for the day
trade_history = []  # To store the history of each trade
buy_prices = {}  # Dictionary to track buy prices for each stock

# Simulated function to place orders
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    if buy:
        # Simulate buy order and log the action
        print(f"[BUY] ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        total_capital_used_simulation += (current_price * quantity)
        buy_prices[ticker] = current_price  # Save the buy price for this ticker
        print(f"[BUY] Saved buy price for {ticker}: ${buy_prices[ticker]:.2f}")
    else:
        # Get the previously stored buy price for the ticker
        buy_price_sim = buy_prices.get(ticker, None)

        if buy_price_sim is None:
            print(f"[ERROR] No buy price found for {ticker}. Skipping sell.")
            return False

        # Simulate sell order and log the action
        print(f"[SELL] {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f} per share.")
        price_change = current_price - buy_price_sim

        # Log the price change and P&L
        print(f"[SELL] Price movement for {ticker}: Buy at ${buy_price_sim:.2f}, Sell at ${current_price:.2f}. Change: ${price_change:.2f}")

        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade
        total_pnl_simulation += trade_pnl_sim  # Update total P&L
        print(f"[SELL] Profit/Loss for this trade: ${trade_pnl_sim:.2f}")
        print(f"[SELL] Total P&L so far: ${total_pnl_simulation:.2f}")

        # Store the trade in history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

# Function to simulate trades using buy/sell signals from the 'positions' column
def simulate_trades():
    for ticker, data in stock_data.items():
        print(f"Simulating trades for {ticker}...")

        # Apply the signal strategy (if not already applied)
        data = rsi_strategy(data)

        for index, row in data.iterrows():
            current_price = row['Close']
            last_position = row['positions']  # Use generated signals for each row (timestamp)

            if last_position == 1.0:  # Buy signal
                print(f"[SIGNAL] Buy signal at {current_price:.2f}")
                if not simulate_order(ticker, fixed_amount=5, buy=True):
                    break  # Stop if capital or loss limit is hit in simulation
            elif last_position == -1.0:  # Sell signal
                print(f"[SIGNAL] Sell signal at {current_price:.2f}")
                if not simulate_order(ticker, fixed_amount=5, buy=False):
                    break  # Stop if capital or loss limit is hit in simulation

    # Print a summary of trades
    print("\n--- Trade History ---")
    for trade in trade_history:
        print(f"{trade['ticker']}: Bought at ${trade['buy_price']:.2f}, Sold at ${trade['sell_price']:.2f}, P&L: ${trade['trade_pnl']:.2f}")

    # Print the total profit or loss for the day
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation
simulate_trades()

import yfinance as yf

# Fetch historical data for Tesla (TSLA)
ticker = 'TSLA'
historical_data = yf.download(ticker, period='1d', interval='1m')

# Add the positions column for signals
historical_data['positions'] = 0  # Placeholder for buy/sell signals

# Apply RSI strategy to generate signals
historical_data = rsi_strategy(historical_data)

# Simulate trades using the historical data
stock_data = {'TSLA': historical_data}  # Store data for simulation
simulate_trades()  # Run the simulation

# Initialize variables for simulation
total_pnl_simulation = 0.0  # Total P&L for the day
total_capital_used_simulation = 0.0  # Capital usage for the day
trade_history = []  # To store the history of each trade
buy_prices = {}  # Dictionary to track buy prices for each stock

# Simulated function to place orders
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    if buy:
        # Simulate buy order and log the action
        print(f"[BUY] ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        total_capital_used_simulation += (current_price * quantity)
        buy_prices[ticker] = current_price  # Save the buy price for this ticker
        print(f"[BUY] Saved buy price for {ticker}: ${buy_prices[ticker]:.2f}")
    else:
        # Get the previously stored buy price for the ticker
        buy_price_sim = buy_prices.get(ticker, None)

        if buy_price_sim is None:
            print(f"[ERROR] No buy price found for {ticker}. Skipping sell.")
            return False

        # Simulate sell order and log the action
        print(f"[SELL] {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f} per share.")
        price_change = current_price - buy_price_sim

        # Log the price change and P&L
        print(f"[SELL] Price movement for {ticker}: Buy at ${buy_price_sim:.2f}, Sell at ${current_price:.2f}. Change: ${price_change:.2f}")

        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade
        total_pnl_simulation += trade_pnl_sim  # Update total P&L
        print(f"[SELL] Profit/Loss for this trade: ${trade_pnl_sim:.2f}")
        print(f"[SELL] Total P&L so far: ${total_pnl_simulation:.2f}")

        # Store the trade in history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

# Function to simulate trades using buy/sell signals from the 'positions' column
def simulate_trades():
    for ticker, data in stock_data.items():
        print(f"Simulating trades for {ticker}...")

        # Apply the signal strategy (if not already applied)
        data = rsi_strategy(data)

        for index, row in data.iterrows():
            current_price = row['Close']
            last_position = row['positions']  # Use generated signals for each row (timestamp)

            if last_position == 1.0:  # Buy signal
                print(f"[SIGNAL] Buy signal at {current_price:.2f}")
                if not simulate_order(ticker, fixed_amount=5, buy=True):
                    break  # Stop if capital or loss limit is hit in simulation
            elif last_position == -1.0:  # Sell signal
                print(f"[SIGNAL] Sell signal at {current_price:.2f}")
                if not simulate_order(ticker, fixed_amount=5, buy=False):
                    break  # Stop if capital or loss limit is hit in simulation

    # Print a summary of trades
    print("\n--- Trade History ---")
    for trade in trade_history:
        print(f"{trade['ticker']}: Bought at ${trade['buy_price']:.2f}, Sold at ${trade['sell_price']:.2f}, P&L: ${trade['trade_pnl']:.2f}")

    # Print the total profit or loss for the day
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation
simulate_trades()

import yfinance as yf

# Fetch historical data for Tesla (TSLA)
ticker = 'TSLA'
historical_data = yf.download(ticker, period='1d', interval='1m')

# Add the positions column for signals
historical_data['positions'] = 0  # Placeholder for buy/sell signals

# Apply RSI strategy to generate signals
historical_data = rsi_strategy(historical_data)

# Simulate trades using the historical data
stock_data = {'TSLA': historical_data}  # Store data for simulation
simulate_trades()  # Run the simulation

import pandas as pd

# Manually create a dataset with known price movements
data = {
    'Close': [100, 105, 110, 95, 120, 80],  # Simulated prices
    'positions': [0, 1, 0, -1, 1, -1]  # Simulated buy (1) and sell (-1) signals
}

# Create a DataFrame from this data
historical_data = pd.DataFrame(data)

# Use this data for simulation
stock_data = {'TEST': historical_data}  # Use 'TEST' as the stock symbol

# Initialize variables for simulation
total_pnl_simulation = 0.0  # Total P&L for the day
total_capital_used_simulation = 0.0  # Capital usage for the day
trade_history = []  # To store the history of each trade
buy_prices = {}  # Dictionary to track buy prices for each stock

# Simulated function to place orders
def simulate_order(ticker, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Get the current price for the stock
    current_price = stock_data[ticker]['Close'].iloc[-1]

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    if buy:
        # Simulate buy order and log the action
        print(f"[BUY] ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        total_capital_used_simulation += (current_price * quantity)
        buy_prices[ticker] = current_price  # Save the buy price for this ticker
        print(f"[BUY] Saved buy price for {ticker}: ${buy_prices[ticker]:.2f}")
    else:
        # Get the previously stored buy price for the ticker
        buy_price_sim = buy_prices.get(ticker, None)

        if buy_price_sim is None:
            print(f"[ERROR] No buy price found for {ticker}. Skipping sell.")
            return False

        # Simulate sell order and log the action
        print(f"[SELL] {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f} per share.")
        price_change = current_price - buy_price_sim

        # Log the price change and P&L
        print(f"[SELL] Price movement for {ticker}: Buy at ${buy_price_sim:.2f}, Sell at ${current_price:.2f}. Change: ${price_change:.2f}")

        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade
        total_pnl_simulation += trade_pnl_sim  # Update total P&L
        print(f"[SELL] Profit/Loss for this trade: ${trade_pnl_sim:.2f}")
        print(f"[SELL] Total P&L so far: ${total_pnl_simulation:.2f}")

        # Store the trade in history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

# Function to simulate trades using buy/sell signals from the 'positions' column
def simulate_trades():
    for ticker, data in stock_data.items():
        print(f"Simulating trades for {ticker}...")

        for index, row in data.iterrows():
            current_price = row['Close']
            last_position = row['positions']  # Use generated signals for each row (timestamp)

            if last_position == 1.0:  # Buy signal
                print(f"[SIGNAL] Buy signal at {current_price:.2f}")
                if not simulate_order(ticker, fixed_amount=5, buy=True):
                    break  # Stop if capital or loss limit is hit in simulation
            elif last_position == -1.0:  # Sell signal
                print(f"[SIGNAL] Sell signal at {current_price:.2f}")
                if not simulate_order(ticker, fixed_amount=5, buy=False):
                    break  # Stop if capital or loss limit is hit in simulation

    # Print a summary of trades
    print("\n--- Trade History ---")
    for trade in trade_history:
        print(f"{trade['ticker']}: Bought at ${trade['buy_price']:.2f}, Sold at ${trade['sell_price']:.2f}, P&L: ${trade['trade_pnl']:.2f}")

    # Print the total profit or loss for the day
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation with the forced data
simulate_trades()

# Initialize variables for simulation
total_pnl_simulation = 0.0  # Total P&L for the day
total_capital_used_simulation = 0.0  # Capital usage for the day
trade_history = []  # To store the history of each trade
buy_prices = {}  # Dictionary to track buy prices for each stock

# Simulated function to place orders
def simulate_order(ticker, current_price, fixed_amount=5, buy=True):
    global total_capital_used_simulation, total_pnl_simulation

    # Calculate fractional shares to buy with $5
    quantity = fixed_amount / current_price  # Fractional shares based on $5

    if buy:
        # Simulate buy order and log the action
        print(f"[BUY] ${fixed_amount} worth of {ticker} at ${current_price:.2f} per share.")
        total_capital_used_simulation += (current_price * quantity)
        buy_prices[ticker] = current_price  # Save the buy price for this ticker
        print(f"[BUY] Saved buy price for {ticker}: ${buy_prices[ticker]:.2f}")
    else:
        # Get the previously stored buy price for the ticker
        buy_price_sim = buy_prices.get(ticker, None)

        if buy_price_sim is None:
            print(f"[ERROR] No buy price found for {ticker}. Skipping sell.")
            return False

        # Simulate sell order and log the action
        print(f"[SELL] {quantity:.6f} fractional shares of {ticker} at ${current_price:.2f} per share.")
        price_change = current_price - buy_price_sim

        # Log the price change and P&L
        print(f"[SELL] Price movement for {ticker}: Buy at ${buy_price_sim:.2f}, Sell at ${current_price:.2f}. Change: ${price_change:.2f}")

        trade_pnl_sim = price_change * quantity  # Calculate P&L for this trade
        total_pnl_simulation += trade_pnl_sim  # Update total P&L
        print(f"[SELL] Profit/Loss for this trade: ${trade_pnl_sim:.2f}")
        print(f"[SELL] Total P&L so far: ${total_pnl_simulation:.2f}")

        # Store the trade in history
        trade_history.append({
            'ticker': ticker,
            'quantity': quantity,
            'buy_price': buy_price_sim,
            'sell_price': current_price,
            'trade_pnl': trade_pnl_sim
        })

    return True

# Function to simulate trades using buy/sell signals from the 'positions' column
def simulate_trades():
    for ticker, data in stock_data.items():
        print(f"Simulating trades for {ticker}...")

        for index, row in data.iterrows():
            current_price = row['Close']  # Use the row's price directly for the buy/sell action
            last_position = row['positions']  # Use generated signals for each row (timestamp)

            if last_position == 1.0:  # Buy signal
                print(f"[SIGNAL] Buy signal at {current_price:.2f}")
                if not simulate_order(ticker, current_price, fixed_amount=5, buy=True):
                    break  # Stop if capital or loss limit is hit in simulation
            elif last_position == -1.0:  # Sell signal
                print(f"[SIGNAL] Sell signal at {current_price:.2f}")
                if not simulate_order(ticker, current_price, fixed_amount=5, buy=False):
                    break  # Stop if capital or loss limit is hit in simulation

    # Print a summary of trades
    print("\n--- Trade History ---")
    for trade in trade_history:
        print(f"{trade['ticker']}: Bought at ${trade['buy_price']:.2f}, Sold at ${trade['sell_price']:.2f}, P&L: ${trade['trade_pnl']:.2f}")

    # Print the total profit or loss for the day
    print(f"\nSimulation completed. Total profit/loss for the day: ${total_pnl_simulation:.2f}")

# Run the simulation with the corrected price handling
simulate_trades()

import pandas as pd

# Manually create a dataset with known price movements
data = {
    'Close': [100, 105, 110, 95, 120, 80],  # Simulated prices with clear movements
    'positions': [0, 1, 0, -1, 1, -1]  # Simulated buy (1) and sell (-1) signals
}

# Create a DataFrame from this data
historical_data = pd.DataFrame(data)

# Use this data for simulation
stock_data = {'TEST': historical_data}  # Use 'TEST' as the stock symbol
simulate_trades()  # Run the simulation

def rsi_strategy(data):
    data = calculate_rsi(data)

    # Adjust RSI thresholds for more optimized trades
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 40, 1.0, data['signal'])  # Buy when RSI < 40
    data['signal'] = np.where(data['RSI'] > 60, -1.0, data['signal'])  # Sell when RSI > 60
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

import yfinance as yf

# Fetch historical data for Tesla (TSLA)
ticker = 'TSLA'
historical_data = yf.download(ticker, period='1d', interval='1m')

# Add the positions column for signals
historical_data['positions'] = 0  # Placeholder for buy/sell signals

# Apply RSI strategy to generate signals
historical_data = rsi_strategy(historical_data)

# Simulate trades using the historical data
stock_data = {'TSLA': historical_data}  # Store data for simulation
simulate_trades()  # Run the simulation

def rsi_strategy(data):
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 35, 1.0, data['signal'])  # Buy when RSI < 35
    data['signal'] = np.where(data['RSI'] > 65, -1.0, data['signal'])  # Sell when RSI > 65
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions
    return data

import yfinance as yf

# Fetch real-time data for Tesla (TSLA)
ticker = 'TSLA'
data = yf.download(ticker, period='1d', interval='1m')

# Print the last few rows to verify the data is loaded
print(data.tail())

import numpy as np

# RSI calculation function
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    data['RSI'] = rsi
    return data

# Apply RSI calculation
data = calculate_rsi(data)
print(data[['Close', 'RSI']].tail())  # Check the last few rows for RSI values

def rsi_strategy(data):
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 35, 1.0, data['signal'])  # Buy when RSI < 35
    data['signal'] = np.where(data['RSI'] > 65, -1.0, data['signal'])  # Sell when RSI > 65
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    # Log the last few rows to ensure signals are generated
    print(data[['Close', 'RSI', 'signal', 'positions']].tail())

    return data

# Apply the RSI strategy
data = rsi_strategy(data)

buy_prices = {}

def simulate_trades(data, ticker, amount=5):
    total_pnl = 0  # Initialize total profit and loss
    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            print(f"Buying {ticker} at ${current_price:.2f}")
        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price  # Calculate profit/loss
            total_pnl += profit
            print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
            del buy_prices[ticker]  # Remove the buy price after selling

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

# Run the trade simulation
simulate_trades(data, ticker='TSLA')

# Fetch only the last 5 minutes of data instead of the entire day
data = yf.download(ticker, period='5m', interval='1m')

import yfinance as yf
import pandas as pd

# Use historical data for testing while the market is closed
def run_bot():
    ticker = 'TSLA'
    cached_data = pd.DataFrame()  # Initialize an empty DataFrame for cached data

    # Fetch historical data for the previous day
    new_data = yf.download(ticker, period='1d', interval='1m')
    cached_data = pd.concat([cached_data, new_data])

    # Drop duplicates and apply RSI strategy
    cached_data = cached_data.drop_duplicates()
    cached_data = calculate_rsi(cached_data)
    cached_data = rsi_strategy(cached_data)

    # Simulate trades with the historical data
    simulate_trades_with_loss_limit(cached_data, ticker=ticker)

# Run the testing bot
run_bot()

import yfinance as yf
import pandas as pd
import numpy as np

# Define a single stock ticker for testing
ticker = 'AAPL'

# Fetch historical data for the last day
data = yf.download(ticker, period='1d', interval='1m')

# Display the fetched data
print(data.head())

import yfinance as yf
import pandas as pd
import numpy as np
import datetime

# Define the top 25 stock tickers
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA', 'FB', 'NFLX', 'NVDA', 'BRK.B', 'JPM',
           'V', 'JNJ', 'PG', 'DIS', 'PYPL', 'ADBE', 'INTC', 'CMCSA', 'PEP', 'T',
           'CSCO', 'VZ', 'NKE', 'MRK', 'XOM']

# Constants for trading
investment_per_trade = 5  # Max investment per trade
daily_loss_limit = -50  # Max daily loss
total_daily_capital = 200  # Total capital used per day

# Initialize variables
daily_pnl = 0  # Total profit and loss for the day
daily_invested = {ticker: 0 for ticker in tickers}  # Track capital used for each stock
buy_prices = {}  # To store buy prices for each ticker

# RSI calculation function
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    data['RSI'] = rsi
    return data

# Generate buy/sell signals using RSI
def rsi_strategy(data):
    data['signal'] = 0.0
    data['signal'] = np.where(data['RSI'] < 30, 1.0, data['signal'])  # Buy when RSI < 30
    data['signal'] = np.where(data['RSI'] > 70, -1.0, data['signal'])  # Sell when RSI > 70
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions
    return data

# Simulate trades with daily loss limit and stop-loss
stop_loss_percentage = 0.05  # Stop-loss at 5%

def simulate_trades_with_loss_limit(data, ticker):
    global daily_pnl, daily_invested

    total_pnl = 0  # Initialize total profit/loss for this stock
    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']

        # Check if we have enough daily capital left
        if daily_invested[ticker] < total_daily_capital:
            if signal == 1.0:  # Buy signal
                buy_prices[ticker] = current_price
                daily_invested[ticker] += investment_per_trade
                print(f"Buying {ticker} at ${current_price:.2f} with ${investment_per_trade}")
            elif signal == -1.0 and ticker in buy_prices:  # Sell signal
                buy_price = buy_prices[ticker]
                profit = current_price - buy_price

                # Apply stop-loss: exit if the price drops more than 5% from the buy price
                if (current_price - buy_price) / buy_price < -stop_loss_percentage:
                    print(f"Stop-loss triggered for {ticker}. Selling at ${current_price:.2f}. Loss: ${profit:.2f}")
                    total_pnl += profit
                    del buy_prices[ticker]
                    break  # Exit loop after triggering stop-loss

                total_pnl += profit
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]

        # Update the total daily profit/loss
        daily_pnl += total_pnl

        # Stop trading if daily loss limit is hit
        if daily_pnl <= daily_loss_limit:
            print(f"Daily loss limit of ${daily_loss_limit} reached. Stopping trades for the day.")
            break

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

# Backtesting function
def backtest_bot():
    global daily_pnl, daily_invested
    cached_data = pd.DataFrame()  # Initialize an empty DataFrame for cached data

    for ticker in tickers:
        # Fetch historical data for the past day
        new_data = yf.download(ticker, period='1d', interval='1m')

        # Concatenate the new data with cached data
        cached_data = pd.concat([cached_data, new_data])

        # Drop any duplicate entries
        cached_data = cached_data.drop_duplicates()

        # Apply RSI strategy
        cached_data = calculate_rsi(cached_data)
        cached_data = rsi_strategy(cached_data)

        # Simulate trades with the improved strategy
        simulate_trades_with_loss_limit(cached_data, ticker=ticker)

    print("Backtesting completed.")

# Run the backtesting function
backtest_bot()

# Add Moving Average calculations
def calculate_moving_averages(data, short_window=5, long_window=20):
    data['SMA_short'] = data['Close'].rolling(window=short_window).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=long_window).mean()  # Long-term SMA
    return data

# Generate buy/sell signals using RSI and Moving Averages
def multi_indicator_strategy(data):
    data = rsi_strategy(data)  # First apply the RSI strategy
    data = calculate_moving_averages(data)  # Then calculate moving averages

    # Add conditions for buy/sell signals
    data['signal'] = 0.0
    # Buy signal: RSI < 30 and short SMA > long SMA
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])
    # Sell signal: RSI > 70 and short SMA < long SMA
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])

    data['positions'] = data['signal'].diff()  # Generate buy/sell positions
    return data

# Real-time bot with caching and minute-by-minute data fetch
def run_bot():
    global daily_pnl, daily_invested
    cached_data = pd.DataFrame()  # Initialize an empty DataFrame for cached data

    while True:
        if is_market_open():
            for ticker in tickers:
                # Fetch only the last 1 minute of data for each stock
                new_data = yf.download(ticker, period='1m', interval='1m')

                # Concatenate the new data with cached data
                cached_data = pd.concat([cached_data, new_data])

                # Drop any duplicate entries
                cached_data = cached_data.drop_duplicates()

                # Apply multi-indicator strategy
                cached_data = multi_indicator_strategy(cached_data)

                # Simulate trades with the improved strategy
                simulate_trades_with_loss_limit(cached_data, ticker=ticker)

        # Wait for 60 seconds before running again
        time.sleep(60)

# Trailing stop-loss and take-profit adjustments
def simulate_trades_with_loss_limit(data, ticker):
    global daily_pnl, daily_invested

    total_pnl = 0  # Initialize total profit/loss for this stock
    highest_price = 0  # To track the highest price for trailing stop-loss

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']

        # Check if we have enough daily capital left
        if daily_invested[ticker] < total_daily_capital:
            if signal == 1.0:  # Buy signal
                buy_prices[ticker] = current_price
                daily_invested[ticker] += investment_per_trade
                highest_price = current_price  # Set highest price to current
                print(f"Buying {ticker} at ${current_price:.2f} with ${investment_per_trade}")

            elif ticker in buy_prices:  # Check for sell conditions
                buy_price = buy_prices[ticker]

                # Update the highest price for trailing stop
                highest_price = max(highest_price, current_price)

                # Check for take-profit condition (e.g., sell if profit is 10%)
                if current_price >= buy_price * 1.10:
                    profit = current_price - buy_price
                    total_pnl += profit
                    print(f"Take profit triggered for {ticker}. Selling at ${current_price:.2f}. Profit: ${profit:.2f}")
                    del buy_prices[ticker]
                    break  # Exit after selling

                # Check for trailing stop-loss condition (5% below highest price)
                if current_price <= highest_price * (1 - stop_loss_percentage):
                    profit = current_price - buy_price
                    total_pnl += profit
                    print(f"Trailing stop-loss triggered for {ticker}. Selling at ${current_price:.2f}. Profit: ${profit:.2f}")
                    del buy_prices[ticker]
                    break  # Exit after selling

        # Update the total daily profit/loss
        daily_pnl += total_pnl

        # Stop trading if daily loss limit is hit
        if daily_pnl <= daily_loss_limit:
            print(f"Daily loss limit of ${daily_loss_limit} reached. Stopping trades for the day.")
            break

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

# Function to calculate dynamic allocation based on performance
def calculate_dynamic_allocation():
    allocation = {}
    total_investment = sum(daily_invested.values())

    for ticker in tickers:
        # Avoid division by zero
        if total_investment > 0:
            allocation[ticker] = daily_invested[ticker] / total_investment
        else:
            allocation[ticker] = 0

    return allocation

# Modify the trade simulation to use dynamic allocation
def simulate_trades_with_dynamic_allocation(data, ticker):
    global daily_pnl, daily_invested

    total_pnl = 0  # Initialize total profit/loss for this stock
    highest_price = 0  # To track the highest price for trailing stop-loss
    allocation = calculate_dynamic_allocation()  # Get current allocation

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']

        # Check if we have enough daily capital left based on dynamic allocation
        if daily_invested[ticker] < total_daily_capital:
            # Calculate investment amount based on dynamic allocation
            investment_amount = total_daily_capital * allocation[ticker]

            if signal == 1.0 and investment_amount > 0:  # Buy signal
                buy_prices[ticker] = current_price
                daily_invested[ticker] += investment_per_trade
                highest_price = current_price  # Set highest price to current
                print(f"Buying {ticker} at ${current_price:.2f} with ${investment_per_trade}")

            elif ticker in buy_prices:  # Check for sell conditions
                buy_price = buy_prices[ticker]

                # Update the highest price for trailing stop
                highest_price = max(highest_price, current_price)

                # Check for take-profit condition (e.g., sell if profit is 10%)
                if current_price >= buy_price * 1.10:
                    profit = current_price - buy_price
                    total_pnl += profit
                    print(f"Take profit triggered for {ticker}. Selling at ${current_price:.2f}. Profit: ${profit:.2f}")
                    del buy_prices[ticker]
                    break  # Exit after selling

                # Check for trailing stop-loss condition (5% below highest price)
                if current_price <= highest_price * (1 - stop_loss_percentage):
                    profit = current_price - buy_price
                    total_pnl += profit
                    print(f"Trailing stop-loss triggered for {ticker}. Selling at ${current_price:.2f}. Profit: ${profit:.2f}")
                    del buy_prices[ticker]
                    break  # Exit after selling

        # Update the total daily profit/loss
        daily_pnl += total_pnl

        # Stop trading if daily loss limit is hit
        if daily_pnl <= daily_loss_limit:
            print(f"Daily loss limit of ${daily_loss_limit} reached. Stopping trades for the day.")
            break

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

import random

# Initialize Q-table
q_table = {}  # This will hold state-action pairs

# Define actions
actions = ['buy', 'sell', 'hold']

# Q-learning parameters
alpha = 0.1  # Learning rate
gamma = 0.9  # Discount factor
epsilon = 0.1  # Exploration rate

def choose_action(state):
    # Epsilon-greedy action selection
    if random.uniform(0, 1) < epsilon:
        return random.choice(actions)  # Explore
    else:
        return max(q_table.get(state, {action: 0 for action in actions}), key=q_table.get)  # Exploit

def update_q_table(state, action, reward, next_state):
    # Update Q-value based on the Bellman equation
    current_q = q_table.get(state, {}).get(action, 0)
    max_future_q = max(q_table.get(next_state, {action: 0 for action in actions}).values())
    new_q = current_q + alpha * (reward + gamma * max_future_q - current_q)

    if state not in q_table:
        q_table[state] = {}
    q_table[state][action] = new_q

# Update the trade simulation to use Q-learning
def simulate_trades_with_q_learning(data, ticker):
    global daily_pnl, daily_invested

    total_pnl = 0
    highest_price = 0
    state = (ticker, 0)  # Example state representation

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']

        # Determine the action based on Q-learning
        action = choose_action(state)

        if daily_invested[ticker] < total_daily_capital:
            if action == 'buy' and signal == 1.0:  # Buy signal
                buy_prices[ticker] = current_price
                daily_invested[ticker] += investment_per_trade
                highest_price = current_price
                print(f"Buying {ticker} at ${current_price:.2f} with ${investment_per_trade}")
                next_state = (ticker, 1)  # Example next state representation
            elif action == 'sell' and ticker in buy_prices:  # Sell signal
                buy_price = buy_prices[ticker]
                profit = current_price - buy_price

                # Implement trailing stop-loss or take-profit conditions here...
                # You may want to add this logic based on previous implementations

                total_pnl += profit
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
                next_state = (ticker, -1)  # Example next state representation
            else:
                next_state = (ticker, 0)  # No action taken

            reward = total_pnl  # Reward based on profit/loss
            update_q_table(state, action, reward, next_state)  # Update Q-table
            state = next_state  # Move to the next state

        # Update total daily profit/loss and stop trading if needed...

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

def backtest_bot():
    global daily_pnl, daily_invested
    cached_data = pd.DataFrame()  # Initialize an empty DataFrame for cached data

    for ticker in tickers:
        # Fetch historical data for the past day
        new_data = yf.download(ticker, period='1d', interval='1m')

        # Concatenate the new data with cached data
        cached_data = pd.concat([cached_data, new_data])

        # Drop any duplicate entries
        cached_data = cached_data.drop_duplicates()

        # Apply the Q-learning strategy
        simulate_trades_with_q_learning(cached_data, ticker)

    print("Backtesting completed.")

def backtest_bot():
    global daily_pnl, daily_invested
    for ticker in tickers:
        print(f"Fetching data for {ticker}...")
        new_data = yf.download(ticker, period='1d', interval='1m')

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}: {new_data.head()}")
        new_data = multi_indicator_strategy(new_data)  # Apply the strategy

        if new_data is not None:  # Ensure the strategy returned data
            simulate_trades_with_q_learning(new_data, ticker)
        else:
            print(f"No valid data for trading strategy for {ticker}.")

    print("Backtesting completed.")

!pip install textblob

from textblob import TextBlob

def analyze_sentiment(text):
    analysis = TextBlob(text)
    return analysis.sentiment.polarity  # Returns a sentiment score between -1 (negative) and 1 (positive)

import requests

def fetch_news(ticker):
    url = f"https://newsapi.org/v2/everything?q={ticker}&apiKey=YOUR_API_KEY"
    response = requests.get(url)
    articles = response.json().get('articles', [])

    return articles

def integrate_sentiment(data, ticker):
    articles = fetch_news(ticker)
    sentiments = []

    for article in articles:
        text = article['title']  # You can analyze the title or the full article
        sentiment_score = analyze_sentiment(text)
        sentiments.append(sentiment_score)

    # Average sentiment score
    avg_sentiment = np.mean(sentiments) if sentiments else 0

    # Adjust trading signals based on sentiment
    if avg_sentiment > 0.1:  # Positive sentiment
        data['signal'] = np.where(data['RSI'] < 30, 1.0, data['signal'])
    elif avg_sentiment < -0.1:  # Negative sentiment
        data['signal'] = np.where(data['RSI'] > 70, -1.0, data['signal'])

    return data

def time_based_signals(data):
    data['time_signal'] = 0.0
    current_time = datetime.datetime.now().time()

    # Define trading windows (for example purposes)
    opening_window = (datetime.time(9, 30), datetime.time(10, 0))  # First 30 minutes
    midday_window = (datetime.time(12, 0), datetime.time(13, 0))  # Around noon
    closing_window = (datetime.time(15, 30), datetime.time(16, 0))  # Last 30 minutes

    # Add signals based on time windows
    for index, row in data.iterrows():
        if opening_window[0] <= row.name.time() <= opening_window[1]:
            data.at[index, 'time_signal'] = 1.0  # Favor buying in the opening window
        elif midday_window[0] <= row.name.time() <= midday_window[1]:
            data.at[index, 'time_signal'] = 0.5  # Neutral during midday
        elif closing_window[0] <= row.name.time() <= closing_window[1]:
            data.at[index, 'time_signal'] = -1.0  # Favor selling in the closing window

    return data

def integrate_time_signals(data):
    data = multi_indicator_strategy(data)  # Apply existing strategy first
    data = time_based_signals(data)  # Apply time-based signals

    # Combine time-based signals with existing signals
    data['signal'] = np.where((data['signal'] == 1.0) & (data['time_signal'] == 1.0), 1.0, data['signal'])  # Buy
    data['signal'] = np.where((data['signal'] == -1.0) & (data['time_signal'] == -1.0), -1.0, data['signal'])  # Sell

    return data

import requests

def fetch_news(ticker):
    url = f"https://newsapi.org/v2/everything?q={ticker}&apiKey=YOUR_API_KEY"
    response = requests.get(url)

    if response.status_code == 200:
        articles = response.json().get('articles', [])
        return articles
    else:
        print(f"Error fetching news for {ticker}: {response.status_code}")
        return []

def analyze_and_alert(ticker):
    articles = fetch_news(ticker)
    sentiments = []

    for article in articles:
        text = article['title']  # You can analyze the title or the full article
        sentiment_score = analyze_sentiment(text)
        sentiments.append(sentiment_score)

    # Average sentiment score
    avg_sentiment = np.mean(sentiments) if sentiments else 0
    print(f"Average sentiment for {ticker}: {avg_sentiment:.2f}")

    # Trigger alerts based on sentiment
    if avg_sentiment > 0.1:  # Positive sentiment
        print(f"Positive news for {ticker}. Consider buying.")
    elif avg_sentiment < -0.1:  # Negative sentiment
        print(f"Negative news for {ticker}. Consider selling.")

def run_bot_with_news_alerts():
    global daily_pnl, daily_invested
    cached_data = pd.DataFrame()  # Initialize an empty DataFrame for cached data

    while True:
        if is_market_open():
            for ticker in tickers:
                # Fetch only the last 1 minute of data for each stock
                new_data = yf.download(ticker, period='1m', interval='1m')

                # Concatenate the new data with cached data
                cached_data = pd.concat([cached_data, new_data])

                # Drop any duplicate entries
                cached_data = cached_data.drop_duplicates()

                # Apply multi-indicator strategy
                cached_data = integrate_time_signals(cached_data)  # Use your existing time signals

                # Analyze news and trigger alerts
                analyze_and_alert(ticker)

                # Simulate trades with the improved strategy
                simulate_trades_with_q_learning(cached_data, ticker=ticker)

        # Wait for 60 seconds before running again
        time.sleep(60)

def calculate_volatility(data, window=20):
    return data['Close'].pct_change().rolling(window=window).std()  # Standard deviation of daily returns

def calculate_risk_parity_allocation():
    allocation = {}
    total_risk = 0

    for ticker in tickers:
        # Get historical data
        historical_data = yf.download(ticker, period='1mo', interval='1d')  # Last month of daily data
        volatility = calculate_volatility(historical_data)
        avg_volatility = volatility.mean() if volatility.any() else 1  # Avoid division by zero
        allocation[ticker] = 1 / avg_volatility  # Inverse volatility for allocation
        total_risk += allocation[ticker]

    # Normalize the allocation to sum to 1
    for ticker in allocation:
        allocation[ticker] /= total_risk

    return allocation

def simulate_trades_with_risk_parity(data, ticker):
    global daily_pnl, daily_invested

    # Get dynamic allocation based on risk parity
    allocation = calculate_risk_parity_allocation()
    total_pnl = 0
    highest_price = 0
    state = (ticker, 0)  # Example state representation

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']

        # Check if we have enough daily capital left based on risk allocation
        investment_amount = total_daily_capital * allocation[ticker]

        if daily_invested[ticker] < investment_amount:
            if signal == 1.0 and investment_amount > 0:  # Buy signal
                buy_prices[ticker] = current_price
                daily_invested[ticker] += investment_per_trade
                highest_price = current_price
                print(f"Buying {ticker} at ${current_price:.2f} with ${investment_per_trade}")

            elif signal == -1.0 and ticker in buy_prices:  # Sell signal
                buy_price = buy_prices[ticker]
                profit = current_price - buy_price
                total_pnl += profit
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]

        # Continue implementing stop-loss, take-profit, and daily P&L logic...

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

class Backtest:
    def __init__(self, strategy, data):
        self.strategy = strategy  # Strategy to use (e.g., Q-learning, multi-indicator)
        self.data = data  # Historical data
        self.results = []  # To store results of trades
        self.total_profit = 0

    def run(self):
        for ticker in tickers:
            self.strategy(self.data, ticker)  # Run the trading strategy on historical data

    def record_trade(self, trade):
        self.results.append(trade)
        self.total_profit += trade['profit']

    def generate_report(self):
        print("Backtesting Results:")
        print(f"Total Profit: ${self.total_profit:.2f}")
        # Additional metrics can be calculated and printed here

def simulate_trades_with_backtest(data, ticker):
    global daily_pnl, daily_invested

    backtest = Backtest(strategy=simulate_trades_with_q_learning, data=data)
    backtest.run()  # Run the backtest

    # Print results
    backtest.generate_report()

def backtest_bot():
    global daily_pnl, daily_invested
    for ticker in tickers:
        print(f"Fetching data for {ticker}...")
        new_data = yf.download(ticker, period='1mo', interval='1d')  # Use a longer period for better results

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}: {new_data.head()}")

        # Create a backtest instance
        backtest = Backtest(strategy=simulate_trades_with_q_learning, data=new_data)
        backtest.run()  # Run the backtest for each ticker
        backtest.generate_report()  # Generate the report after each backtest

    print("Backtesting completed.")

def print_summary():
    print("\n--- Trading Bot Summary ---")
    print(f"Total Daily P&L: ${daily_pnl:.2f}")
    for ticker, invested in daily_invested.items():
        print(f"{ticker}: Invested ${invested:.2f}")

def user_commands():
    while True:
        command = input("\nEnter command (start/stop/status/exit): ").strip().lower()

        if command == "start":
            print("Starting trading bot...")
            run_bot_with_news_alerts()  # Start the trading bot
        elif command == "stop":
            print("Stopping trading bot...")
            break  # You may want to set a flag for the trading loop to exit gracefully
        elif command == "status":
            print_summary()  # Print current trading summary
        elif command == "exit":
            print("Exiting trading bot...")
            break
        else:
            print("Invalid command. Please try again.")

def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"Fetching data for {ticker} for the last week...")
        new_data = yf.download(ticker, period='7d', interval='1m')  # Fetch last week's data

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}: {new_data.head()}")

        # Run the trading simulation with Q-learning
        simulate_trades_with_q_learning(new_data, ticker)

        # At the end of the week, calculate and sum up profits
        total_weekly_profit += daily_pnl  # Assume daily_pnl tracks the weekly performance

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

def simulate_trades_with_q_learning(data, ticker):
    global daily_pnl, daily_invested

    total_pnl = 0
    highest_price = 0
    state = (ticker, 0)  # Example state representation

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']  # Buy/Sell signals

        # Debug: Print current price and signal
        print(f"Current Price: {current_price:.2f}, Signal: {signal}")

        # Determine action based on Q-learning
        action = choose_action(state)

        if daily_invested[ticker] < total_daily_capital:
            if action == 'buy' and signal == 1.0:  # Buy signal
                buy_prices[ticker] = current_price
                daily_invested[ticker] += investment_per_trade
                highest_price = current_price
                print(f"Buying {ticker} at ${current_price:.2f} with ${investment_per_trade}")

            elif action == 'sell' and ticker in buy_prices:  # Sell signal
                buy_price = buy_prices[ticker]
                profit = current_price - buy_price

                if profit > 0:  # Only count profits
                    total_pnl += profit
                    print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                    del buy_prices[ticker]
                else:
                    print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

        # Update daily profit/loss
        daily_pnl += total_pnl

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

def simulate_trades_with_q_learning(data, ticker):
    global daily_pnl, daily_invested

    total_pnl = 0
    highest_price = 0
    state = (ticker, 0)  # Example state representation

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']  # Buy/Sell signals

        # Debug: Print current price and signal
        print(f"Current Price: {current_price:.2f}, Signal: {signal}")

        # Determine action based on Q-learning
        action = choose_action(state)

        if daily_invested[ticker] < total_daily_capital:
            if action == 'buy' and signal == 1.0:  # Buy signal
                buy_prices[ticker] = current_price
                daily_invested[ticker] += investment_per_trade
                highest_price = current_price
                print(f"Buying {ticker} at ${current_price:.2f} with ${investment_per_trade}")

            elif action == 'sell' and ticker in buy_prices:  # Sell signal
                buy_price = buy_prices[ticker]
                profit = current_price - buy_price

                # Ensure profit calculation is valid
                if profit > 0:
                    total_pnl += profit
                    print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                    del buy_prices[ticker]
                else:
                    print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

        # Update daily profit/loss
        daily_pnl += total_pnl

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    # Print out the signals for debugging
    print(data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal', 'positions']].tail(10))  # Print last 10 rows
    return data

def simulate_trades_with_q_learning(data, ticker):
    global daily_pnl, daily_invested

    total_pnl = 0
    highest_price = 0
    state = (ticker, 0)  # Example state representation

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']  # Buy/Sell signals

        # Debug: Print current price and signal
        print(f"Current Price: {current_price:.2f}, Signal: {signal}")

        # Determine action based on Q-learning
        action = choose_action(state)

        if daily_invested[ticker] < total_daily_capital:
            if action == 'buy' and signal == 1.0:  # Buy signal
                buy_prices[ticker] = current_price
                daily_invested[ticker] += investment_per_trade
                highest_price = current_price
                print(f"Buying {ticker} at ${current_price:.2f} with ${investment_per_trade}")

            elif action == 'sell' and signal == -1.0 and ticker in buy_prices:  # Sell signal
                buy_price = buy_prices[ticker]
                profit = current_price - buy_price

                if profit > 0:  # Only count profits
                    total_pnl += profit
                    print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                    del buy_prices[ticker]
                else:
                    print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

        # Update daily profit/loss
        daily_pnl += total_pnl

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"Fetching data for {ticker} for the last week...")
        new_data = yf.download(ticker, period='7d', interval='1m')  # Fetch last week's data

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}:")
        print(new_data.head())  # Print the first few rows of the data

        # Run the trading simulation with Q-learning
        simulate_trades_with_q_learning(new_data, ticker)

        # At the end of the week, calculate and sum up profits
        total_weekly_profit += daily_pnl  # Assume daily_pnl tracks the weekly performance
        print(f"Total P&L for {ticker}: ${daily_pnl:.2f}")  # Print profit for this ticker

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

def simulate_trades_with_q_learning(data, ticker):
    global daily_pnl, daily_invested

    total_pnl = 0
    highest_price = 0
    state = (ticker, 0)  # Example state representation

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']  # Buy/Sell signals

        # Debug: Print current price, signal, and current daily P&L
        print(f"Current Price: {current_price:.2f}, Signal: {signal}, Daily P&L: {daily_pnl:.2f}")

        # Determine action based on Q-learning
        action = choose_action(state)

        if daily_invested[ticker] < total_daily_capital:
            if action == 'buy' and signal == 1.0:  # Buy signal
                buy_prices[ticker] = current_price
                daily_invested[ticker] += investment_per_trade
                highest_price = current_price
                print(f"Buying {ticker} at ${current_price:.2f} with ${investment_per_trade}")

            elif action == 'sell' and ticker in buy_prices:  # Sell signal
                buy_price = buy_prices[ticker]
                profit = current_price - buy_price

                if profit > 0:  # Only count profits
                    total_pnl += profit
                    daily_pnl += profit  # Update daily P&L
                    print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                    del buy_prices[ticker]
                else:
                    print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

        # Print daily P&L after each iteration
        print(f"Updated Daily P&L for {ticker}: ${daily_pnl:.2f}")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"Fetching data for {ticker} for the last week...")
        new_data = yf.download(ticker, period='7d', interval='1m')  # Fetch last week's data

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}:")
        print(new_data.head())  # Print the first few rows of the data

        daily_pnl = 0  # Reset daily P&L for each ticker
        simulate_trades_with_q_learning(new_data, ticker)

        # At the end of the week, calculate and sum up profits
        total_weekly_profit += daily_pnl  # Assume daily_pnl tracks the weekly performance
        print(f"Total P&L for {ticker}: ${daily_pnl:.2f}")  # Print profit for this ticker

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    # Print the last few rows to see signals
    print("Signals generated:")
    print(data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal', 'positions']].tail(10))  # Print last 10 rows
    return data

def simulate_trades_simple(data, ticker):
    global daily_pnl, daily_invested
    daily_pnl = 0  # Reset daily P&L for this backtest
    total_pnl = 0

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['positions']

        # Print debug information for each row
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            daily_invested[ticker] += investment_per_trade
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                daily_pnl += profit  # Update daily P&L
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"Fetching data for {ticker} for the last week...")
        new_data = yf.download(ticker, period='7d', interval='1m')  # Fetch last week's data

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}:")
        print(new_data.head())  # Print the first few rows of the data

        # Run the simplified trading simulation
        simulate_trades_simple(new_data, ticker)

        # At the end of the week, calculate and sum up profits
        total_weekly_profit += daily_pnl  # Assume daily_pnl tracks the weekly performance
        print(f"Total P&L for {ticker}: ${daily_pnl:.2f}")  # Print profit for this ticker

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"Fetching data for {ticker} for the last week...")
        new_data = yf.download(ticker, period='7d', interval='1m')  # Fetch last week's data

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}:\n", new_data.head(10))  # Print the first 10 rows of the data

        # Apply the multi-indicator strategy to generate signals
        new_data = multi_indicator_strategy(new_data)

        # Print signals generated for debugging
        print(f"Signals generated for {ticker}:\n", new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']].tail(10))  # Last 10 rows

        # Run the simplified trading simulation
        daily_pnl = 0  # Reset daily P&L for each ticker
        simulate_trades_simple(new_data, ticker)

        # At the end of the week, calculate and sum up profits
        total_weekly_profit += daily_pnl  # Assume daily_pnl tracks the weekly performance
        print(f"Total P&L for {ticker}: ${daily_pnl:.2f}")  # Print profit for this ticker

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

def simulate_trades_simple(data, ticker):
    global daily_pnl, daily_invested
    total_pnl = 0
    daily_pnl = 0  # Reset daily P&L for this backtest

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        # Print debug information for each row
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            daily_invested[ticker] += investment_per_trade
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                daily_pnl += profit  # Update daily P&L
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"Fetching data for {ticker} for the last week...")
        new_data = yf.download(ticker, period='7d', interval='1m')  # Fetch last week's data

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

        # Apply the multi-indicator strategy to generate signals
        new_data = multi_indicator_strategy(new_data)

        # Print the entire dataset with signals
        print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")  # Print signals

        # Run the simplified trading simulation
        daily_pnl = 0  # Reset daily P&L for each ticker
        simulate_trades_simple(new_data, ticker)

        # At the end of the week, calculate and sum up profits
        total_weekly_profit += daily_pnl  # Assume daily_pnl tracks the weekly performance
        print(f"Total P&L for {ticker}: ${daily_pnl:.2f}")  # Print profit for this ticker

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

def simulate_trades_simple(data, ticker):
    global daily_pnl, daily_invested
    total_pnl = 0
    daily_pnl = 0  # Reset daily P&L for this backtest

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        # Print debug information for each row
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            daily_invested[ticker] += investment_per_trade
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                daily_pnl += profit  # Update daily P&L
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")

import yfinance as yf
import pandas as pd
import numpy as np

# Define your tickers and constants
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA', 'FB', 'NFLX', 'NVDA', 'BRK.B', 'JPM',
           'V', 'JNJ', 'PG', 'DIS', 'PYPL', 'ADBE', 'INTC', 'CMCSA', 'PEP', 'T',
           'CSCO', 'VZ', 'NKE', 'MRK', 'XOM']
investment_per_trade = 5  # Max investment per trade
daily_invested = {ticker: 0 for ticker in tickers}  # Track capital used for each stock
buy_prices = {}  # To store buy prices for each ticker
daily_pnl = 0  # Initialize daily profit and loss

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Multi-indicator strategy function
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

# Trading simulation function
def simulate_trades_simple(data, ticker):
    global daily_pnl, daily_invested
    total_pnl = 0
    daily_pnl = 0  # Reset daily P&L for this backtest

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        # Debug output
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            daily_invested[ticker] += investment_per_trade
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                daily_pnl += profit  # Update daily P&L
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return daily_pnl

# Backtest function for the last week
def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"Fetching data for {ticker} for the last week...")
        new_data = yf.download(ticker, period='7d', interval='1m')  # Fetch last week's data

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

        # Apply the multi-indicator strategy to generate signals
        new_data = multi_indicator_strategy(new_data)

        # Print the signals generated
        print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

        # Run the simplified trading simulation
        daily_pnl = 0  # Reset daily P&L for each ticker
        ticker_pnl = simulate_trades_simple(new_data, ticker)

        # At the end of the week, calculate and sum up profits
        total_weekly_profit += ticker_pnl  # Assume daily_pnl tracks the weekly performance
        print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

import yfinance as yf
import pandas as pd
import numpy as np

# Define your tickers and constants
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA', 'FB', 'NFLX', 'NVDA', 'BRK.B', 'JPM',
           'V', 'JNJ', 'PG', 'DIS', 'PYPL', 'ADBE', 'INTC', 'CMCSA', 'PEP', 'T',
           'CSCO', 'VZ', 'NKE', 'MRK', 'XOM']
investment_per_trade = 5  # Max investment per trade
daily_invested = {ticker: 0 for ticker in tickers}  # Track capital used for each stock
buy_prices = {}  # To store buy prices for each ticker
daily_pnl = 0  # Initialize daily profit and loss

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Multi-indicator strategy function
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

# Trading simulation function
def simulate_trades_simple(data, ticker):
    global daily_pnl, daily_invested
    total_pnl = 0
    daily_pnl = 0  # Reset daily P&L for this backtest

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        # Print debug information for each row
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            daily_invested[ticker] += investment_per_trade
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                daily_pnl += profit  # Update daily P&L
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Backtest function for the last week
def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"Fetching data for {ticker} for the last week...")
        new_data = yf.download(ticker, period='7d', interval='1m')  # Fetch last week's data

        if new_data.empty:  # Check if data was successfully fetched
            print(f"Failed to fetch data for {ticker}. Skipping...")
            continue

        print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

        # Apply the multi-indicator strategy to generate signals
        new_data = multi_indicator_strategy(new_data)

        # Print the signals generated
        print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

        # Run the simplified trading simulation
        ticker_pnl = simulate_trades_simple(new_data, ticker)

        # At the end of the week, calculate and sum up profits
        total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
        print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

import yfinance as yf

# Test fetching data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
new_data = yf.download(ticker, period='7d', interval='1m')

if new_data.empty:
    print(f"Failed to fetch data for {ticker}.")
else:
    print(f"Data fetched for {ticker}:\n{new_data}")

def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"Fetching data for {ticker} for the last week...")
        try:
            new_data = yf.download(ticker, period='7d', interval='1m')  # Fetch last week's data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Print the signals generated
            print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while fetching data for {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

import yfinance as yf

# Test fetching data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
new_data = yf.download(ticker, period='7d', interval='1m')

if new_data.empty:
    print(f"Failed to fetch data for {ticker}.")
else:
    print(f"Data fetched for {ticker}:\n{new_data}")

# Define the multi-indicator strategy function
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

# Apply the strategy to the fetched data
new_data = multi_indicator_strategy(new_data)

# Print the signals generated
print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

# Trading simulation function
def simulate_trades_simple(data, ticker):
    global daily_pnl, daily_invested
    total_pnl = 0
    daily_pnl = 0  # Reset daily P&L for this backtest

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        # Print debug information for each row
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            daily_invested[ticker] += investment_per_trade
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                daily_pnl += profit  # Update daily P&L
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Run the trading simulation
ticker_pnl = simulate_trades_simple(new_data, ticker)
print(f"Total Profit for {ticker}: ${ticker_pnl:.2f}")

import yfinance as yf

# Test fetching data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
new_data = yf.download(ticker, period='7d', interval='1m')

if new_data.empty:
    print(f"Failed to fetch data for {ticker}.")
else:
    print(f"Data fetched for {ticker}:\n{new_data}")

# Try fetching daily data for the last week instead
new_data = yf.download(ticker, period='7d', interval='1d')  # Fetch last week's daily data

try:
    new_data = yf.download(ticker, period='7d', interval='1m')
    if new_data.empty:
        print(f"Failed to fetch data for {ticker}.")
    else:
        print(f"Data fetched for {ticker}:\n{new_data}")
except Exception as e:
    print(f"An error occurred: {e}")

import yfinance as yf

# Test fetching daily data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
try:
    new_data = yf.download(ticker, period='7d', interval='1d')  # Fetch last week's daily data
    if new_data.empty:
        print(f"Failed to fetch data for {ticker}. No data returned.")
    else:
        print(f"Data fetched for {ticker}:\n{new_data}")
except Exception as e:
    print(f"An error occurred while fetching data for {ticker}: {e}")

!ping google.com -c 4

import yfinance as yf
import pandas as pd
import numpy as np

# Define your tickers and constants
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA', 'FB', 'NFLX', 'NVDA', 'BRK.B', 'JPM',
           'V', 'JNJ', 'PG', 'DIS', 'PYPL', 'ADBE', 'INTC', 'CMCSA', 'PEP', 'T',
           'CSCO', 'VZ', 'NKE', 'MRK', 'XOM']
investment_per_trade = 5  # Max investment per trade
daily_invested = {ticker: 0 for ticker in tickers}  # Track capital used for each stock
buy_prices = {}  # To store buy prices for each ticker
daily_pnl = 0  # Initialize daily profit and loss

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Multi-indicator strategy function
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

# Trading simulation function
def simulate_trades_simple(data, ticker):
    global daily_pnl, daily_invested
    total_pnl = 0
    daily_pnl = 0  # Reset daily P&L for this backtest
    buy_prices = {}  # Reset buy prices for this ticker

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        # Print debug information for each row
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            daily_invested[ticker] += investment_per_trade
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                daily_pnl += profit  # Update daily P&L
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Backtest function for the last week
def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last week...")
        try:
            new_data = yf.download(ticker, period='7d', interval='1d')  # Fetch last week's daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Print the signals generated
            print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

!ping google.com -c 4

import requests

try:
    response = requests.get('https://www.google.com', timeout=5)
    print("Internet is working. Status code:", response.status_code)
except requests.ConnectionError:
    print("No internet connection.")

!pip install yfinance --upgrade --no-cache-dir

import yfinance as yf

# Test fetching data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
try:
    new_data = yf.download(ticker, period='7d', interval='1d')  # Fetch last week's daily data
    if new_data.empty:
        print(f"Failed to fetch data for {ticker}. No data returned.")
    else:
        print(f"Data fetched for {ticker}:\n{new_data}")
except Exception as e:
    print(f"An error occurred while fetching data for {ticker}: {e}")

tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA']

for ticker in tickers:
    print(f"\nFetching data for {ticker}...")
    try:
        new_data = yf.download(ticker, period='7d', interval='1d')  # Fetch last week's daily data
        if new_data.empty:
            print(f"Failed to fetch data for {ticker}. No data returned.")
        else:
            print(f"Data fetched for {ticker}:\n{new_data}")
    except Exception as e:
        print(f"An error occurred while fetching data for {ticker}: {e}")

import yfinance as yf

# Test fetching data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
try:
    new_data = yf.download(ticker, period='1mo', interval='1d')  # Fetch last month's daily data
    if new_data.empty:
        print(f"Failed to fetch data for {ticker}. No data returned.")
    else:
        print(f"Data fetched for {ticker}:\n{new_data}")
except Exception as e:
    print(f"An error occurred while fetching data for {ticker}: {e}")

tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA']

for ticker in tickers:
    print(f"\nFetching data for {ticker}...")
    try:
        new_data = yf.download(ticker, period='1mo', interval='1d')  # Fetch last month's daily data
        if new_data.empty:
            print(f"Failed to fetch data for {ticker}. No data returned.")
        else:
            print(f"Data fetched for {ticker}:\n{new_data}")
    except Exception as e:
        print(f"An error occurred while fetching data for {ticker}: {e}")

import yfinance as yf
import pandas as pd
import numpy as np

# Define your tickers and constants
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA', 'FB', 'NFLX', 'NVDA', 'BRK.B', 'JPM',
           'V', 'JNJ', 'PG', 'DIS', 'PYPL', 'ADBE', 'INTC', 'CMCSA', 'PEP', 'T',
           'CSCO', 'VZ', 'NKE', 'MRK', 'XOM']
investment_per_trade = 5  # Max investment per trade
daily_invested = {ticker: 0 for ticker in tickers}  # Track capital used for each stock
buy_prices = {}  # To store buy prices for each ticker
daily_pnl = 0  # Initialize daily profit and loss

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Multi-indicator strategy function
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

# Trading simulation function
def simulate_trades_simple(data, ticker):
    global daily_pnl, daily_invested
    total_pnl = 0
    daily_pnl = 0  # Reset daily P&L for this backtest
    buy_prices = {}  # Reset buy prices for this ticker

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        # Print debug information for each row
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            daily_invested[ticker] += investment_per_trade
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                daily_pnl += profit  # Update daily P&L
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Backtest function for the last week
def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last week...")
        try:
            new_data = yf.download(ticker, period='7d', interval='1d')  # Fetch last week's daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Print the signals generated
            print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

import yfinance as yf

# Test fetching data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
try:
    # Fetch last month's daily data
    new_data = yf.download(ticker, period='30d', interval='1d')
    if new_data.empty:
        print(f"Failed to fetch data for {ticker}. No data returned.")
    else:
        print(f"Data fetched for {ticker}:\n{new_data}")
except Exception as e:
    print(f"An error occurred while fetching data for {ticker}: {e}")

import yfinance as yf

# Test fetching data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
try:
    new_data = yf.download(ticker, period='5d', interval='1d')  # Fetch last 5 days of daily data
    if new_data.empty:
        print(f"Failed to fetch data for {ticker}. No data returned.")
    else:
        print(f"Data fetched for {ticker}:\n{new_data}")
except Exception as e:
    print(f"An error occurred while fetching data for {ticker}: {e}")

tickers = ['AAPL', 'MSFT']

for ticker in tickers:
    print(f"\nFetching data for {ticker}...")
    try:
        new_data = yf.download(ticker, period='5d', interval='1d')  # Fetch last 5 days of daily data
        if new_data.empty:
            print(f"Failed to fetch data for {ticker}. No data returned.")
        else:
            print(f"Data fetched for {ticker}:\n{new_data}")
    except Exception as e:
        print(f"An error occurred while fetching data for {ticker}: {e}")

tickers = ['AAPL', 'MSFT']

for ticker in tickers:
    print(f"\nFetching data for {ticker}...")
    try:
        new_data = yf.download(ticker, period='5d', interval='1d')  # Fetch last 5 days of daily data
        if new_data.empty:
            print(f"Failed to fetch data for {ticker}. No data returned.")
        else:
            print(f"Data fetched for {ticker}:\n{new_data}")
    except Exception as e:
        print(f"An error occurred while fetching data for {ticker}: {e}")

import requests

try:
    response = requests.get('https://www.google.com', timeout=5)
    print("Internet is working. Status code:", response.status_code)
except requests.ConnectionError:
    print("No internet connection.")

import yfinance as yf
import pandas as pd
import numpy as np

# Define your tickers and constants
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA', 'FB', 'NFLX', 'NVDA', 'BRK.B', 'JPM',
           'V', 'JNJ', 'PG', 'DIS', 'PYPL', 'ADBE', 'INTC', 'CMCSA', 'PEP', 'T',
           'CSCO', 'VZ', 'NKE', 'MRK', 'XOM']
investment_per_trade = 5  # Max investment per trade
daily_invested = {ticker: 0 for ticker in tickers}  # Track capital used for each stock
buy_prices = {}  # To store buy prices for each ticker
daily_pnl = 0  # Initialize daily profit and loss

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Multi-indicator strategy function
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

# Trading simulation function
def simulate_trades_simple(data, ticker):
    global daily_pnl, daily_invested
    total_pnl = 0
    daily_pnl = 0  # Reset daily P&L for this backtest
    buy_prices = {}  # Reset buy prices for this ticker

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        # Print debug information for each row
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            daily_invested[ticker] += investment_per_trade
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                daily_pnl += profit  # Update daily P&L
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Backtest function for the last week
def backtest_last_week():
    global daily_pnl, daily_invested
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last week...")
        try:
            new_data = yf.download(ticker, period='7d', interval='1d')  # Fetch last week's daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Print the signals generated
            print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

import yfinance as yf

# Fetch data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
try:
    # Fetch last week's daily data
    new_data = yf.download(ticker, period='7d', interval='1d')
    if new_data.empty:
        print(f"Failed to fetch data for {ticker}. No data returned.")
    else:
        print(f"Data fetched for {ticker}:\n{new_data}\n")
except Exception as e:
    print(f"An error occurred while fetching data for {ticker}: {e}")

!pip install yfinance --upgrade --no-cache-dir

import yfinance as yf

# Try fetching data for a specific ticker
ticker = 'AAPL'  # Example ticker symbol
try:
    # Fetch last 5 days of daily data
    new_data = yf.download(ticker, period='5d', interval='1d')
    print(f"Data fetched for {ticker}:\n{new_data}")
except Exception as e:
    print(f"An error occurred while fetching data for {ticker}: {e}")

import yfinance as yf

# Test fetching data for a different ticker
ticker = 'MSFT'  # Example ticker symbol
try:
    # Fetch last month of daily data
    new_data = yf.download(ticker, period='1mo', interval='1d')
    print(f"Data fetched for {ticker}:\n{new_data}")
except Exception as e:
    print(f"An error occurred while fetching data for {ticker}: {e}")

import yfinance as yf
import pandas as pd
import numpy as np

# Define your tickers and constants
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA']  # Add any tickers you want to test
investment_per_trade = 5  # Max investment per trade
daily_invested = {ticker: 0 for ticker in tickers}  # Track capital used for each stock
buy_prices = {}  # To store buy prices for each ticker

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Multi-indicator strategy function
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

# Trading simulation function
def simulate_trades_simple(data, ticker):
    total_pnl = 0
    buy_prices = {}  # Reset buy prices for this ticker

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Backtest function for the last week
def backtest_last_week():
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last week...")
        try:
            new_data = yf.download(ticker, period='7d', interval='1d')  # Fetch last week's daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Print the signals generated
            print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

import yfinance as yf
import pandas as pd
import numpy as np

# Define your tickers and constants
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA']  # Add any tickers you want to test
investment_per_trade = 5  # Max investment per trade
daily_invested = {ticker: 0 for ticker in tickers}  # Track capital used for each stock
buy_prices = {}  # To store buy prices for each ticker

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Multi-indicator strategy function
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

# Trading simulation function
def simulate_trades_simple(data, ticker):
    total_pnl = 0
    buy_prices = {}  # Reset buy prices for this ticker

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Backtest function for the last week
def backtest_last_week():
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last week...")
        try:
            new_data = yf.download(ticker, period='5d', interval='1d')  # Use '5d' for fetching daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Print the signals generated
            print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

# Function to simulate trades
def simulate_trades_simple(data, ticker):
    total_pnl = 0
    buy_prices = {}  # Reset buy prices for this ticker

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Backtest function for the last week
def backtest_last_week():
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last week...")
        try:
            new_data = yf.download(ticker, period='5d', interval='1d')  # Use '5d' for fetching daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Print the signals generated
            print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

            # Check if there are any signals generated
            if new_data['signal'].any():
                print(f"Trading signals exist for {ticker}. Proceeding with trade simulation.")
            else:
                print(f"No trading signals generated for {ticker}.")

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last week
backtest_last_week()

def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    # Print the calculated RSI and SMA values
    print("RSI values:\n", data['RSI'])
    print("Short-term SMA values:\n", data['SMA_short'])
    print("Long-term SMA values:\n", data['SMA_long'])

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    return data

def backtest_last_week():
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last month...")
        try:
            new_data = yf.download(ticker, period='1mo', interval='1d')  # Use '1mo' for fetching daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Print the signals generated
            print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

            # Check if there are any signals generated
            if new_data['signal'].any():
                print(f"Trading signals exist for {ticker}. Proceeding with trade simulation.")
            else:
                print(f"No trading signals generated for {ticker}.")

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    # Print the calculated RSI and SMA values
    print("RSI values:\n", data['RSI'])
    print("Short-term SMA values:\n", data['SMA_short'])
    print("Long-term SMA values:\n", data['SMA_long'])

    data['signal'] = 0.0
    data['signal'] = np.where((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions

    # Print the signals generated
    print(f"Signals generated:\n{data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}\n")

    return data

# Backtest function for the last week
def backtest_last_week():
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last month...")
        try:
            new_data = yf.download(ticker, period='1mo', interval='1d')  # Use '1mo' for fetching daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

import yfinance as yf
import pandas as pd
import numpy as np

# Define a single ticker to simplify
ticker = 'AAPL'  # Example ticker symbol

# Fetch data for the last month
print(f"Fetching data for {ticker}...")
try:
    new_data = yf.download(ticker, period='1mo', interval='1d')  # Fetch last month's daily data
    if new_data.empty:
        print(f"Failed to fetch data for {ticker}. No data returned.")
    else:
        print(f"Data fetched for {ticker}:\n{new_data}\n")  # Print the entire dataset

        # Calculate RSI
        delta = new_data['Close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        new_data['RSI'] = rsi

        # Print the calculated RSI
        print("Calculated RSI values:\n", new_data['RSI'])

        # Calculate SMA
        new_data['SMA_short'] = new_data['Close'].rolling(window=5).mean()  # Short-term SMA
        new_data['SMA_long'] = new_data['Close'].rolling(window=20).mean()  # Long-term SMA

        # Print the calculated SMA values
        print("Short-term SMA values:\n", new_data['SMA_short'])
        print("Long-term SMA values:\n", new_data['SMA_long'])

        # Generate signals
        new_data['signal'] = 0.0
        new_data['signal'] = np.where((new_data['RSI'] < 30) & (new_data['SMA_short'] > new_data['SMA_long']), 1.0, new_data['signal'])  # Buy signal
        new_data['signal'] = np.where((new_data['RSI'] > 70) & (new_data['SMA_short'] < new_data['SMA_long']), -1.0, new_data['signal'])  # Sell signal

        # Print the signals generated
        print(f"Signals generated:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}\n")

except Exception as e:
    print(f"An error occurred while fetching data for {ticker}: {e}")

def simulate_trades_simple(data, ticker):
    total_pnl = 0
    buy_prices = {}  # Reset buy prices for this ticker

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Now let's integrate this simulation into the backtest function
def backtest_last_week():
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last month...")
        try:
            new_data = yf.download(ticker, period='1mo', interval='1d')  # Use '1mo' for fetching daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last month
backtest_last_week()

# Generate buy/sell signals using modified RSI thresholds
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA
    data['signal'] = 0.0
    # Modify thresholds for RSI signals
    data['signal'] = np.where((data['RSI'] < 35) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 65) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions
    return data

import yfinance as yf
import pandas as pd
import numpy as np

# Define your tickers and constants
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA']  # Add any tickers you want to test
investment_per_trade = 5  # Max investment per trade
daily_invested = {ticker: 0 for ticker in tickers}  # Track capital used for each stock
buy_prices = {}  # To store buy prices for each ticker

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Multi-indicator strategy function with modified RSI thresholds
def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA
    data['signal'] = 0.0
    # Modify thresholds for RSI signals
    data['signal'] = np.where((data['RSI'] < 35) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 65) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal
    data['positions'] = data['signal'].diff()  # Generate buy/sell positions
    return data

# Trading simulation function
def simulate_trades_simple(data, ticker):
    total_pnl = 0
    buy_prices = {}  # Reset buy prices for this ticker

    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals

        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            if profit > 0:
                total_pnl += profit
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
                del buy_prices[ticker]
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl

# Backtest function for the last month
def backtest_last_week():
    total_weekly_profit = 0  # Track total profit for the week

    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last month...")
        try:
            new_data = yf.download(ticker, period='1mo', interval='1d')  # Use '1mo' for fetching daily data
            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Assume ticker_pnl tracks the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")
    print("Backtesting completed.")

# Run the backtest for the last month
backtest_last_week()

# Fetch data for each ticker and print the DataFrame
print(f"Fetching data for {ticker}...")
new_data = yf.download(ticker, period='1mo', interval='1d')
print(new_data)  # Add this line to print the DataFrame after fetching

def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    data['RSI'] = rsi
    print(data[['Close', 'RSI']])  # Print the Close and RSI columns
    return data

def multi_indicator_strategy(data):
    data = calculate_rsi(data)  # Calculate RSI
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=20).mean()  # Long-term SMA

    print(data[['Close', 'RSI', 'SMA_short', 'SMA_long']])  # Print relevant values before checking signals

    # Check if 'RSI' is present before generating signals
    if 'RSI' not in data.columns:
        print("RSI column not found. Check RSI calculation.")
        return data

    data['signal'] = 0.0
    # Modify thresholds for RSI signals
    data['signal'] = np.where((data['RSI'] < 40) & (data['SMA_short'] > data['SMA_long']), 1.0, data['signal'])  # Buy signal
    data['signal'] = np.where((data['RSI'] > 60) & (data['SMA_short'] < data['SMA_long']), -1.0, data['signal'])  # Sell signal

    print(f"Signals generated:\n{data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

    data['positions'] = data['signal'].diff()  # Generate buy/sell positions
    return data

# Run the backtest for the last month
backtest_last_week()

def simulate_trades_simple(data, ticker):
    total_pnl = 0
    buy_prices = {}  # Reset buy prices for this ticker
    for index, row in data.iterrows():
        current_price = row['Close']
        signal = row['signal']  # Buy/Sell signals
        print(f"Ticker: {ticker}, Current Price: {current_price:.2f}, Signal: {signal}")

        if signal == 1.0:  # Buy signal
            buy_prices[ticker] = current_price
            print(f"Buying {ticker} at ${current_price:.2f}")

        elif signal == -1.0 and ticker in buy_prices:  # Sell signal
            buy_price = buy_prices[ticker]
            profit = current_price - buy_price

            total_pnl += profit  # Update total profit/loss
            if profit > 0:
                print(f"Selling {ticker} at ${current_price:.2f}. Profit: ${profit:.2f}")
            else:
                print(f"Selling {ticker} at ${current_price:.2f}. No profit.")
            del buy_prices[ticker]  # Remove the ticker from buy prices

    print(f"Total P&L for {ticker}: ${total_pnl:.2f}")
    return total_pnl  # Return the profit/loss for this ticker

def backtest_last_week():
    total_weekly_profit = 0  # Track total profit for the week
    for ticker in tickers:
        print(f"\nFetching data for {ticker} for the last month...")
        try:
            new_data = yf.download(ticker, period='1mo', interval='1d')  # Fetch last month's daily data

            if new_data.empty:  # Check if data was successfully fetched
                print(f"Failed to fetch data for {ticker}. Skipping...")
                continue

            print(f"Data fetched for {ticker}:\n{new_data}")  # Print the entire dataset

            # Apply the multi-indicator strategy to generate signals
            new_data = multi_indicator_strategy(new_data)

            # Print the signals generated
            print(f"Signals generated for {ticker}:\n{new_data[['Close', 'RSI', 'SMA_short', 'SMA_long', 'signal']]}")

            # Run the simplified trading simulation
            ticker_pnl = simulate_trades_simple(new_data, ticker)

            # At the end of the week, calculate and sum up profits
            total_weekly_profit += ticker_pnl  # Sum up the weekly performance
            print(f"Total P&L for {ticker}: ${ticker_pnl:.2f}")  # Print profit for this ticker

        except Exception as e:
            print(f"An error occurred while processing {ticker}: {e}")

    print(f"Total Profit for the last week: ${total_weekly_profit:.2f}")  # Print total weekly profit
    print("Backtesting completed.")

backtest_last_week()

def multi_indicator_strategy(data):
    # Ensure SMA calculations are valid
    data['SMA_short'] = data['Close'].rolling(window=short_window).mean()
    data['SMA_long'] = data['Close'].rolling(window=long_window).mean()

    # Initialize signal column
    data['signal'] = 0.0

    # Buy signal: Short SMA crosses above Long SMA and RSI is low
    data['signal'][(data['SMA_short'] > data['SMA_long']) & (data['RSI'] < 30)] = 1.0

    # Sell signal: Short SMA crosses below Long SMA and RSI is high
    data['signal'][(data['SMA_short'] < data['SMA_long']) & (data['RSI'] > 70)] = -1.0

    return data

def multi_indicator_strategy(data):
    # ... [existing code] ...

    print("RSI Values:\n", data['RSI'])
    print("SMA Short Values:\n", data['SMA_short'])
    print("SMA Long Values:\n", data['SMA_long'])

    # ... [existing signal generation code] ...

def multi_indicator_strategy(data):
    # Calculate the short and long SMAs
    data['SMA_short'] = data['Close'].rolling(window=short_window).mean()
    data['SMA_long'] = data['Close'].rolling(window=long_window).mean()

    # Initialize the signal column
    data['signal'] = 0.0

    # Debugging outputs
    print("RSI Values:\n", data['RSI'])
    print("SMA Short Values:\n", data['SMA_short'])
    print("SMA Long Values:\n", data['SMA_long'])

    # Buy signal: Short SMA crosses above Long SMA and RSI is low
    data['signal'][(data['SMA_short'] > data['SMA_long']) & (data['RSI'] < 30)] = 1.0

    # Sell signal: Short SMA crosses below Long SMA and RSI is high
    data['signal'][(data['SMA_short'] < data['SMA_long']) & (data['RSI'] > 70)] = -1.0

    return data

for ticker, data in stock_data.items():
    print(f"Latest RSI for {ticker}: {data['RSI'].iloc[-1]}")
    print(f"Latest SMA Short for {ticker}: {data['SMA_short'].iloc[-1]}")
    print(f"Latest SMA Long for {ticker}: {data['SMA_long'].iloc[-1]}")

# Ensure SMA calculations are defined as follows
data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
data['SMA_long'] = data['Close'].rolling(window=10).mean()   # Long-term SMA

for ticker, data in stock_data.items():
    print(f"Columns for {ticker}: {data.columns.tolist()}")

for ticker, data in stock_data.items():
    print(data[['Close', 'SMA_short', 'SMA_long', 'RSI']].tail(10))  # Show the last 10 entries

# Assuming you already fetched the stock data
for ticker, data in stock_data.items():
    # Calculate SMA
    data['SMA_short'] = data['Close'].rolling(window=5).mean()  # Short-term SMA
    data['SMA_long'] = data['Close'].rolling(window=10).mean()   # Long-term SMA

    # Print the last few entries to verify
    print(f"Latest values for {ticker}:")
    print(data[['Close', 'SMA_short', 'SMA_long', 'RSI']].tail(10))

# Print the latest RSI and SMA values for TSLA
latest_rsi = df['RSI'].iloc[-1]
latest_sma_short = df['SMA_short'].iloc[-1]
latest_sma_long = df['SMA_long'].iloc[-1]

print(f"Latest RSI for TSLA: {latest_rsi}")
print(f"Latest SMA Short for TSLA: {latest_sma_short}")
print(f"Latest SMA Long for TSLA: {latest_sma_long}")

import pandas as pd
import yfinance as yf

# Define the ticker and time period
ticker = 'TSLA'
start_date = '2024-09-01'
end_date = '2024-10-11'

# Fetch the historical data
df = yf.download(ticker, start=start_date, end=end_date)

# Calculate RSI and moving averages (SMA)
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

# Add RSI to DataFrame
df['RSI'] = calculate_rsi(df)

# Calculate short and long SMAs
df['SMA_short'] = df['Close'].rolling(window=5).mean()  # Short SMA
df['SMA_long'] = df['Close'].rolling(window=20).mean()  # Long SMA

# Print the latest RSI and SMA values for TSLA
latest_rsi = df['RSI'].iloc[-1]
latest_sma_short = df['SMA_short'].iloc[-1]
latest_sma_long = df['SMA_long'].iloc[-1]

print(f"Latest RSI for TSLA: {latest_rsi}")
print(f"Latest SMA Short for TSLA: {latest_sma_short}")
print(f"Latest SMA Long for TSLA: {latest_sma_long}")

# Initialize variables for profit and loss
total_profit = 0.0
total_investment = 0.0
position = None  # None means not holding a position

# Iterate over the DataFrame rows to simulate trading
for index, row in df.iterrows():
    current_price = row['Close']
    current_rsi = row['RSI']
    current_sma_short = row['SMA_short']
    current_sma_long = row['SMA_long']

    # Buy logic
    if current_rsi < 30 and current_price > current_sma_short and position is None:
        position = current_price  # Buy at the current price
        total_investment += position  # Add to the total investment
        print(f"Buying at {current_price} on {index}")

    # Sell logic
    elif current_rsi > 70 and current_price < current_sma_long and position is not None:
        profit = current_price - position  # Calculate profit
        total_profit += profit  # Update total profit
        print(f"Selling at {current_price} on {index}, Profit: {profit}")
        position = None  # Exit position

# Final P&L output
print(f"Total Profit: {total_profit}")
print(f"Total Investment: {total_investment}")

import numpy as np

# Define the state using RSI and Moving Averages (SMA)
def get_state(df):
    rsi = df['RSI'].iloc[-1]
    sma_short = df['SMA_short'].iloc[-1]
    sma_long = df['SMA_long'].iloc[-1]

    # Simplify states: RSI has 3 states, SMA has 2 states
    rsi_state = 0 if rsi < 30 else 1 if rsi > 70 else 2  # 0 = low, 1 = high, 2 = neutral
    ma_state = 0 if sma_short < sma_long else 1          # 0 = SMA_short below SMA_long, 1 = above

    return (rsi_state, ma_state)

# Actions: 0 = hold, 1 = buy, 2 = sell
actions = [0, 1, 2]

# Initialize Q-table: size (number of RSI states) x (number of SMA states) x (number of actions)
q_table = np.zeros((3, 2, len(actions)))  # 3 RSI states, 2 SMA states, 3 possible actions

# Parameters for learning
alpha = 0.1  # Learning rate (how fast the AI learns)
gamma = 0.95  # Discount factor (how much future rewards matter)
epsilon = 0.1  # Exploration rate (how often the AI tries new things)

# Reward system based on profit and loss
def get_reward(action, current_price, previous_price):
    if action == 1:  # Buy
        return 0  # No reward for buying (yet)
    elif action == 2:  # Sell
        return current_price - previous_price  # Profit or loss
    else:  # Hold
        return 0  # No reward for holding

Q(state, action) = Q(state, action) + alpha * (reward + gamma * max(Q(next_state)) - Q(state, action))

# Q-Learning update function
def update_q_table(state, action, reward, next_state):
    max_next_q = np.max(q_table[next_state])  # Get the maximum Q-value for the next state
    current_q_value = q_table[state][action]  # Get the current Q-value for the chosen action in the current state

    # Q-learning formula: Q(s, a) = Q(s, a) + alpha * (reward + gamma * max(Q(s', a')) - Q(s, a))
    q_table[state][action] = current_q_value + alpha * (reward + gamma * max_next_q - current_q_value)

import random

def update_q_table(state, action, reward, next_state):
    # Update the Q-table based on the Q-learning formula
    max_next_q = np.max(q_table[next_state])
    q_table[state][action] = q_table[state][action] + alpha * (reward + gamma * max_next_q - q_table[state][action])

def choose_action(state):
    # Use epsilon-greedy to choose action
    if random.uniform(0, 1) < epsilon:
        return random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit the best-known action

for t in range(len(df) - 1):
    state = get_state(df.iloc[t])
    action = choose_action(state)
    current_price = df['Close'].iloc[t]
    next_price = df['Close'].iloc[t + 1]

    # Reward based on the action
    reward = get_reward(action, next_price, current_price)

    # Get the next state
    next_state = get_state(df.iloc[t + 1])

    # Update Q-table
    update_q_table(state, action, reward, next_state)

    # Print progress every 100 steps
    if t % 100 == 0:
        print(f"Step {t}, Action: {action}, Reward: {reward}")

# Define the state using RSI and Moving Averages (SMA)
def get_state(row):
    rsi = row['RSI']
    sma_short = row['SMA_short']
    sma_long = row['SMA_long']

    # Return the state as a tuple or list
    return (rsi, sma_short, sma_long)

for t in range(len(df) - 1):
    # Pass a single row (df.iloc[t]) to the get_state function
    state = get_state(df.iloc[t])
    action = choose_action(state)
    current_price = df['Close'].iloc[t]
    next_price = df['Close'].iloc[t + 1]

    # The rest of the trading logic remains the same

def discretize(value, bins):
    """Helper function to discretize continuous values into buckets."""
    return np.digitize(value, bins) - 1  # -1 because np.digitize starts at 1

# Define the state using RSI and Moving Averages (SMA)
def get_state(row):
    # Define some arbitrary bins for discretizing RSI and SMAs
    rsi_bins = [30, 70]  # RSI is divided into [0-30], [30-70], and [70-100]
    sma_bins = np.linspace(row['SMA_long'], row['SMA_short'], num=10)  # 10 bins for SMA

    rsi_discrete = discretize(row['RSI'], rsi_bins)
    sma_short_discrete = discretize(row['SMA_short'], sma_bins)
    sma_long_discrete = discretize(row['SMA_long'], sma_bins)

    # Return the state as a tuple of discrete values
    return (rsi_discrete, sma_short_discrete, sma_long_discrete)

# Initialize Q-table as a dictionary instead of a NumPy array
q_table = {}

# Modify choose_action to handle dictionary-based Q-table
def choose_action(state):
    # Initialize the state in the Q-table if it doesn't exist
    if state not in q_table:
        q_table[state] = np.zeros(len(actions))  # Initialize action values for this state

    if np.random.uniform(0, 1) < epsilon:
        return random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit the best-known action

for t in range(len(df) - 1):
    # Pass a single row (df.iloc[t]) to the get_state function
    state = get_state(df.iloc[t])
    action = choose_action(state)
    current_price = df['Close'].iloc[t]
    next_price = df['Close'].iloc[t + 1]

    # Implement the rest of the Q-learning update logic here

# Track the bot's actions and Q-values during training
for t in range(len(df) - 1):
    state = get_state(df.iloc[t])
    action = choose_action(state)
    current_price = df['Close'].iloc[t]
    next_price = df['Close'].iloc[t + 1]

    # Execute the trade and calculate the reward
    reward = next_price - current_price if action == 1 else current_price - next_price  # Simple reward logic

    # Update Q-table
    next_state = get_state(df.iloc[t + 1])
    update_q_table(state, action, reward, next_state)

    # Optional: Print progress every 100 steps
    if t % 100 == 0:
        print(f"Step: {t}, State: {state}, Action: {action}, Q-values: {q_table[state]}")

# Initialize balance or profit
balance = 1000  # Starting with a balance of $1000
position = 0    # Number of shares owned

for t in range(len(df) - 1):
    state = get_state(df.iloc[t])
    action = choose_action(state)
    current_price = df['Close'].iloc[t]
    next_price = df['Close'].iloc[t + 1]

    # Execute the trade and update balance
    if action == 1:  # Buy
        position += 1
        balance -= current_price
    elif action == 2 and position > 0:  # Sell (only if we own shares)
        position -= 1
        balance += current_price

    # Calculate the reward and update Q-table
    reward = next_price - current_price if action == 1 else current_price - next_price  # Simplified reward
    next_state = get_state(df.iloc[t + 1])
    update_q_table(state, action, reward, next_state)

    # Print balance and position after each step
    print(f"Step: {t}, Action: {action}, Balance: {balance}, Position: {position}")

# Run the training loop for all rows in the DataFrame
for t in range(len(df) - 1):
    state = get_state(df.iloc[t])  # Get current state based on RSI and SMAs
    action = choose_action(state)  # Choose an action (buy/sell/hold)

    current_price = df['Close'].iloc[t]  # Current stock price
    next_price = df['Close'].iloc[t + 1]  # Next stock price

    # Calculate reward
    if action == 1:  # Buy
        reward = next_price - current_price  # Profit is next price - current price
    elif action == 2:  # Sell
        reward = current_price - next_price  # Profit is current price - next price
    else:  # Hold
        reward = 0

    # Update Q-table
    next_state = get_state(df.iloc[t + 1])  # Get next state
    update_q_table(state, action, reward, next_state)  # Update Q-values

if t % 10 == 0:  # Every 10 steps, print Q-values and balance
    print(f"Iteration {t}, Q-values for current state: {q_table[state]}")

import pickle

# Save the Q-table to a file for later use
with open('q_table.pkl', 'wb') as file:
    pickle.dump(q_table, file)
print("Q-table saved successfully!")

# Load saved Q-table
with open('q_table.pkl', 'rb') as file:
    q_table = pickle.load(file)

# Run the backtest loop with new data
for t in range(len(new_df) - 1):
    state = get_state(new_df.iloc[t])
    action = choose_action(state)
    # Similar loop as training, but now just track actions and balance.

import yfinance as yf

# Replace 'AAPL' with the ticker you want and adjust the date range
new_data = yf.download('AAPL', start='2023-01-01', end='2023-12-31')

# Calculate RSI and Moving Averages (just like in training)
new_data['RSI'] = calculate_rsi(new_data['Close'])
new_data['SMA_short'] = new_data['Close'].rolling(window=14).mean()
new_data['SMA_long'] = new_data['Close'].rolling(window=50).mean()

new_df = new_data.dropna()  # Remove any rows with missing data

print(new_data.head())

print(new_data.columns)

new_data.columns = new_data.columns.str.strip()  # Remove any leading/trailing spaces

new_data.index = pd.to_datetime(new_data.index, errors='coerce')

import yfinance as yf

# Replace with the correct stock ticker and date range
new_data = yf.download('AAPL', start='2023-01-01', end='2023-12-31')

# Ensure data is correctly processed
print(new_data.head())

print(new_data.head())
print(new_data.columns)

# Assuming you've already defined calculate_RSI, calculate_SMA
new_data['RSI'] = calculate_RSI(new_data['Close'])
new_data['SMA_short'] = calculate_SMA(new_data['Close'], window=14)
new_data['SMA_long'] = calculate_SMA(new_data['Close'], window=50)

print(new_data.tail())  # Verify that these columns are now added

def calculate_RSI(series, period=14):
    delta = series.diff(1)
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=period).mean()
    avg_loss = loss.rolling(window=period).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

def calculate_SMA(series, window):
    return series.rolling(window=window).mean()

new_data['RSI'] = calculate_RSI(new_data['Close'])
new_data['SMA_short'] = calculate_SMA(new_data['Close'], window=14)
new_data['SMA_long'] = calculate_SMA(new_data['Close'], window=50)

print(new_data.tail())  # To verify the calculations

print(new_data[['Close', 'RSI', 'SMA_short', 'SMA_long']].tail())

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])  # Use the current row of data
    action = choose_action(state)        # Choose action based on Q-learning or other logic

    # Define trading conditions
    rsi = new_data['RSI'].iloc[t]
    sma_short = new_data['SMA_short'].iloc[t]
    sma_long = new_data['SMA_long'].iloc[t]

    if rsi < 30 and sma_short > sma_long:
        # Buy signal
        print(f"Buy at {new_data['Close'].iloc[t]}")
    elif rsi > 70 and sma_short < sma_long:
        # Sell signal
        print(f"Sell at {new_data['Close'].iloc[t]}")
    else:
        # Hold signal
        print("Hold")

initial_balance = 1000  # Starting with $1000
position = 0  # No initial stock
balance = initial_balance

for t in range(len(new_data) - 1):
    action = choose_action(get_state(new_data.iloc[t]))

    current_price = new_data['Close'].iloc[t]

    if action == "buy" and balance >= current_price:
        position += 1
        balance -= current_price
        print(f"Bought at {current_price}, New balance: {balance}")

    elif action == "sell" and position > 0:
        position -= 1
        balance += current_price
        print(f"Sold at {current_price}, New balance: {balance}")

# Final balance
print(f"Final Balance: {balance + position * new_data['Close'].iloc[-1]}")

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)

    next_state = get_state(new_data.iloc[t + 1])
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Update Q-table based on reward
    Q[state, action] = Q[state, action] + alpha * (reward + gamma * np.max(Q[next_state]) - Q[state, action])

def calculate_reward(current_row, next_row, action):
    current_price = current_row['Close']
    next_price = next_row['Close']

    if action == "buy":
        # Reward based on the price increase after buying
        return next_price - current_price

    elif action == "sell":
        # Reward based on the price decrease after selling
        return current_price - next_price

    else:
        # No action or hold, reward is 0
        return 0

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)

    next_state = get_state(new_data.iloc[t + 1])
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Update Q-table based on the reward
    Q[state, action] = Q[state, action] + alpha * (reward + gamma * np.max(Q[next_state]) - Q[state, action])

# Actions for the trading bot (buy, sell, hold)
actions = ["buy", "sell", "hold"]

# Initialize an empty Q-table as a dictionary
Q = {}

# Initialize the Q-table with zeros for each state-action pair
for state in range(len(new_data)):  # Assuming states are derived from rows of data
    Q[state] = {action: 0 for action in actions}

# Initialize parameters
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)

    next_state = get_state(new_data.iloc[t + 1])
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Update Q-table based on the reward
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

# Initialize parameters
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor

# Ensure states and actions exist in the Q-table
for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    next_state = get_state(new_data.iloc[t + 1])
    action = choose_action(state)

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # If the current state is not in the Q-table, initialize it
    if state not in Q:
        Q[state] = {a: 0 for a in actions}  # Initialize all actions for this state

    # If the next state is not in the Q-table, initialize it
    if next_state not in Q:
        Q[next_state] = {a: 0 for a in actions}

    # Update Q-table based on the reward
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

# Initialize parameters
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor

# Ensure states and actions exist in the Q-table
for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    next_state = get_state(new_data.iloc[t + 1])
    action = choose_action(state)

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # If the current state is not in the Q-table, initialize it
    if state not in Q:
        Q[state] = {a: 0 for a in actions}  # Initialize all actions for this state

    # If the next state is not in the Q-table, initialize it
    if next_state not in Q:
        Q[next_state] = {a: 0 for a in actions}

    # Ensure that the chosen action for the current state exists in the Q-table
    if action not in Q[state]:
        Q[state][action] = 0  # Initialize the action

    # Ensure that the max action for the next state exists in the Q-table
    if action not in Q[next_state]:
        Q[next_state][action] = 0  # Initialize the action for next state

    # Update Q-table based on the reward
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

Q = {}  # Q-table for storing state-action values

def initialize_Q(state):
    if state not in Q:
        Q[state] = {action: 0 for action in actions}

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)

    # Ensure the Q-table is initialized for this state
    initialize_Q(state)

    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]
    next_state = get_state(new_data.iloc[t + 1])

    # Ensure the Q-table is initialized for the next state as well
    initialize_Q(next_state)

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Update Q-table based on the reward
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

Q = {}  # Initialize the Q-table

# Function to initialize Q-table for a given state if not already done
def initialize_Q(state):
    if state not in Q:
        Q[state] = {action: 0 for action in actions}

# Q-learning loop
for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)

    # Ensure Q-table is initialized for this state
    initialize_Q(state)

    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]
    next_state = get_state(new_data.iloc[t + 1])

    # Ensure Q-table is initialized for the next state
    initialize_Q(next_state)

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Update Q-table using the Q-learning update rule
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

Q = {}  # Initialize the Q-table
actions = [-1, 0, 1]  # Example action space: sell, hold, buy

# Function to initialize Q-table for a given state if not already done
def initialize_Q(state):
    if state not in Q:
        Q[state] = {action: 0.0 for action in actions}

# Q-learning loop
for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)

    # Ensure Q-table is initialized for the current state
    initialize_Q(state)

    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]
    next_state = get_state(new_data.iloc[t + 1])

    # Ensure Q-table is initialized for the next state
    initialize_Q(next_state)

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Update Q-table using the Q-learning update rule
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

# Print Q-table to verify its structure
print("Q-table:", Q)

Q = {}  # Initialize the Q-table
actions = [-1, 0, 1]  # Example action space: sell, hold, buy

# Function to initialize Q-values for a given state
def initialize_Q(state):
    if state not in Q:
        Q[state] = {action: 0.0 for action in actions}

# Q-learning loop
for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)

    # Ensure Q-table is initialized for the current state
    initialize_Q(state)

    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]
    next_state = get_state(new_data.iloc[t + 1])

    # Ensure Q-table is initialized for the next state
    initialize_Q(next_state)

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Ensure every action in the current state and next state is initialized
    for action in actions:
        if action not in Q[state]:
            Q[state][action] = 0.0
        if action not in Q[next_state]:
            Q[next_state][action] = 0.0

    # Update Q-table using the Q-learning update rule
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

# Print Q-table to verify its structure
print("Q-table:", Q)

total_profit = 0
for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)
    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)
    total_profit += reward  # Track the total profit

    next_state = get_state(new_data.iloc[t + 1])
    initialize_Q(next_state)

    # Update Q-table
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

print("Total Profit:", total_profit)

def initialize_Q(state):
    """ Ensure the Q-table has an entry for the given state with default values for actions. """
    if state not in Q:
        # Initialize Q-values for both actions (Buy=0, Sell=1)
        Q[state] = {0: 0.0, 1: 0.0}  # Assuming 0 = Buy, 1 = Sell

# Main loop
total_profit = 0

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])

    # Initialize Q for this state if it's not already in the table
    initialize_Q(state)

    action = choose_action(state)
    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)
    total_profit += reward  # Track total profit

    next_state = get_state(new_data.iloc[t + 1])

    # Initialize Q for next state if not already in the table
    initialize_Q(next_state)

    # Update Q-table
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

print("Total Profit:", total_profit)

from collections import defaultdict

# Initialize Q-table using defaultdict
Q = defaultdict(lambda: {0: 0.0, 1: 0.0})  # 0 = Buy, 1 = Sell

# Main loop for backtesting and updating the Q-table
total_profit = 0

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])

    # No need to manually initialize Q since defaultdict takes care of it
    action = choose_action(state)
    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)
    total_profit += reward  # Track total profit

    next_state = get_state(new_data.iloc[t + 1])

    # Update Q-table
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

print("Total Profit:", total_profit)

# Debugging: Print state for each iteration
for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    print(f"State at iteration {t}: {state}")  # Print the state to check its values

    action = choose_action(state)
    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]

    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)
    total_profit += reward  # Track total profit

    next_state = get_state(new_data.iloc[t + 1])

    # Update Q-table
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

print("Total Profit:", total_profit)

def get_state(row):
    rsi = row['RSI']
    sma_short = row['SMA_short']
    sma_long = row['SMA_long']

    # Ensure that RSI and SMAs are valid and within proper bounds
    if pd.isna(rsi) or pd.isna(sma_short) or pd.isna(sma_long):
        return (0, 0, 0)  # Return a default neutral state if values are invalid

    # Ensure RSI is within the range 0-100
    rsi_state = 1 if rsi > 70 else (-1 if rsi < 30 else 0)

    # Ensure SMA values comparison is valid
    sma_state = 1 if sma_short > sma_long else (-1 if sma_short < sma_long else 0)

    return (rsi_state, sma_state, 1)  # The last value can be an arbitrary component of the state

def calculate_reward(current_price, next_price, action):
    if action == 1:  # Buy action
        return next_price - current_price  # Reward based on price increase
    elif action == 0:  # Hold action
        return 0  # No reward for holding
    else:  # Sell action
        return current_price - next_price  # Reward for selling at a higher price

Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

if state == (-1, -1, -1) or next_state == (-1, -1, -1):
    print(f"Invalid state at iteration {t}: state={state}, next_state={next_state}")
    continue  # Skip this iteration to prevent Q-table updates for invalid states

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    next_state = get_state(new_data.iloc[t + 1])

    # Ensure no invalid states are processed
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Invalid state at iteration {t}: state={state}, next_state={next_state}")
        continue  # Skip this iteration if the state is invalid

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Update Q-table
    if state not in Q:
        Q[state] = {action: 0 for action in actions}  # Initialize state if missing
    if next_state not in Q:
        Q[next_state] = {action: 0 for action in actions}  # Initialize next_state if missing

    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    next_state = get_state(new_data.iloc[t + 1])

    # Ensure no invalid states are processed
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Invalid state at iteration {t}: state={state}, next_state={next_state}")
        continue  # Skip this iteration if the state is invalid

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if missing
    if state not in Q:
        Q[state] = {action: 0 for action in actions}  # Initialize state if missing
    if next_state not in Q:
        Q[next_state] = {action: 0 for action in actions}  # Initialize next_state if missing

    # Update Q-table using scalar values
    max_next_state_value = max(Q[next_state].values()) if Q[next_state] else 0
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_state_value - Q[state][action])

print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Get state and next state as scalars (tuples of integer or float values)
    state = tuple(get_state(new_data.iloc[t]))  # Ensure state is hashable (e.g., a tuple)
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Ensure next_state is hashable (e.g., a tuple)

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if missing
    if state not in Q:
        Q[state] = {action: 0 for action in actions}  # Initialize state
    if next_state not in Q:
        Q[next_state] = {action: 0 for action in actions}  # Initialize next_state

    # Get the maximum value of the next state actions (ensure it is scalar)
    max_next_state_value = max(Q[next_state].values()) if Q[next_state] else 0

    # Update Q-table using Q-learning formula
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_state_value - Q[state][action])

# Output total profit
print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Convert state and next_state into hashable tuples (so they can be used as keys)
    state = tuple(get_state(new_data.iloc[t]))  # Hashable tuple for state
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Hashable tuple for next_state

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if they are missing
    if state not in Q:
        Q[state] = {action: 0 for action in actions}
    if next_state not in Q:
        Q[next_state] = {action: 0 for action in actions}

    # Get the maximum value of next_state's actions (safely as a scalar)
    max_next_state_value = max(Q[next_state].values(), default=0)  # Ensure a scalar max value

    # Update Q-table using Q-learning formula
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_state_value - Q[state][action])

# Output total profit
print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Convert state and next_state into hashable tuples (so they can be used as keys)
    state = tuple(get_state(new_data.iloc[t]))  # Hashable tuple for state
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Hashable tuple for next_state

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if they are missing
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Scalar values (floats) for each action
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}  # Initialize next_state if missing

    # Safely get the maximum value from next_state actions
    max_next_state_value = max(Q[next_state].values()) if Q[next_state] else 0.0  # Scalar

    # Update Q-table using Q-learning formula
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_state_value - Q[state][action])

# Output total profit
print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Convert state and next_state into hashable tuples (so they can be used as keys)
    state = tuple(get_state(new_data.iloc[t]))  # Hashable tuple for state
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Hashable tuple for next_state

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if they are missing
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Scalar values (floats) for each action
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}  # Initialize next_state if missing

    # Safely get the maximum value from next_state actions and ensure it's a float
    max_next_state_value = max(Q[next_state].values()) if Q[next_state] else 0.0
    max_next_state_value = float(max_next_state_value)  # Ensure it's a float

    # Update Q-table using Q-learning formula
    Q[state][action] = float(Q[state][action]) + alpha * (reward + gamma * max_next_state_value - float(Q[state][action]))

# Output total profit
print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Convert state and next_state into hashable tuples (so they can be used as keys)
    state = tuple(get_state(new_data.iloc[t]))  # Hashable tuple for state
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Hashable tuple for next_state

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if they are missing
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Ensure scalar (float) values for actions
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}  # Initialize next_state if missing

    # Safely get the maximum value from next_state actions, ensuring all are floats
    max_next_state_value = max([float(value) for value in Q[next_state].values()]) if Q[next_state] else 0.0

    # Update Q-table using Q-learning formula
    Q[state][action] = float(Q[state][action]) + alpha * (reward + gamma * max_next_state_value - float(Q[state][action]))

# Output total profit
print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Convert state and next_state into hashable tuples (so they can be used as keys)
    state = tuple(get_state(new_data.iloc[t]))  # Hashable tuple for state
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Hashable tuple for next_state

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if they are missing
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Ensure scalar (float) values for actions
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}  # Initialize next_state if missing

    # Safely get the maximum value from next_state actions, ensuring they are floats
    max_next_state_value = max([float(value) for value in Q[next_state].values() if isinstance(value, (int, float))]) if Q[next_state] else 0.0

    # Update Q-table using Q-learning formula, forcing all to be floats
    current_q_value = float(Q[state][action])  # Ensure the current value is a float
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

# Output total profit
print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Convert state and next_state into hashable tuples (so they can be used as keys)
    state = tuple(get_state(new_data.iloc[t]))  # Hashable tuple for state
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Hashable tuple for next_state

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if they are missing
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Ensure scalar (float) values for actions
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}  # Initialize next_state if missing

    # Safely get the maximum value from next_state actions, ensuring they are floats
    max_next_state_value = max([float(value) for value in Q[next_state].values() if isinstance(value, (int, float))]) if Q[next_state] else 0.0

    # Update Q-table using Q-learning formula, forcing all to be floats
    current_q_value = Q[state][action]  # Extract the current Q-value
    if isinstance(current_q_value, pd.Series):
        current_q_value = current_q_value.item()  # Extract the scalar from Series if needed

    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

# Output total profit
print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Convert state and next_state into hashable tuples (so they can be used as keys)
    state = tuple(get_state(new_data.iloc[t]))  # Hashable tuple for state
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Hashable tuple for next_state

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if they are missing
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Ensure scalar (float) values for actions
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}  # Initialize next_state if missing

    # Safely get the maximum value from next_state actions, ensuring they are floats
    max_next_state_value = max([float(value) for value in Q[next_state].values() if isinstance(value, (int, float))]) if Q[next_state] else 0.0

    # Update Q-table using Q-learning formula, ensuring all values are scalars
    current_q_value = Q[state][action]  # Extract the current Q-value

    if isinstance(current_q_value, pd.Series):
        # Handle cases where the current_q_value is a Series with multiple values
        if len(current_q_value) == 1:
            current_q_value = current_q_value.item()  # Extract scalar from Series
        else:
            raise ValueError("Encountered a Series with multiple values, expected a scalar.")

    # Apply Q-learning formula
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

# Output total profit
print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Convert state and next_state into hashable tuples (so they can be used as keys)
    state = tuple(get_state(new_data.iloc[t]))  # Hashable tuple for state
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Hashable tuple for next_state

    # Print state and Q-table status for debugging
    print(f"Iteration {t}: State = {state}, Next State = {next_state}")
    print(f"Q[state] = {Q.get(state, 'Not in Q-table')}")

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if they are missing
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Ensure scalar (float) values for actions
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}  # Initialize next_state if missing

    # Safely get the maximum value from next_state actions, ensuring they are floats
    max_next_state_value = max([float(value) for value in Q[next_state].values() if isinstance(value, (int, float))]) if Q[next_state] else 0.0

    # Update Q-table using Q-learning formula, ensuring all values are scalars
    current_q_value = Q[state][action]  # Extract the current Q-value

    # Debug: Check the type and length of current_q_value
    print(f"current_q_value = {current_q_value}, type: {type(current_q_value)}")

    if isinstance(current_q_value, pd.Series):
        # Handle cases where the current_q_value is a Series with multiple values
        if len(current_q_value) == 1:
            current_q_value = current_q_value.item()  # Extract scalar from Series
        else:
            print(f"Error at iteration {t}: Multiple values found in current_q_value: {current_q_value}")
            raise ValueError("Encountered a Series with multiple values, expected a scalar.")

    # Apply Q-learning formula
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

# Output total profit
print("Total Profit:", total_profit)

for t in range(len(new_data) - 1):
    # Convert state and next_state into hashable tuples (so they can be used as keys)
    state = tuple(get_state(new_data.iloc[t]))  # Hashable tuple for state
    next_state = tuple(get_state(new_data.iloc[t + 1]))  # Hashable tuple for next_state

    # Print state and Q-table status for debugging
    print(f"Iteration {t}: State = {state}, Next State = {next_state}")
    print(f"Q[state] = {Q.get(state, 'Not in Q-table')}")

    # Skip invalid states
    if state == (-1, -1, -1) or next_state == (-1, -1, -1):
        print(f"Skipping invalid state at iteration {t}")
        continue

    action = choose_action(state)
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    # Initialize state and next_state in Q-table if they are missing
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Ensure scalar (float) values for actions
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}  # Initialize next_state if missing

    # Safely get the maximum value from next_state actions, ensuring they are floats
    max_next_state_value = max([float(value) for value in Q[next_state].values() if isinstance(value, (int, float))]) if Q[next_state] else 0.0

    # Use the "Close" price only to update the Q-value (instead of the whole series)
    current_q_value = Q[state][action]  # Extract the current Q-value

    # Ensure it's a scalar value, not a series
    if isinstance(current_q_value, pd.Series):
        if 'Close' in current_q_value:
            current_q_value = current_q_value['Close']  # Only use the 'Close' price
        else:
            print(f"Error at iteration {t}: No 'Close' value in current_q_value: {current_q_value}")
            raise ValueError("Expected a scalar 'Close' value.")

    # Apply Q-learning formula
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

# Output total profit
print("Total Profit:", total_profit)

def calculate_reward(current_data, next_data, action):
    current_price = current_data['Close']
    next_price = next_data['Close']

    if action == 1:  # Buy
        return -current_price  # Negative reward because we spent money
    elif action == -1:  # Sell
        return next_price - current_price  # Positive reward if next price is higher
    else:  # Hold
        return 0  # No reward for holding

total_profit = 0
for t in range(len(new_data) - 1):
    # Existing Q-learning logic
    ...

    # Update profit when selling
    if action == -1:  # Sell action
        total_profit += calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

print("Total Profit after backtest:", total_profit)

def calculate_reward(current_data, next_data, action):
    current_price = current_data['Close']
    next_price = next_data['Close']

    if action == 1:  # Buy action
        return -current_price  # Spending money, so it's a negative reward
    elif action == -1:  # Sell action
        return next_price - current_price  # Profit if sold at a higher price
    else:  # Hold action
        return 0  # No reward for holding

total_profit = 0  # Initialize total profit

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)

    # Perform buy/sell logic
    next_state = get_state(new_data.iloc[t + 1])
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    if state not in Q:
        Q[state] = {action: 0 for action in actions}  # Initialize Q-table for the state

    if next_state not in Q:
        Q[next_state] = {action: 0 for action in actions}  # Initialize next state if missing

    max_next_state_value = max([float(value) for value in Q[next_state].values()])

    # Update Q-table using Q-learning formula
    current_q_value = Q[state][action]
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

    # Update total profit when selling
    if action == -1:  # Sell action
        total_profit += reward  # Add profit from sell action

# Print total profit after the backtest
print("Total Profit after backtest:", total_profit)

total_profit = 0  # Initialize total profit

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)

    # Perform buy/sell logic
    next_state = get_state(new_data.iloc[t + 1])
    reward = calculate_reward(new_data.iloc[t], new_data.iloc[t + 1], action)

    if state not in Q:
        Q[state] = {action: 0.0 for action in actions}  # Ensure initialization with floats

    if next_state not in Q:
        Q[next_state] = {action: 0.0 for action in actions}  # Ensure initialization with floats

    # Ensure max_next_state_value is a scalar value
    try:
        max_next_state_value = max([float(value) if not isinstance(value, pd.Series) else float(value.iloc[0])
                                    for value in Q[next_state].values()])
    except Exception as e:
        print(f"Error processing next state values: {e}")
        max_next_state_value = 0.0  # Use a fallback value in case of error

    # Update Q-table using Q-learning formula
    current_q_value = Q[state][action]
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

    # Update total profit when selling
    if action == -1:  # Sell action
        total_profit += reward  # Add profit from sell action

# Print total profit after the backtest
print("Total Profit after backtest:", total_profit)

def get_state(row):
    """Defines the state based on the current indicators (RSI, SMA_short, SMA_long)."""
    rsi = row['RSI']
    sma_short = row['SMA_short']
    sma_long = row['SMA_long']

    # Example state representation (you can modify this for better granularity)
    state = (int(rsi > 70),  # RSI overbought
             int(rsi < 30),  # RSI oversold
             int(sma_short > sma_long))  # Is short MA above long MA?

    return state

def choose_action(state):
    """Chooses the action based on the Q-values or exploration (epsilon-greedy)."""
    if random.uniform(0, 1) < epsilon:  # Exploration
        return random.choice(actions)  # Explore (random action)
    else:
        return np.argmax(Q[state])  # Exploit (choose best-known action)

def calculate_reward(current_price, next_price, action):
    if action == 1:  # Buy action
        return next_price - current_price  # Profit or loss from buying and selling
    elif action == -1:  # Sell action
        return current_price - next_price  # Profit from selling at higher price
    else:  # Hold action
        return 0  # Neutral reward for holding

reward = calculate_reward(new_data['Close'].iloc[t], new_data['Close'].iloc[t + 1], action)

Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_state_value - Q[state][action])

daily_spent = 0
daily_profit = 0
max_spend = 200
max_trade = 5
max_loss = -50

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)
    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]

    # Calculate reward based on action
    reward = calculate_reward(current_price, next_price, action)

    # Add trading constraints
    if action == 1:  # Buy action
        if daily_spent + max_trade <= max_spend:
            daily_spent += max_trade
            daily_profit += reward
        else:
            action = 0  # Hold if we exceed daily spend limit

    elif action == -1:  # Sell action
        daily_profit += reward

    # Check daily loss limit
    if daily_profit < max_loss:
        print("Daily loss limit reached. Halting trading for today.")
        break  # Stop trading if we exceed daily loss

    # Update Q-table
    next_state = get_state(new_data.iloc[t + 1])
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max(Q[next_state].values()) - Q[state][action])

    print(f"Iteration {t}: Action = {action}, Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)
    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]

    # Calculate reward based on action
    reward = calculate_reward(current_price, next_price, action)

    # Add trading constraints
    if action == 1:  # Buy action
        if daily_spent + max_trade <= max_spend:
            daily_spent += max_trade
            daily_profit += reward
        else:
            action = 0  # Hold if we exceed daily spend limit

    elif action == -1:  # Sell action
        daily_profit += reward

    # Check daily loss limit
    if daily_profit < max_loss:
        print("Daily loss limit reached. Halting trading for today.")
        break  # Stop trading if we exceed daily loss

    # Ensure Q-values are scalar
    if state not in Q:
        Q[state] = {action: 0.0 for action in actions}  # Initialize Q[state]

    if next_state not in Q:
        Q[next_state] = {action: 0.0 for action in actions}  # Initialize Q[next_state]

    max_next_state_value = max([float(value) for value in Q[next_state].values()])

    # Update Q-table
    Q[state][action] = float(Q[state][action]) + alpha * (reward + gamma * max_next_state_value - float(Q[state][action]))

    print(f"Iteration {t}: Action = {action}, Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)
    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]

    # Calculate reward based on action
    reward = calculate_reward(current_price, next_price, action)

    # Add trading constraints
    if action == 1:  # Buy action
        if daily_spent + max_trade <= max_spend:
            daily_spent += max_trade
            daily_profit += reward
        else:
            action = 0  # Hold if we exceed daily spend limit

    elif action == -1:  # Sell action
        daily_profit += reward

    # Check daily loss limit
    if daily_profit < max_loss:
        print("Daily loss limit reached. Halting trading for today.")
        break  # Stop trading if we exceed daily loss

    # Ensure Q-values are scalar
    if state not in Q:
        Q[state] = {action: 0.0 for action in actions}  # Initialize Q[state]

    if next_state not in Q:
        Q[next_state] = {action: 0.0 for action in actions}  # Initialize Q[next_state]

    # Safely get the maximum value from next_state actions
    max_next_state_value = max([float(value) if isinstance(value, (int, float)) else value.item()
                                for value in Q[next_state].values()])

    # Ensure the current Q-value is also a scalar
    current_q_value = Q[state][action]
    if isinstance(current_q_value, pd.Series):
        current_q_value = current_q_value.item()  # Extract the scalar from the Series

    # Update Q-table
    Q[state][action] = float(current_q_value) + alpha * (reward + gamma * max_next_state_value - float(current_q_value))

    print(f"Iteration {t}: Action = {action}, Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)
    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]

    # Calculate reward based on action
    reward = calculate_reward(current_price, next_price, action)

    # Add trading constraints
    if action == 1:  # Buy action
        if daily_spent + max_trade <= max_spend:
            daily_spent += max_trade
            daily_profit += reward
        else:
            action = 0  # Hold if we exceed daily spend limit

    elif action == -1:  # Sell action
        daily_profit += reward

    # Check daily loss limit
    if daily_profit < max_loss:
        print("Daily loss limit reached. Halting trading for today.")
        break  # Stop trading if we exceed daily loss

    # Ensure Q-values are scalar
    if state not in Q:
        Q[state] = {action: 0.0 for action in actions}  # Initialize Q[state]

    if next_state not in Q:
        Q[next_state] = {action: 0.0 for action in actions}  # Initialize Q[next_state]

    # Safely get the maximum value from next_state actions
    def get_scalar_value(value):
        if isinstance(value, pd.Series):
            if len(value) > 1:
                return value.iloc[0]  # Pick the first value
            else:
                return value.item()  # Extract scalar if single value
        return float(value)  # Ensure it's a float if already scalar

    max_next_state_value = max([get_scalar_value(value) for value in Q[next_state].values()])

    # Ensure the current Q-value is also a scalar
    current_q_value = Q[state][action]
    current_q_value = get_scalar_value(current_q_value)  # Ensure scalar

    # Update Q-table
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

    print(f"Iteration {t}: Action = {action}, Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

for t in range(len(new_data) - 1):
    state = get_state(new_data.iloc[t])
    action = choose_action(state)
    current_price = new_data['Close'].iloc[t]
    next_price = new_data['Close'].iloc[t + 1]

    # Calculate reward based on action
    reward = calculate_reward(current_price, next_price, action)

    # Add trading constraints
    if action == 1:  # Buy action
        if daily_spent + max_trade <= max_spend:
            daily_spent += max_trade
            daily_profit += reward
        else:
            action = 0  # Hold if we exceed daily spend limit

    elif action == -1:  # Sell action
        daily_profit += reward

    # Check daily loss limit
    if daily_profit < max_loss:
        print("Daily loss limit reached. Halting trading for today.")
        break  # Stop trading if we exceed daily loss

    # Ensure Q-values are scalar and initialized
    if state not in Q:
        Q[state] = {action: 0.0 for action in actions}  # Initialize Q[state]

    if action not in Q[state]:
        Q[state][action] = 0.0  # Initialize Q[state][action] if missing

    if next_state not in Q:
        Q[next_state] = {action: 0.0 for action in actions}  # Initialize Q[next_state]

    # Safely get the maximum value from next_state actions
    max_next_state_value = max([get_scalar_value(value) for value in Q[next_state].values()])

    # Ensure the current Q-value is also a scalar
    current_q_value = Q[state][action]
    current_q_value = get_scalar_value(current_q_value)  # Ensure scalar

    # Update Q-table
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

    print(f"Iteration {t}: Action = {action}, Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

# Check if the daily loss or spend limit has been reached at the end of the day
if daily_profit < max_loss:
    print(f"Max loss of {max_loss} reached. Stopping trading for today.")
    break  # End trading for the day if loss exceeds limit

if daily_spent >= max_spend:
    print(f"Max spend of {max_spend} reached. Stopping trading for today.")
    break  # End trading for the day if we exceed the allowed spend

for day_counter in range(total_days):  # Assume 'total_days' is the number of days to simulate
    daily_profit = 0
    daily_spent = 0

    # Assuming you have a loop over your trades (e.g., minute-by-minute trades)
    for t in range(len(new_data) - 1):
        state = get_state(new_data.iloc[t])
        action = choose_action(state)

        # Your trading logic here (e.g., buy/sell based on action)
        # ...

        # Calculate the daily profit/loss and spend
        daily_profit += calculate_profit(...)
        daily_spent += calculate_spend(...)

        # Check if the daily loss or spend limit has been reached
        if daily_profit < max_loss:
            print(f"Max loss of {max_loss} reached on day {day_counter}. Stopping trading for today.")
            break  # Exit inner loop to stop trading for the day

        if daily_spent >= max_spend:
            print(f"Max spend of {max_spend} reached on day {day_counter}. Stopping trading for today.")
            break  # Exit inner loop to stop trading for the day

    # Log daily results at the end of the day
    print(f"Summary for day {day_counter}: Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

    # Optionally, check if you want to stop the entire simulation
    if total_profit < some_global_limit:
        print("Stopping simulation due to overall profit/loss threshold.")
        break  # Exit outer loop to stop the simulation

total_days = 30  # Or any number of days you want to simulate

# Set the number of days to simulate
total_days = 30  # For example, simulate 30 days

# Main trading loop over days
for day_counter in range(total_days):
    daily_profit = 0
    daily_spent = 0

    # Loop over your trades (e.g., minute-by-minute trades)
    for t in range(len(new_data) - 1):
        state = get_state(new_data.iloc[t])
        action = choose_action(state)

        # Your trading logic here (e.g., buy/sell based on action)
        # ...

        # Calculate the daily profit/loss and spend
        daily_profit += calculate_profit(...)  # Define this function accordingly
        daily_spent += calculate_spend(...)  # Define this function accordingly

        # Check if the daily loss or spend limit has been reached
        if daily_profit < max_loss:
            print(f"Max loss of {max_loss} reached on day {day_counter}. Stopping trading for today.")
            break  # Exit inner loop to stop trading for the day

        if daily_spent >= max_spend:
            print(f"Max spend of {max_spend} reached on day {day_counter}. Stopping trading for today.")
            break  # Exit inner loop to stop trading for the day

    # Log daily results at the end of the day
    print(f"Summary for day {day_counter}: Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

    # Optionally, stop the entire simulation based on a condition
    if total_profit < some_global_limit:
        print("Stopping simulation due to overall profit/loss threshold.")
        break  # Exit outer loop to stop the simulation

def calculate_profit(buy_price, sell_price, quantity):
    """Calculate profit from a single trade."""
    return (sell_price - buy_price) * quantity

def calculate_spend(buy_price, quantity):
    """Calculate the total spend on a trade."""
    return buy_price * quantity

# Define total_days and max_loss/max_spend
total_days = 30
max_loss = 50  # Example maximum loss allowed
max_spend = 200  # Example maximum spend allowed

# Assuming you have buy_price and sell_price for each trade, and quantity of shares

# Define the functions
def calculate_profit(buy_price, sell_price, quantity):
    """Calculate profit from a single trade."""
    return (sell_price - buy_price) * quantity

def calculate_spend(buy_price, quantity):
    """Calculate total spend for a trade."""
    return buy_price * quantity

# Main trading loop over days
for day_counter in range(total_days):
    daily_profit = 0
    daily_spent = 0

    # Loop over trades (minute-by-minute trades)
    for t in range(len(new_data) - 1):
        state = get_state(new_data.iloc[t])
        action = choose_action(state)

        # Example: buy_price = Close price of the current minute, sell_price = Close price of the next minute
        buy_price = new_data['Close'].iloc[t]
        sell_price = new_data['Close'].iloc[t + 1]
        quantity = 1  # Example quantity of shares bought (could be fractional)

        if action == 0:  # If the action is to buy
            daily_spent += calculate_spend(buy_price, quantity)
        elif action == 1:  # If the action is to sell
            daily_profit += calculate_profit(buy_price, sell_price, quantity)

        # Check if the daily loss or spend limit has been reached
        if daily_profit < -max_loss:
            print(f"Max loss of {max_loss} reached on day {day_counter}. Stopping trading for today.")
            break  # Exit inner loop to stop trading for the day

        if daily_spent >= max_spend:
            print(f"Max spend of {max_spend} reached on day {day_counter}. Stopping trading for today.")
            break  # Exit inner loop to stop trading for the day

    # Log daily results at the end of the day
    print(f"Summary for day {day_counter}: Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

# Adjusted code to log and monitor Q-values and trading process

for day_counter in range(total_days):
    daily_profit = 0
    daily_spent = 0
    state = None
    action = None

    for t in range(len(new_data) - 1):
        state = get_state(new_data.iloc[t])
        action = choose_action(state)

        # Example: using close prices as buy and sell points
        buy_price = new_data['Close'].iloc[t]
        sell_price = new_data['Close'].iloc[t + 1]
        quantity = 1  # Assuming fixed quantity of shares, adjust if necessary

        # Log state and action for debugging
        print(f"Iteration {t}: State = {state}, Action = {action}")

        if action == 0:  # Buy action
            daily_spent += calculate_spend(buy_price, quantity)
        elif action == 1:  # Sell action
            daily_profit += calculate_profit(buy_price, sell_price, quantity)

        # Update the Q-table (reinforcement learning step)
        next_state = get_state(new_data.iloc[t + 1])

        if next_state not in Q:
            Q[next_state] = {action: 0.0 for action in actions}

        max_next_state_value = max([float(value) for value in Q[next_state].values()])

        # Ensure the current Q-value is a scalar before updating
        current_q_value = float(Q[state][action])

        # Q-learning update rule
        Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

        # Monitor for daily limits (l

# Safely handle Q-values and ensure they are scalars
def safe_get_scalar(value):
    # If the value is a pandas Series, extract the scalar
    if isinstance(value, pd.Series):
        if len(value) == 1:
            return value.item()  # Extract scalar
        else:
            raise ValueError(f"Expected a scalar but got multiple values: {value}")
    # Otherwise, ensure it's a float
    return float(value)

for day_counter in range(total_days):
    daily_profit = 0
    daily_spent = 0
    state = None
    action = None

    for t in range(len(new_data) - 1):
        state = get_state(new_data.iloc[t])
        action = choose_action(state)

        # Example: using close prices as buy and sell points
        buy_price = new_data['Close'].iloc[t]
        sell_price = new_data['Close'].iloc[t + 1]
        quantity = 1  # Assuming fixed quantity of shares, adjust if necessary

        # Log state and action for debugging
        print(f"Iteration {t}: State = {state}, Action = {action}")

        if action == 0:  # Buy action
            daily_spent += calculate_spend(buy_price, quantity)
        elif action == 1:  # Sell action
            daily_profit += calculate_profit(buy_price, sell_price, quantity)

        # Update the Q-table (reinforcement learning step)
        next_state = get_state(new_data.iloc[t + 1])

        if next_state not in Q:
            Q[next_state] = {action: 0.0 for action in actions}

        # Safely get the maximum value for the next state
        max_next_state_value = max([safe_get_scalar(value) for value in Q[next_state].values()])

        # Ensure the current Q-value is a scalar before updating
        current_q_value = safe_get_scalar(Q[state][action])

        # Q-learning update rule
        Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

        # Monitor for daily limits (loss or spend)
        if daily_profit < -max_loss:
            print(f"Max loss of {max_loss} exceeded on day {day_counter}. Stopping trading for today.")
            break

        if daily_spent >= max_spend:
            print(f"Max spend of {max_spend} reached on day {day_counter}. Stopping trading for today.")
            break

    # Log results at the end of the day
    print(f"Day {day_counter} completed: Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

# Reward is based on profit (can be adjusted for different strategies)
def calculate_reward(buy_price, sell_price, action):
    if action == 1:  # Sell action
        profit = sell_price - buy_price
        if profit > 0:
            return profit  # Positive reward for profit
        else:
            return -abs(profit)  # Negative reward for loss
    elif action == 0:  # Buy action (encourages taking action)
        return -buy_price * 0.01  # Small penalty for buying, incentivizes selling
    else:  # Hold action
        return 0  # Neutral reward for holding

total_days = 10  # Set the total number of days for the backtest (adjust as needed)

for day_counter in range(total_days):
    daily_profit = 0
    daily_spent = 0
    state = None
    action = None

    print(f"Starting day {day_counter + 1}...")

    for t in range(len(new_data) - 1):
        state = get_state(new_data.iloc[t])
        action = choose_action(state)

        buy_price = new_data['Close'].iloc[t]
        sell_price = new_data['Close'].iloc[t + 1]
        quantity = 1

        if action == 0:  # Buy action
            daily_spent += calculate_spend(buy_price, quantity)
        elif action == 1:  # Sell action
            daily_profit += calculate_profit(buy_price, sell_price, quantity)

        reward = calculate_reward(buy_price, sell_price, action)

        next_state = get_state(new_data.iloc[t + 1])
        if next_state not in Q:
            Q[next_state] = {action: 0.0 for action in actions}

        max_next_state_value = max([safe_get_scalar(value) for value in Q[next_state].values()])
        current_q_value = safe_get_scalar(Q[state][action])

        Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

        if daily_profit < -max_loss:
            print(f"Max loss of {max_loss} exceeded on day {day_counter + 1}. Stopping trading for today.")
            break

        if daily_spent >= max_spend:
            print(f"Max spend of {max_spend} reached on day {day_counter + 1}. Stopping trading for today.")
            break

    print(f"Day {day_counter + 1} finished: Daily Profit = {daily_profit}, Daily Spend = {daily_spent}")

total_profit = 0
total_spent = 0

for day_counter in range(total_days):
    daily_profit = 0
    daily_spent = 0

    for t in range(len(new_data) - 1):
        # trading logic (similar to the previous loop)
        pass

    total_profit += daily_profit
    total_spent += daily_spent

# Final review
average_daily_profit = total_profit / total_days
print(f"Total Profit: {total_profit}, Average Daily Profit: {average_daily_profit}")

def get_state(df_row):
    try:
        rsi = df_row['RSI']
        sma_short = df_row['SMA_short']
        sma_long = df_row['SMA_long']

        # Ensure we have valid data (no NaNs)
        if pd.isna(rsi) or pd.isna(sma_short) or pd.isna(sma_long):
            return (0, 0, 0)  # Default state if data is missing
        else:
            return (1 if rsi < 30 else 0, 1 if sma_short > sma_long else 0, 1 if sma_long > sma_short else 0)
    except KeyError:
        return (0, 0, 0)  # Default state if keys are missing

def calculate_profit(buy_price, sell_price, quantity):
    try:
        profit = (sell_price - buy_price) * quantity
        return max(0, profit)  # Ensure that we only return non-negative profits
    except ZeroDivisionError:
        return 0

def calculate_spend(buy_price, quantity):
    try:
        spend = buy_price * quantity
        return max(0, spend)  # Ensure spend is never negative
    except ZeroDivisionError:
        return 0

epsilon = 0.1  # Exploration rate (10% of the time, try a random action)

def choose_action(state):
    if np.random.rand() < epsilon:
        return np.random.choice(actions)  # Explore: choose a random action
    else:
        return np.argmax([Q[state][a] for a in actions])  # Exploit: choose the best known action

total_wins = 0
total_losses = 0
max_drawdown = 0
peak = 0
sharpe_ratio = 0

for day_counter in range(total_days):
    daily_profit = 0
    daily_spent = 0
    peak = max(peak, daily_profit)
    drawdown = (peak - daily_profit) / peak if peak > 0 else 0
    max_drawdown = max(max_drawdown, drawdown)

    if daily_profit > 0:
        total_wins += 1
    else:
        total_losses += 1

# Compute win/loss ratio and Sharpe ratio
win_loss_ratio = total_wins / total_losses if total_losses > 0 else 'N/A'
print(f"Win/Loss Ratio: {win_loss_ratio}, Max Drawdown: {max_drawdown}")

# Sharpe ratio calculation (assuming we have risk-free rate and daily returns)
mean_profit = np.mean([daily_profit for _ in range(total_days)])
std_dev_profit = np.std([daily_profit for _ in range(total_days)])
sharpe_ratio = mean_profit / std_dev_profit if std_dev_profit > 0 else 0
print(f"Sharpe Ratio: {sharpe_ratio}")

initial_alpha = 0.1  # Starting learning rate
decay_rate = 0.001   # How fast the learning rate decays over time
min_alpha = 0.01     # The minimum value for alpha

def update_learning_rate(iteration):
    return max(min_alpha, initial_alpha * (1.0 / (1.0 + decay_rate * iteration)))

# Apply the decaying learning rate in your Q-learning update rule
for iteration in range(total_iterations):
    alpha = update_learning_rate(iteration)
    ...

total_iterations = 1000  # Define how many iterations (trades) the AI should make

total_iterations = 1000  # Set the total number of iterations

# Apply the decaying learning rate in your Q-learning update rule
for iteration in range(total_iterations):
    alpha = update_learning_rate(iteration)
    # Your Q-learning logic here...

total_iterations = 1000  # Define how many iterations (trades) the AI should make

# Loop for the Q-learning process with dynamic learning rate
for iteration in range(total_iterations):
    alpha = update_learning_rate(iteration)  # Update learning rate dynamically
    gamma = 0.95  # Discount factor

    state = get_state(...)  # Get the current state
    action = choose_action(state)  # Choose action based on the state

    reward = calculate_reward(...)  # Calculate the reward
    next_state = get_state(...)  # Get the next state

    # Initialize Q-value for the next state if it doesn't exist
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}

    # Get the maximum Q-value for the next state (for future action prediction)
    max_next_state_value = max([float(value) for value in Q[next_state].values()])

    # Ensure the current Q-value is a scalar before updating
    current_q_value = Q[state][action]
    current_q_value = get_scalar_value(current_q_value)  # Ensure scalar

    # Q-learning update formula
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

    print(f"Iteration {iteration}: State = {state}, Action = {action}, Alpha = {alpha}")

for iteration in range(total_iterations):
    alpha = update_learning_rate(iteration)  # Update learning rate dynamically
    gamma = 0.95  # Discount factor

    # Get the current state from the data (assuming new_data is your DataFrame)
    state = get_state(new_data.iloc[iteration])
    action = choose_action(state)  # Choose action based on the state

    reward = calculate_reward(...)  # Placeholder: You need to calculate reward
    next_state = get_state(new_data.iloc[iteration + 1])

    # Initialize Q-value for the next state if it doesn't exist
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}

    # Get the maximum Q-value for the next state
    max_next_state_value = max([float(value) for value in Q[next_state].values()])

    # Ensure the current Q-value is a scalar before updating
    current_q_value = Q[state][action]
    current_q_value = get_scalar_value(current_q_value)  # Ensure scalar

    # Q-learning update formula
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

    print(f"Iteration {iteration}: State = {state}, Action = {action}, Alpha = {alpha}")

def calculate_reward(buy_price, sell_price, action):
    """
    Calculate reward based on the difference between buy and sell prices.

    :param buy_price: The price at which the asset was bought
    :param sell_price: The price at which the asset was sold
    :param action: Action taken, 1 for buying, -1 for selling
    :return: Reward (profit or loss) from the trade
    """
    if action == -1:  # Sell action
        reward = sell_price - buy_price  # Profit (or loss) from the trade
    else:
        reward = 0  # No reward for holding or buying
    return reward

for iteration in range(total_iterations):
    alpha = update_learning_rate(iteration)  # Update learning rate dynamically
    gamma = 0.95  # Discount factor

    # Get the current state from the data (assuming new_data is your DataFrame)
    state = get_state(new_data.iloc[iteration])
    action = choose_action(state)  # Choose action based on the state

    # Define your buy_price and sell_price (example)
    buy_price = new_data['Close'].iloc[iteration]  # Use 'Close' price as buy price
    sell_price = new_data['Close'].iloc[iteration + 1]  # Sell at next time step

    # Calculate reward based on action (buy/sell)
    reward = calculate_reward(buy_price, sell_price, action)

    next_state = get_state(new_data.iloc[iteration + 1])

    # Initialize Q-value for the next state if it doesn't exist
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}

    # Get the maximum Q-value for the next state
    max_next_state_value = max([float(value) for value in Q[next_state].values()])

    # Ensure the current Q-value is a scalar before updating
    current_q_value = Q[state][action]
    current_q_value = get_scalar_value(current_q_value)  # Ensure scalar

    # Q-learning update formula
    Q[state][action] = current_q_value + alpha * (reward + gamma * max_next_state_value - current_q_value)

    print(f"Iteration {iteration}: State = {state}, Action = {action}, Reward = {reward}, Alpha = {alpha}")

# Ensure the current state is initialized in Q-table
if state not in Q:
    Q[state] = {a: 0.0 for a in actions}  # Initialize all actions with Q-value of 0.0

# Now choose an action
action = choose_action(state)  # Choose the best action based on current state

def choose_action(state):
    # Ensure the state exists in the Q-table
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Initialize all actions for the new state

    # Epsilon-greedy action selection
    if np.random.rand() < epsilon:
        return np.random.choice(actions)  # Explore: randomly choose an action
    else:
        return np.argmax([Q[state][a] for a in actions])  # Exploit: choose the best action

# Ensure the state is initialized in the Q-table
if state not in Q:
    Q[state] = {a: 0.0 for a in actions}  # Initialize with default Q-values

# Now, select the action
action = choose_action(state)

def choose_action(state):
    # Ensure the state exists in the Q-table and initialize actions for the state
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Initialize all actions with Q-values of 0.0

    # Epsilon-greedy action selection
    if np.random.rand() < epsilon:
        return np.random.choice(actions)  # Explore: choose a random action
    else:
        return actions[np.argmax([Q[state][a] for a in actions])]  # Exploit: choose the best action

# Main loop where the Q-learning occurs
for iteration in range(total_iterations):
    # Get the current state from the data
    state = get_state(new_data.iloc[iteration])

    # Ensure the state is in the Q-table
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Initialize with default Q-values

    # Select an action
    action = choose_action(state)

    # Define your buy_price and sell_price (example values, replace as needed)
    buy_price = new_data['Close'].iloc[iteration]
    sell_price = new_data['Close'].iloc[iteration + 1] if iteration + 1 < len(new_data) else buy_price

    # Calculate the reward (assuming calculate_reward is defined)
    reward = calculate_reward(buy_price, sell_price, action)

    # Perform your Q-table update logic here

    # Example of Q-table update (you can modify this to fit your logic)
    next_state = get_state(new_data.iloc[iteration + 1]) if iteration + 1 < len(new_data) else state
    max_next_q_value = max(Q[next_state].values()) if next_state in Q else 0

    # Q-learning update rule
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_q_value - Q[state][action])

def choose_action(state):
    # Ensure the state exists in the Q-table and initialize actions for the state
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Initialize all actions (-1, 0, 1) with Q-values of 0.0

    # Epsilon-greedy action selection
    if np.random.rand() < epsilon:
        return np.random.choice(actions)  # Explore: choose a random action
    else:
        return actions[np.argmax([Q[state].get(a, 0.0) for a in actions])]  # Exploit: choose the best action

# Main loop where the Q-learning occurs
for iteration in range(total_iterations):
    # Get the current state from the data
    state = get_state(new_data.iloc[iteration])

    # Ensure the state is in the Q-table
    if state not in Q:
        Q[state] = {a: 0.0 for a in actions}  # Initialize all actions (-1, 0, 1) with default Q-values

    # Select an action
    action = choose_action(state)

    # Define your buy_price and sell_price (example values, replace as needed)
    buy_price = new_data['Close'].iloc[iteration]
    sell_price = new_data['Close'].iloc[iteration + 1] if iteration + 1 < len(new_data) else buy_price

    # Calculate the reward (assuming calculate_reward is defined)
    reward = calculate_reward(buy_price, sell_price, action)

    # Get the next state and update Q-table
    next_state = get_state(new_data.iloc[iteration + 1]) if iteration + 1 < len(new_data) else state
    if next_state not in Q:
        Q[next_state] = {a: 0.0 for a in actions}  # Initialize next_state if not in Q-table

    max_next_q_value = max(Q[next_state].values())  # Get max Q-value for next state

    # Q-learning update rule
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_q_value - Q[state][action])

    # Print the iteration, action, reward, and Q-values for debugging
    print(f"Iteration {iteration}: State = {state}, Action = {action}, Reward = {reward}, Q-values = {Q[state]}")

# Ensure actions for the state are initialized in Q-table
if state not in Q:
    Q[state] = {a: 0.0 for a in actions}  # Initialize all actions for the current state

# Q-learning update rule
if action not in Q[state]:
    Q[state][action] = 0.0  # Initialize action if not present

# Perform the Q-learning update
Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_q_value - Q[state][action])

# Print the iteration, action, reward, and Q-values for debugging
print(f"Iteration {iteration}: State = {state}, Action = {action}, Reward = {reward}, Q-values = {Q[state]}")

def calculate_reward(buy_price, sell_price, action):
    if action == 1:  # Sell action
        return sell_price - buy_price  # Profit from the sale
    elif action == -1:  # Buy action
        return -1 * (buy_price)  # Cost of buying
    else:
        return 0  # No reward for 'hold' action

for iteration in range(total_iterations):
    state = get_state(new_data.iloc[iteration])
    print(f"Iteration {iteration}: State = {state}")

    action = choose_action(state)  # Choose action based on the state
    print(f"Iteration {iteration}: Action = {action}")

    # Here you'd also call the function to buy or sell based on the action and update your reward.

# Ensure the loop doesn't exceed the length of the dataset
total_iterations = min(total_iterations, len(new_data) - 1)

for iteration in range(total_iterations):
    # Get the current state
    state = get_state(new_data.iloc[iteration])
    print(f"Iteration {iteration}: State = {state}")

    action = choose_action(state)  # Choose action based on the state
    print(f"Iteration {iteration}: Action = {action}")

    # Get the reward (you may need to define or modify how you handle buying/selling prices)
    buy_price = new_data['Close'].iloc[iteration]
    sell_price = new_data['Close'].iloc[iteration + 1] if iteration + 1 < len(new_data) else buy_price
    reward = calculate_reward(buy_price, sell_price, action)
    print(f"Iteration {iteration}: Reward = {reward}")

    # Proceed with Q-learning updates and avoid errors
    next_state = get_state(new_data.iloc[iteration + 1]) if iteration + 1 < len(new_data) else state
    max_next_q_value = max([Q[next_state][a] for a in actions if next_state in Q], default=0)

    # Update Q-values using Q-learning
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_q_value - Q[state][action])

    print(f"Iteration {iteration}: Q-values = {Q[state]}")

# Initialize performance tracking variables
total_profit = 0
total_loss = 0
total_trades = 0
profitable_trades = 0
unprofitable_trades = 0

for iteration in range(total_iterations):
    # Get the current state
    state = get_state(new_data.iloc[iteration])
    print(f"Iteration {iteration}: State = {state}")

    action = choose_action(state)  # Choose action based on the state
    print(f"Iteration {iteration}: Action = {action}")

    # Get the reward (you may need to define or modify how you handle buying/selling prices)
    buy_price = new_data['Close'].iloc[iteration]
    sell_price = new_data['Close'].iloc[iteration + 1] if iteration + 1 < len(new_data) else buy_price
    reward = calculate_reward(buy_price, sell_price, action)
    print(f"Iteration {iteration}: Reward = {reward}")

    # Track profit or loss
    if reward > 0:
        total_profit += reward
        profitable_trades += 1
    elif reward < 0:
        total_loss += reward
        unprofitable_trades += 1
    total_trades += 1

    # Get the next state
    next_state = get_state(new_data.iloc[iteration + 1]) if iteration + 1 < len(new_data) else state
    max_next_q_value = max([Q[next_state][a] for a in actions if next_state in Q], default=0)

    # Update Q-values using Q-learning
    Q[state][action] = Q[state][action] + alpha * (reward + gamma * max_next_q_value - Q[state][action])

    print(f"Iteration {iteration}: Q-values = {Q[state]}")

# Summary of performance
print(f"Total Trades: {total_trades}")
print(f"Profitable Trades: {profitable_trades}")
print(f"Unprofitable Trades: {unprofitable_trades}")
print(f"Total Profit: {total_profit}")
print(f"Total Loss: {total_loss}")
print(f"Net Profit: {total_profit + total_loss}")

def calculate_reward(action, profit):
    if action == 1:  # Buy
        return profit  # Positive reward based on profit
    elif action == -1:  # Sell
        return -profit  # Negative reward based on loss
    else:
        return -1  # Small penalty for inactivity

import random

def choose_action(state, epsilon):
    if random.random() < epsilon:  # Explore
        return random.choice([-1, 0, 1])
    else:  # Exploit
        return max(q_values[state], key=q_values[state].get)  # Choose the best action

# Example of decaying epsilon
epsilon = 1.0  # Start with full exploration
decay_rate = 0.995
min_epsilon = 0.1  # Minimum exploration rate

for iteration in range(total_iterations):
    # Update epsilon after every episode
    epsilon = max(min_epsilon, epsilon * decay_rate)

alpha = 0.1  # Learning rate
gamma = 0.99  # Discount factor

for iteration in range(total_iterations):
    state = get_state(new_data.iloc[iteration])
    action = choose_action(state, epsilon)

    # Perform the action and receive reward
    reward = perform_action(action)
    next_state = get_state(new_data.iloc[iteration + 1])  # Assuming you're moving to the next state

    # Update Q-values
    best_next_action = max(q_values[next_state], key=q_values[next_state].get)
    q_values[state][action] += alpha * (reward + gamma * q_values[next_state][best_next_action] - q_values[state][action])

# Initialize Q-values as a nested dictionary for each state
q_values = {}
# Assuming your state has three dimensions: (0, 1, 0), (1, 0, 1), etc.
# You can define a range of states depending on your specific use case.
for s1 in range(2):  # Example for first dimension
    for s2 in range(2):  # Example for second dimension
        for s3 in range(2):  # Example for third dimension
            q_values[(s1, s2, s3)] = {-1: 0.0, 0: 0.0, 1: 0.0}  # Initialize all actions for each state

def choose_action(state, epsilon):
    if random.random() < epsilon:  # Explore
        return random.choice([-1, 0, 1])
    else:  # Exploit
        return max(q_values[state], key=q_values[state].get)  # Choose the best action

# Initialize Q-values
q_values = {}
for s1 in range(2):  # Example for first dimension
    for s2 in range(2):  # Example for second dimension
        for s3 in range(2):  # Example for third dimension
            q_values[(s1, s2, s3)] = {-1: 0.0, 0: 0.0, 1: 0.0}

alpha = 0.1  # Learning rate
gamma = 0.99  # Discount factor
epsilon = 0.1  # Exploration rate

for iteration in range(total_iterations):
    state = get_state(new_data.iloc[iteration])
    action = choose_action(state, epsilon)

    # Perform the action and receive reward
    reward = perform_action(action)
    next_state = get_state(new_data.iloc[iteration + 1])  # Assuming you're moving to the next state

    # Update Q-values
    best_next_action = max(q_values[next_state], key=q_values[next_state].get)
    q_values[state][action] += alpha * (reward + gamma * q_values[next_state][best_next_action] - q_values[state][action])

def perform_action(action):
    # You need to define the logic for how the action affects your environment/state
    global current_state  # You might need to track the current state globally or pass it as an argument

    # Example logic based on action
    if action == -1:  # Action to sell
        reward = current_state[1]  # Replace this with actual logic to calculate reward
    elif action == 0:  # Action to hold
        reward = 0  # No reward for holding
    elif action == 1:  # Action to buy
        reward = -current_state[1]  # Replace this with actual logic to calculate reward

    # Update the current state based on action taken
    # Example state transition logic can be implemented here

    return reward

# Example of initializing the current state
current_state = (0, 0, 0)  # Example starting state

# Initialize Q-values
q_values = {}
for s1 in range(2):  # Example for first dimension
    for s2 in range(2):  # Example for second dimension
        for s3 in range(2):  # Example for third dimension
            q_values[(s1, s2, s3)] = {-1: 0.0, 0: 0.0, 1: 0.0}

alpha = 0.1  # Learning rate
gamma = 0.99  # Discount factor
epsilon = 0.1  # Exploration rate

# Example of initializing the current state
current_state = (0, 0, 0)  # Example starting state

def perform_action(action):
    global current_state
    # Example logic for reward based on action
    if action == -1:  # Sell
        reward = current_state[1]  # Replace with actual reward logic
    elif action == 0:  # Hold
        reward = 0
    elif action == 1:  # Buy
        reward = -current_state[1]  # Replace with actual reward logic

    # Update current_state here based on the action taken
    # Example: current_state = new_state_after_action

    return reward

for iteration in range(total_iterations):
    state = get_state(new_data.iloc[iteration])
    action = choose_action(state, epsilon)

    # Perform the action and receive reward
    reward = perform_action(action)
    next_state = get_state(new_data.iloc[iteration + 1])  # Move to next state

    # Update Q-values
    best_next_action = max(q_values[next_state], key=q_values[next_state].get)
    q_values[state][action] += alpha * (reward + gamma * q_values[next_state][best_next_action] - q_values[state][action])

# Update the perform_action function to change the current state
def perform_action(action, iteration):
    global current_state
    # Get the current market price from new_data
    current_price = new_data.iloc[iteration]['price']  # Adjust column name as needed

    if action == -1:  # Sell
        # Calculate reward based on selling logic
        reward = current_state[1]  # Replace with actual logic for selling
    elif action == 0:  # Hold
        reward = 0
    elif action == 1:  # Buy
        # Calculate reward based on buying logic
        reward = -current_price  # Replace with actual logic for buying

    # Update the current state (this is a simplistic example)
    # You may want to implement a more complex state transition logic here
    current_state = (current_price, action, iteration)

    return reward

total_profit = 0
total_trades = 0
profitable_trades = 0
unprofitable_trades = 0

for iteration in range(total_iterations):
    state = get_state(new_data.iloc[iteration])
    action = choose_action(state, epsilon)

    # Perform the action and receive reward
    reward = perform_action(action, iteration)

    # Update profit tracking
    total_profit += reward
    total_trades += 1

    if reward > 0:
        profitable_trades += 1
    elif reward < 0:
        unprofitable_trades += 1

    next_state = get_state(new_data.iloc[iteration + 1])  # Move to next state

    # Update Q-values
    best_next_action = max(q_values[next_state], key=q_values[next_state].get)
    q_values[state][action] += alpha * (reward + gamma * q_values[next_state][best_next_action] - q_values[state][action])

# At the end of the iterations, print the performance metrics
print(f"Total Trades: {total_trades}")
print(f"Profitable Trades: {profitable_trades}")
print(f"Unprofitable Trades: {unprofitable_trades}")
print(f"Total Profit: {total_profit}")

print(new_data.columns)

current_price = new_data.iloc[iteration]['price']

print(new_data.columns)

# Replace this line:
current_price = new_data.iloc[iteration]['price']

# With this line (using the correct column name):
current_price = new_data.iloc[iteration]['closing_price']

# Print the DataFrame and its columns to check structure
print(new_data.head())  # Display the first few rows of the DataFrame
print(new_data.columns)  # Display the column names of the DataFrame

current_price = new_data.iloc[iteration]['closing_price']

# Print the DataFrame and its columns to check structure
print(new_data.head())  # Display the first few rows of the DataFrame
print(new_data.columns)  # Display the column names of the DataFrame

current_price = new_data.iloc[iteration]['price']  # Use the correct column name here

# Check the first few rows of the DataFrame
print(new_data.head())

# Check the column names in the DataFrame
print(new_data.columns.tolist())

# Example: Update the access in your code
current_price = new_data['close'].iloc[iteration]  # Adjust this line

# Check the first few rows of the DataFrame
print(new_data.head())

# Check the column names in the DataFrame
print(new_data.columns.tolist())

current_price = new_data['Closing Price'].iloc[iteration]

# Print the first few rows of the DataFrame and the column names
print("DataFrame Head:\n", new_data.head())
print("DataFrame Columns:", new_data.columns.tolist())

# Adjust this line based on the actual column name
current_price = new_data['Close'].iloc[iteration]  # Use the exact column name you found

# Test accessing a specific value in the DataFrame
try:
    print("Accessing price at iteration 0:", new_data['close'].iloc[0])  # Adjust column name if necessary
except KeyError as e:
    print(f"KeyError: {e}. Please check the column names.")

# Example of loading data
new_data = pd.read_csv('your_data_file.csv')  # Adjust this based on how you're loading your data

# After loading, check the structure again
print("DataFrame Head:\n", new_data.head())
print("DataFrame Columns:", new_data.columns.tolist())

pip install yfinance

import yfinance as yf

# List of your stock tickers
tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "FB", "NFLX", "NVDA", "BRK-B", "JPM", "V", "UNH", "HD", "PG", "DIS", "VZ", "MA", "INTC", "CMCSA", "CSCO", "PEP", "ADBE", "NKE", "T"]

# Download historical data
data = yf.download(tickers, start="2020-01-01", end="2024-10-01")

# Save to CSV
data.to_csv("historical_data.csv")

pip install alpha_vantage

from alpha_vantage.timeseries import TimeSeries
import pandas as pd

# Initialize
ts = TimeSeries(key='YOUR_API_KEY', output_format='pandas')

# List of tickers
tickers = ["AAPL", "GOOGL", "MSFT", ...]

# Create an empty DataFrame
all_data = pd.DataFrame()

for ticker in tickers:
    data, _ = ts.get_daily(symbol=ticker, outputsize='full')
    data['Ticker'] = ticker
    all_data = all_data.append(data)

all_data.to_csv("historical_data_alpha_vantage.csv")

from alpha_vantage.timeseries import TimeSeries
import pandas as pd

# Initialize Alpha Vantage with your API key
ts = TimeSeries(key='YOUR_API_KEY', output_format='pandas')

# List of tickers
tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "FB", "NFLX", "NVDA", "BRK-B", "JPM",
           "V", "UNH", "HD", "PG", "DIS", "VZ", "MA", "INTC", "CMCSA", "CSCO",
           "PEP", "ADBE", "NKE", "T"]

# Create a list to hold DataFrames
data_frames = []

for ticker in tickers:
    data, _ = ts.get_daily(symbol=ticker, outputsize='full')
    data['Ticker'] = ticker  # Add a column for the ticker
    data_frames.append(data)  # Append DataFrame to the list

# Concatenate all DataFrames into one
all_data = pd.concat(data_frames)

# Save the combined DataFrame to a CSV file
all_data.to_csv("historical_data_alpha_vantage.csv")

from alpha_vantage.timeseries import TimeSeries
import pandas as pd

# Use your actual API key
api_key = 'yLZzzY_8ZZ6FElsmmRjSHYvuUMSmxnFB'
ts = TimeSeries(key=api_key, output_format='pandas')

# List of stock tickers you want to fetch data for
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'FB', 'TSLA',
           'NVDA', 'BRK.B', 'JPM', 'V', 'UNH', 'JNJ',
           'PG', 'HD', 'DIS', 'NFLX', 'VZ', 'INTC',
           'CMCSA', 'PEP', 'T', 'MRK', 'NKE', 'ADBE',
           'CSCO']

all_data = pd.DataFrame()

for ticker in tickers:
    try:
        data, _ = ts.get_daily(symbol=ticker, outputsize='full')
        data['Ticker'] = ticker  # Add a column for the ticker
        all_data = pd.concat([all_data, data])  # Use concat instead of append
    except Exception as e:
        print(f"Error fetching data for {ticker}: {e}")

# Save the combined DataFrame to a CSV file
all_data.to_csv("historical_data_alpha_vantage.csv")
print("Historical data for all stocks has been saved.")

import pandas as pd
from alpha_vantage.timeseries import TimeSeries

# Initialize the TimeSeries object
ts = TimeSeries(key='yLZzzY_8ZZ6FElsmmRjSHYvuUMSmxnFB', output_format='pandas')

# List of stock tickers you want to download data for
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'FB', 'BRK.B', 'JPM', 'JNJ', 'V', 'PG', 'MA', 'NVDA', 'DIS', 'NFLX', 'VZ', 'PYPL', 'ADBE', 'CMCSA', 'CSCO', 'PEP', 'INTC', 'T', 'XOM', 'MRK']

# Initialize an empty DataFrame to store all data
all_data = pd.DataFrame()

# Loop through tickers and get daily data
for ticker in tickers:
    try:
        data, _ = ts.get_daily(symbol=ticker, outputsize='full')
        data['Ticker'] = ticker  # Add a column for the ticker
        all_data = pd.concat([all_data, data])  # Use concat to append DataFrames
    except Exception as e:
        print(f"Error retrieving data for {ticker}: {e}")

# Save to CSV
all_data.to_csv("historical_data_alpha_vantage.csv")

import pandas as pd

# Load the historical data
data = pd.read_csv("historical_data_alpha_vantage.csv")
print("Data Loaded. Sample Data:\n", data.head())

# Check for missing values
print("Missing values:\n", data.isnull().sum())

# Drop any rows with missing values (if necessary)
data.dropna(inplace=True)

# Convert the date column to datetime type
data['date'] = pd.to_datetime(data['date'])
data.set_index('date', inplace=True)

import pandas as pd

# Load the historical data
data = pd.read_csv("historical_data_alpha_vantage.csv")

# Check the columns and the first few rows of the DataFrame
print("Columns in DataFrame:", data.columns)
print("Sample Data:\n", data.head())

# Let's assume the date column is named 'timestamp'
data['timestamp'] = pd.to_datetime(data['timestamp'])  # Adjust based on the actual column name
data.set_index('timestamp', inplace=True)  # Set the timestamp as the index

import pandas as pd

# Load the historical data
data = pd.read_csv("historical_data_alpha_vantage.csv")

# Display the columns and the first few rows
print("Columns in DataFrame:", data.columns.tolist())
print("Sample Data:\n", data.head())

data['Date'] = pd.to_datetime(data['Date'])  # Adjust based on the actual column name
data.set_index('Date', inplace=True)  # Set the date as the index

import pandas as pd

# Load the historical data
try:
    data = pd.read_csv("historical_data_alpha_vantage.csv")

    # Display the columns and the first few rows
    print("Columns in DataFrame:", data.columns.tolist())
    print("Sample Data:\n", data.head())

    # Check the info for data types
    print("\nDataFrame Info:")
    print(data.info())
except Exception as e:
    print("Error loading the data:", e)

# Adjust these to your actual column names
date_column = 'YourDateColumn'  # replace with your date column name
price_column = 'YourPriceColumn'  # replace with your price column name

# Convert the date column to datetime format
data[date_column] = pd.to_datetime(data[date_column], errors='coerce')

# Set the date column as the index
data.set_index(date_column, inplace=True)

# Sort the DataFrame by date
data.sort_index(inplace=True)

# Display the cleaned DataFrame
print("Cleaned DataFrame Head:\n", data.head())

# Display the column names of the DataFrame
print("DataFrame Columns:\n", data.columns)

date_column = 'timestamp'  # replace with your actual date column name
price_column = 'close'      # replace with your actual price column name

# Convert the date column to datetime format
data[date_column] = pd.to_datetime(data[date_column], errors='coerce')

# Set the date column as the index
data.set_index(date_column, inplace=True)

# Sort the DataFrame by date
data.sort_index(inplace=True)

# Display the cleaned DataFrame
print("Cleaned DataFrame Head:\n", data.head())

# Display the first few rows and column names of the DataFrame
print("DataFrame Head:\n", data.head())
print("DataFrame Columns:\n", data.columns)

# Step 4: Prepare the Data for Training

# 1. Convert the Date Column to Datetime Format
data['YourDateColumn'] = pd.to_datetime(data['YourDateColumn'])

# 2. Set the Date as the Index
data.set_index('YourDateColumn', inplace=True)

# 3. Resample Data (if necessary)
# For example, resampling to daily frequency, you might use:
data = data.resample('D').mean()  # Adjust frequency as needed ('T' for minute, 'H' for hourly, etc.)

# Check the prepared DataFrame
print("Prepared DataFrame Head:\n", data.head())

# Check the DataFrame columns
print("DataFrame Columns:\n", data.columns)

# Step 4: Prepare the Data for Training

# 1. Convert the Date Column to Datetime Format
data['ActualDateColumnName'] = pd.to_datetime(data['ActualDateColumnName'])

# 2. Set the Date as the Index
data.set_index('ActualDateColumnName', inplace=True)

# 3. Resample Data (if necessary)
data = data.resample('D').mean()  # Adjust frequency as needed

# Check the prepared DataFrame
print("Prepared DataFrame Head:\n", data.head())

# Assuming your DataFrame is named 'data'
print("DataFrame Columns:\n", data.columns)

# 1. Convert the Date Column to Datetime Format
data['timestamp'] = pd.to_datetime(data['timestamp'])

# 2. Set the Date as the Index
data.set_index('timestamp', inplace=True)

# 3. Resample Data (if necessary)
data = data.resample('D').mean()  # Adjust frequency as needed

# Check the prepared DataFrame
print("Prepared DataFrame Head:\n", data.head())

# Assuming your DataFrame is named 'data'
print("DataFrame Columns:\n", data.columns)

# 1. Convert the Date Column to Datetime Format
data['date'] = pd.to_datetime(data['date'])

# 2. Set the Date as the Index
data.set_index('date', inplace=True)

# 3. Resample Data (if necessary)
data = data.resample('D').mean()  # Adjust frequency as needed

# Check the prepared DataFrame
print("Prepared DataFrame Head:\n", data.head())

import pandas as pd

# Load the historical data
try:
    data = pd.read_csv('historical_data_alpha_vantage.csv')  # Adjust the file name if needed
    print("Data Loaded Successfully:")
    print(data.head())  # Display the first few rows
    print("\nColumns in DataFrame:", data.columns)  # Display the column names
except FileNotFoundError as e:
    print("File not found. Please ensure the file path is correct.")
except Exception as e:
    print("An error occurred:", e)

# Assuming the identified date column is 'date'
try:
    # Convert the identified Date Column to Datetime Format
    data['date'] = pd.to_datetime(data['date'])  # Replace 'date' with the actual date column name if different

    # Set the Date as the Index
    data.set_index('date', inplace=True)

    # Optional: Resample the data (if necessary)
    data = data.resample('D').mean()  # Adjust frequency as needed

    print("Prepared DataFrame Head:\n", data.head())  # Display the prepared DataFrame
except KeyError as e:
    print("Key error: The specified date column does not exist in the DataFrame.", e)
except Exception as e:
    print("An error occurred during date processing:", e)

import numpy as np

# Function to calculate RSI
def calculate_rsi(data, period=14):
    delta = data['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Function to generate signals
def generate_signals(data):
    data['rsi'] = calculate_rsi(data)
    data['moving_average'] = data['close'].rolling(window=20).mean()  # Example: 20-day moving average

    # Buy when RSI < 30 and close price > moving average
    data['buy_signal'] = (data['rsi'] < 30) & (data['close'] > data['moving_average'])

    # Sell when RSI > 70 and close price < moving average
    data['sell_signal'] = (data['rsi'] > 70) & (data['close'] < data['moving_average'])

# Apply the signals to the DataFrame
generate_signals(data)

# Display signals
print("Signals:\n", data[['close', 'rsi', 'moving_average', 'buy_signal', 'sell_signal']].tail(10))

# Check the DataFrame columns
print("DataFrame Columns:\n", data.columns)

# Update the calculate_rsi function to reflect the correct column name
def calculate_rsi(data, period=14):
    delta = data['Close'].diff()  # Use the correct column name here
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Update the generate_signals function as well
def generate_signals(data):
    data['rsi'] = calculate_rsi(data)
    data['moving_average'] = data['Close'].rolling(window=20).mean()  # Use the correct column name
    data['buy_signal'] = (data['rsi'] < 30) & (data['Close'] > data['moving_average'])
    data['sell_signal'] = (data['rsi'] > 70) & (data['Close'] < data['moving_average'])

import pandas as pd

# Assuming you already have your DataFrame 'data'
# Display the first few rows to ensure the new columns are added correctly
data['rsi'] = calculate_rsi(data)
data['moving_average'] = data['Close'].rolling(window=20).mean()  # Update if column name is different
data['buy_signal'] = (data['rsi'] < 30) & (data['Close'] > data['moving_average'])
data['sell_signal'] = (data['rsi'] > 70) & (data['Close'] < data['moving_average'])

# Display the DataFrame to verify the new columns
print(data[['Close', 'rsi', 'moving_average', 'buy_signal', 'sell_signal']].tail(10))

# Print the column names to identify the correct ones
print(data.columns)

# Update this to match your actual column names
close_column = 'close'  # Replace with the actual column name for closing prices

# Calculating RSI and moving average
data['rsi'] = calculate_rsi(data)
data['moving_average'] = data[close_column].rolling(window=20).mean()  # Use the updated variable

# Generate buy and sell signals
data['buy_signal'] = (data['rsi'] < 30) & (data[close_column] > data['moving_average'])
data['sell_signal'] = (data['rsi'] > 70) & (data[close_column] < data['moving_average'])

# Display the DataFrame to verify the new columns
print(data[[close_column, 'rsi', 'moving_average', 'buy_signal', 'sell_signal']].tail(10))

# Assuming your DataFrame is named 'data'
print(data.columns)

# Replace 'your_actual_close_column_name' with the correct column name for closing prices
close_column = 'your_actual_close_column_name'  # Update this

# Calculate RSI and moving average
data['rsi'] = calculate_rsi(data)  # Ensure this function is defined
data['moving_average'] = data[close_column].rolling(window=20).mean()

# Generate buy and sell signals
data['buy_signal'] = (data['rsi'] < 30) & (data[close_column] > data['moving_average'])
data['sell_signal'] = (data['rsi'] > 70) & (data[close_column] < data['moving_average'])

# Display the DataFrame to verify the new columns
print(data[[close_column, 'rsi', 'moving_average', 'buy_signal', 'sell_signal']].tail(10))

# Assuming your DataFrame is named 'data'
print(data.columns)

# Assuming you found the correct name is 'close'
close_column = 'close'  # Update this with the correct column name

# Calculate RSI and moving average
data['rsi'] = calculate_rsi(data[close_column])  # Ensure this function is defined
data['moving_average'] = data[close_column].rolling(window=20).mean()

# Generate buy and sell signals
data['buy_signal'] = (data['rsi'] < 30) & (data[close_column] > data['moving_average'])
data['sell_signal'] = (data['rsi'] > 70) & (data[close_column] < data['moving_average'])

# Display the DataFrame to verify the new columns
print(data[[close_column, 'rsi', 'moving_average', 'buy_signal', 'sell_signal']].tail(10))

# Display the columns and the first few rows of the DataFrame
print(data.columns)  # Print the column names
print(data.head())   # Print the first few rows of the DataFrame

# Example if the column is named 'Close'
close_column = 'Close'  # Use the correct name based on your DataFrame

# Calculate RSI and moving average
data['rsi'] = calculate_rsi(data[close_column])  # Ensure this function is defined
data['moving_average'] = data[close_column].rolling(window=20).mean()

# Generate buy and sell signals
data['buy_signal'] = (data['rsi'] < 30) & (data[close_column] > data['moving_average'])
data['sell_signal'] = (data['rsi'] > 70) & (data[close_column] < data['moving_average'])

# Display the DataFrame to verify the new columns
print(data[[close_column, 'rsi', 'moving_average', 'buy_signal', 'sell_signal']].tail(10))

import pandas as pd
from alpha_vantage.timeseries import TimeSeries

api_key = 'yLZzzY_8ZZ6FElsmmRjSHYvuUMSmxnFB'
ts = TimeSeries(key=api_key, output_format='pandas')

tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'FB', 'NFLX', 'NVDA', 'PYPL', 'ADBE', 'INTC', 'CSCO', 'CMCSA', 'VZ', 'T', 'PFE', 'NKE', 'PEP', 'KO', 'WMT', 'COST', 'DIS', 'MDLZ', 'AVGO']  # Add your 25 tickers here

all_data = pd.DataFrame()

for ticker in tickers:
    try:
        data, _ = ts.get_daily(symbol=ticker, outputsize='full')
        data['Ticker'] = ticker  # Add a column for the ticker
        all_data = pd.concat([all_data, data])  # Concatenate data into one DataFrame
    except Exception as e:
        print(f"Error fetching data for {ticker}: {e}")

# Reset index for better readability
all_data.reset_index(inplace=True)

all_data.to_csv("historical_data_alpha_vantage.csv", index=False)

print(all_data.head())

import pandas as pd

all_data = pd.read_csv("historical_data_alpha_vantage.csv")
print(all_data.head())  # Check the first few rows
print(all_data.columns)  # Check the column names

all_data.dropna(inplace=True)  # Remove rows with missing values
all_data['date'] = pd.to_datetime(all_data['date'])  # Convert to datetime

import pandas as pd

# Load your data
all_data = pd.read_csv("historical_data_alpha_vantage.csv")

# Check the columns of the DataFrame
print("Columns in the DataFrame:", all_data.columns.tolist())

# Assuming the date column is named 'Date'
all_data['Date'] = pd.to_datetime(all_data['Date'])  # Convert to datetime
all_data.set_index('Date', inplace=True)  # Set the date as the index

print(new_data.columns)

# Check the column names
print(new_data.columns)

# Assuming the date column is identified as 'YourDateColumnName'
new_data['YourDateColumnName'] = pd.to_datetime(new_data['YourDateColumnName'])

new_data.reset_index(inplace=True)  # This will make the index a column
print(new_data.head())  # Check the DataFrame again

def calculate_rsi(data, window=14):
    delta = data['Close'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

new_data['RSI'] = calculate_rsi(new_data)

new_data['SMA_short'] = new_data['Close'].rolling(window=20).mean()
new_data['SMA_long'] = new_data['Close'].rolling(window=50).mean()

print(new_data.head())

def generate_signals(data):
    data['Signal'] = 0  # Default to no action
    data['Signal'][((data['RSI'] < 30) & (data['SMA_short'] > data['SMA_long']))] = 1  # Buy signal
    data['Signal'][((data['RSI'] > 70) & (data['SMA_short'] < data['SMA_long']))] = -1  # Sell signal
    return data

new_data = generate_signals(new_data)

print(new_data[['Date', 'Close', 'RSI', 'SMA_short', 'SMA_long', 'Signal']].head(20))

def backtest_strategy(data):
    initial_balance = 1000  # Starting balance
    balance = initial_balance
    position = 0  # Current position in shares
    buy_price = 0

    for index, row in data.iterrows():
        if row['Signal'] == 1 and position == 0:  # Buy
            position = balance / row['Close']  # Buy as many shares as possible
            buy_price = row['Close']
            balance = 0  # Spend all cash

        elif row['Signal'] == -1 and position > 0:  # Sell
            balance = position * row['Close']  # Sell all shares
            position = 0  # Clear position

    # Calculate final balance
    if position > 0:  # If still holding shares at the end
        balance = position * data['Close'].iloc[-1]

    return balance

final_balance = backtest_strategy(new_data)
print(f"Final Balance: ${final_balance:.2f}")

return_percentage = ((final_balance - initial_balance) / initial_balance) * 100
print(f"Percentage Return: {return_percentage:.2f}%")

import matplotlib.pyplot as plt

plt.figure(figsize=(14, 7))
plt.plot(new_data['Close'], label='Close Price', alpha=0.5)
plt.plot(new_data['SMA_short'], label='Short SMA', alpha=0.75)
plt.plot(new_data['SMA_long'], label='Long SMA', alpha=0.75)

# Plot buy signals
buy_signals = new_data[new_data['Signal'] == 1]
plt.scatter(buy_signals.index, buy_signals['Close'], marker='^', color='g', label='Buy Signal', s=100)

# Plot sell signals
sell_signals = new_data[new_data['Signal'] == -1]
plt.scatter(sell_signals.index, sell_signals['Close'], marker='v', color='r', label='Sell Signal', s=100)

plt.title('Trading Strategy Performance')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

initial_balance = 1000  # Your starting balance
final_balance = 1042.36  # Replace this with the calculated final balance
return_percentage = ((final_balance - initial_balance) / initial_balance) * 100
print(f"Percentage Return: {return_percentage:.2f}%")

import matplotlib.pyplot as plt

plt.figure(figsize=(14, 7))
plt.plot(new_data['Close'], label='Close Price', alpha=0.5)
plt.plot(new_data['SMA_short'], label='Short SMA', alpha=0.75)
plt.plot(new_data['SMA_long'], label='Long SMA', alpha=0.75)

# Plot buy signals
buy_signals = new_data[new_data['Signal'] == 1]
plt.scatter(buy_signals.index, buy_signals['Close'], marker='^', color='g', label='Buy Signal', s=100)

# Plot sell signals
sell_signals = new_data[new_data['Signal'] == -1]
plt.scatter(sell_signals.index, sell_signals['Close'], marker='v', color='r', label='Sell Signal', s=100)

plt.title('Trading Strategy Performance')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

results = []
for rsi_period in [7, 14, 21]:  # Different RSI periods
    for sma_short_period in [5, 10, 20]:  # Short SMA periods
        for sma_long_period in [20, 50, 100]:  # Long SMA periods
            # Run your backtest function here with these parameters
            # Assume backtest_function is defined to take these parameters
            final_balance = backtest_function(rsi_period, sma_short_period, sma_long_period)
            results.append((rsi_period, sma_short_period, sma_long_period, final_balance))

# Find the best combination
best_result = max(results, key=lambda x: x[3])
print(f"Best Parameters: RSI: {best_result[0]}, Short SMA: {best_result[1]}, Long SMA: {best_result[2]}, Final Balance: {best_result[3]}")

def backtest_function(rsi_period, sma_short_period, sma_long_period):
    # Your trading logic goes here
    # This should include loading the data, calculating indicators,
    # executing trades based on the strategy, and calculating the final balance.

    # For example:
    # - Load historical data
    # - Calculate RSI
    # - Calculate SMA
    # - Create buy/sell signals
    # - Execute trades
    # - Calculate final balance

    # Sample final balance calculation (you should replace this with your logic)
    initial_balance = 1000  # Starting balance
    final_balance = initial_balance * (1 + (some_return_based_on_trades))  # Placeholder for your actual return logic

    return final_balance

results = []
for rsi_period in [7, 14, 21]:  # Different RSI periods
    for sma_short_period in [5, 10, 20]:  # Short SMA periods
        for sma_long_period in [20, 50, 100]:  # Long SMA periods
            final_balance = backtest_function(rsi_period, sma_short_period, sma_long_period)
            results.append((rsi_period, sma_short_period, sma_long_period, final_balance))

# Find the best combination
best_result = max(results, key=lambda x: x[3])
print(f"Best Parameters: RSI: {best_result[0]}, Short SMA: {best_result[1]}, Long SMA: {best_result[2]}, Final Balance: {best_result[3]}")

def backtest_function(rsi_period, sma_short_period, sma_long_period):
    # Load historical data (assuming it's in a DataFrame called 'data')
    # For example, data = pd.read_csv('your_data_file.csv')

    # Calculate RSI
    data['RSI'] = talib.RSI(data['Close'], timeperiod=rsi_period)

    # Calculate Short and Long SMAs
    data['SMA_Short'] = data['Close'].rolling(window=sma_short_period).mean()
    data['SMA_Long'] = data['Close'].rolling(window=sma_long_period).mean()

    # Initialize variables for trading
    initial_balance = 1000
    balance = initial_balance
    shares = 0

    # Iterate through the DataFrame to generate buy/sell signals
    for i in range(len(data)):
        if data['RSI'].iloc[i] < 30 and data['Close'].iloc[i] > data['SMA_Short'].iloc[i]:
            # Buy signal
            shares_to_buy = balance // data['Close'].iloc[i]
            shares += shares_to_buy
            balance -= shares_to_buy * data['Close'].iloc[i]

        elif data['RSI'].iloc[i] > 70 and data['Close'].iloc[i] < data['SMA_Long'].iloc[i]:
            # Sell signal
            balance += shares * data['Close'].iloc[i]
            shares = 0

    # Calculate final balance including any remaining shares
    final_balance = balance + (shares * data['Close'].iloc[-1])  # Sell remaining shares at last close price

    return final_balance

results = []
for rsi_period in [7, 14, 21]:  # Different RSI periods
    for sma_short_period in [5, 10, 20]:  # Short SMA periods
        for sma_long_period in [20, 50, 100]:  # Long SMA periods
            final_balance = backtest_function(rsi_period, sma_short_period, sma_long_period)
            results.append((rsi_period, sma_short_period, sma_long_period, final_balance))

# Find the best combination
best_result = max(results, key=lambda x: x[3])
print(f"Best Parameters: RSI: {best_result[0]}, Short SMA: {best_result[1]}, Long SMA: {best_result[2]}, Final Balance: {best_result[3]}")

!pip install TA-Lib

import talib

!apt-get install -y build-essential

!pip install TA-Lib

import talib

!pip install pandas_ta

import pandas_ta as ta

# Calculate RSI using pandas_ta
data['RSI'] = ta.rsi(data['Close'], length=rsi_period)

# Calculate SMAs
data['SMA_Short'] = data['Close'].ta.sma(length=sma_short_period)
data['SMA_Long'] = data['Close'].ta.sma(length=sma_long_period)

print(data.columns)

print(data.head())

data['RSI'] = ta.rsi(data['Close'], length=rsi_period)

print(data.columns)

print(data.head())

data['RSI'] = ta.rsi(data['close'], length=rsi_period)

print(data.columns)

# If the column is named 'close', for example
data.rename(columns={'close': 'Close'}, inplace=True)  # Or use the actual name found from the print statement

print(data['Close'].isnull().sum())

print(data.columns)

print(data.head())

print(data.isnull().sum())

# If the column is 'close', adjust your calculations accordingly
data['RSI'] = talib.RSI(data['close'], timeperiod=rsi_period)

# Install the TA-Lib library (only needed in Google Colab)
!pip install TA-Lib

# Import necessary libraries
import pandas as pd
import talib

# Load your data
data = pd.read_csv('your_data_file.csv')  # Adjust the path to your data file

# Print columns to verify
print(data.columns)

# Assuming 'Close' is the correct column name
rsi_period = 14  # Example period
data['RSI'] = talib.RSI(data['Close'], timeperiod=rsi_period)

# Print the DataFrame to verify RSI calculation
print(data.head())

import pandas as pd

def calculate_rsi(data, period=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Assuming 'data' is your DataFrame containing the stock data
data['RSI'] = calculate_rsi(data)

# Now, you can proceed with your other calculations and strategy implementation

import pandas as pd

# Assuming 'data' is your DataFrame
print("DataFrame Columns:", data.columns)

def calculate_rsi(data, period=14):
    delta = data['close'].diff()  # Adjust based on the actual column name
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Add RSI to the DataFrame
data['RSI'] = calculate_rsi(data)

print(data.columns)
print(data.head())

def calculate_rsi(data, period=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

data['RSI'] = calculate_rsi(data)

import pandas as pd

def calculate_indicators(data, rsi_period, sma_short_period, sma_long_period):
    # Calculate the price changes
    delta = data['Close'].diff()

    # Calculate gains and losses
    gain = (delta.where(delta > 0, 0)).rolling(window=rsi_period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=rsi_period).mean()

    # Calculate the RSI
    rs = gain / loss
    data['RSI'] = 100 - (100 / (1 + rs))

    # Calculate Short and Long SMAs
    data['SMA_short'] = data['Close'].rolling(window=sma_short_period).mean()
    data['SMA_long'] = data['Close'].rolling(window=sma_long_period).mean()

    return data

# Example usage
# Assuming 'data' is your DataFrame containing stock prices with a 'Close' column
data = calculate_indicators(data, rsi_period=14, sma_short_period=5, sma_long_period=20)

print(data.tail())  # To check the last few rows including the new indicators

import pandas as pd
from datetime import datetime, time

# Define trading hours
def is_market_open():
    now = datetime.now()
    start = time(9, 30)  # 9:30 AM
    end = time(16, 0)    # 4:00 PM
    return start <= now.time() <= end

# Trading logic
def trading_logic():
    if is_market_open():
        # Place your trading logic here
        print("Market is open. Executing trades...")
    else:
        print("Market is closed. No trading will occur.")

# Example of running the trading logic
trading_logic()

pip install twilio

from twilio.rest import Client

def send_sms_alert(message):
    # Your Twilio credentials
    account_sid = 'your_account_sid'
    auth_token = 'your_auth_token'
    client = Client(account_sid, auth_token)

    # Send the message
    client.messages.create(
        to="your_phone_number",
        from_="your_twilio_number",
        body=message
    )

import time

def hourly_alert():
    while market_is_open():
        # Assuming you have a function to get your latest trade info
        latest_trade_info = get_latest_trade_info()
        send_sms_alert(latest_trade_info)
        time.sleep(3600)  # Wait for 1 hour

from twilio.rest import Client

# Twilio credentials
account_sid = 'ACa5985a497c5e83be2657929f9fb6028b'
auth_token = 'ba9698ae5e2533484e47047a51cf4fb6'
twilio_phone_number = 'YOUR_TWILIO_PHONE_NUMBER'  # Replace with your Twilio phone number
my_phone_number = '16314877979'  # Replace with your phone number

# Initialize Twilio client
client = Client(account_sid, auth_token)

def send_alert(message):
    message = client.messages.create(
        body=message,
        from_=twilio_phone_number,
        to=my_phone_number
    )
    print(f"Alert sent: {message.sid}")

import time

while True:
    # Check if the market is open before sending the alert
    if is_market_open():  # This is a placeholder for your market check function
        alert_message = "Your alert message goes here."
        send_alert(alert_message)

    # Sleep for an hour (3600 seconds)
    time.sleep(3600)

from datetime import datetime, time

def is_market_open():
    now = datetime.now()
    start = time(9, 30)  # 9:30 AM
    end = time(16, 0)    # 4:00 PM
    return start <= now.time() <= end

import robin_stocks.robinhood as r
import pandas as pd
import time

# Function to log in to Robinhood
def login_to_robinhood(username, password):
    try:
        r.login(username=username, password=password)
        print("Logged in to Robinhood successfully!")
    except Exception as e:
        print(f"Failed to log in: {e}")

# Login (replace with your credentials)
login_to_robinhood('rmah5078@my.msmc.edu', 'Lucky1313!')

# Function to execute a buy order
def execute_buy(symbol, quantity):
    try:
        buy_order = r.orders.order_buy_market(symbol, quantity)
        print(f"Buy order placed for {symbol}: {buy_order}")
    except Exception as e:
        print(f"Error placing buy order for {symbol}: {e}")

# Function to execute a sell order
def execute_sell(symbol, quantity):
    try:
        sell_order = r.orders.order_sell_market(symbol, quantity)
        print(f"Sell order placed for {symbol}: {sell_order}")
    except Exception as e:
        print(f"Error placing sell order for {symbol}: {e}")

# Function to check the buy/sell signals and execute trades
def execute_trades(data):
    for index, row in data.iterrows():
        symbol = row['symbol']
        quantity = 1  # You can adjust the quantity based on your strategy

        if row['buy_signal']:
            print(f"Buy signal detected for {symbol}")
            execute_buy(symbol, quantity)

        elif row['sell_signal']:
            print(f"Sell signal detected for {symbol}")
            execute_sell(symbol, quantity)

# Example DataFrame structure with 'symbol', 'buy_signal', and 'sell_signal'
data = pd.DataFrame({
    'symbol': ['AAPL', 'GOOGL', 'TSLA'],
    'buy_signal': [True, False, True],
    'sell_signal': [False, True, False]
})

# Execute trades based on signals
execute_trades(data)

# Logout after completing trades
r.logout()

import robin_stocks.robinhood as r
import pandas as pd
import time
import logging

# Setup logging
logging.basicConfig(filename='day_trader_ai_errors.log', level=logging.ERROR)

# Function to log in to Robinhood
def login_to_robinhood(username, password):
    try:
        r.login(username=username, password=password)
        print("Logged in to Robinhood successfully!")
    except Exception as e:
        logging.error(f"Failed to log in: {e}")
        print(f"Login failed. Check the error log.")

# Retry logic for executing trades
def retry_on_failure(func, symbol, quantity, max_retries=3, delay=5):
    for i in range(max_retries):
        try:
            func(symbol, quantity)
            return  # Exit once successful
        except Exception as e:
            logging.error(f"Error executing {func.__name__} for {symbol}: {e}")
            print(f"Error executing {func.__name__} for {symbol}. Retrying {i + 1}/{max_retries}")
            time.sleep(delay)
    print(f"Max retries reached for {func.__name__} on {symbol}. Skipping.")

# Function to execute a buy order
def execute_buy(symbol, quantity):
    retry_on_failure(r.orders.order_buy_market, symbol, quantity)

# Function to execute a sell order
def execute_sell(symbol, quantity):
    retry_on_failure(r.orders.order_sell_market, symbol, quantity)

# Function to check the buy/sell signals and execute trades
def execute_trades(data):
    for index, row in data.iterrows():
        symbol = row['symbol']
        quantity = 1  # Adjust based on your strategy

        if row['buy_signal']:
            print(f"Buy signal detected for {symbol}")
            execute_buy(symbol, quantity)

        elif row['sell_signal']:
            print(f"Sell signal detected for {symbol}")
            execute_sell(symbol, quantity)

# Example DataFrame structure with 'symbol', 'buy_signal', and 'sell_signal'
data = pd.DataFrame({
    'symbol': ['AAPL', 'GOOGL', 'TSLA'],
    'buy_signal': [True, False, True],
    'sell_signal': [False, True, False]
})

# Login to Robinhood
login_to_robinhood('your_username', 'your_password')

# Execute trades based on signals
execute_trades(data)

# Logout after completing trades
r.logout()

import robin_stocks.robinhood as r
import pandas as pd
import logging
import time

# Setup logging
logging.basicConfig(filename='day_trader_ai_errors.log', level=logging.ERROR)

# Global variables to track daily budget, daily loss, and profit
starting_daily_budget = 200  # Initial daily budget
daily_budget = starting_daily_budget
total_daily_loss = 0
max_daily_loss = 50  # Maximum allowed loss for the day
profit_rollover = 0  # Profit from previous day
trade_amount = 5  # Initial trade amount

# Function to log in to Robinhood
def login_to_robinhood(username, password):
    try:
        r.login(username=username, password=password)
        print("Logged in to Robinhood successfully!")
    except Exception as e:
        logging.error(f"Failed to log in: {e}")
        print(f"Login failed. Check the error log.")

# Function to buy fractional shares
def execute_buy_fractional(symbol, amount):
    try:
        buy_order = r.orders.order_buy_fractional_by_price(symbol, amount)
        print(f"Fractional buy order placed for {symbol}: {buy_order}")
    except Exception as e:
        logging.error(f"Error placing fractional buy order for {symbol}: {e}")

# Function to sell fractional shares
def execute_sell_fractional(symbol, amount):
    try:
        sell_order = r.orders.order_sell_fractional_by_price(symbol, amount)
        print(f"Fractional sell order placed for {symbol}: {sell_order}")
    except Exception as e:
        logging.error(f"Error placing fractional sell order for {symbol}: {e}")

# Function to track daily spending
def track_spending(amount):
    global daily_budget
    daily_budget -= amount
    print(f"Remaining daily budget: ${daily_budget}")

# Function to check stop-loss and take-profit for individual trades
def check_risk_management(symbol, purchase_price, current_price):
    global total_daily_loss, trade_amount

    # Calculate the loss for the trade
    loss = purchase_price - current_price

    # Check stop-loss (max $50 loss per day)
    if total_daily_loss + loss >= max_daily_loss:
        print(f"Daily stop-loss triggered for {symbol}. Selling...")
        execute_sell_fractional(symbol, trade_amount)  # Sell the fractional shares
        total_daily_loss += loss
        return True  # Stop trading for the day

    return False

# Function to adjust the trade amount based on profits
def adjust_trade_amount(profit):
    global trade_amount, profit_rollover
    # Only increase trade amount if there are profits
    if profit > 0:
        profit_rollover += profit
        # Adjust the trade amount using profits only
        trade_amount = 5 + profit_rollover // 10  # Adjust the scaling as needed
        print(f"New trade amount based on profits: ${trade_amount}")

# Function to manage trades, daily budget, and profit rollover
def execute_trades_with_budget(data):
    global total_daily_loss, daily_budget, profit_rollover, trade_amount

    # Update daily budget with previous day's profit
    daily_budget += profit_rollover
    print(f"Today's starting budget: ${daily_budget}")

    for index, row in data.iterrows():
        symbol = row['symbol']
        current_price = float(r.stocks.get_latest_price(symbol)[0])  # Get the current price

        # Each trade starts at $5 or the current trade amount based on profit
        trade_amount_to_use = min(trade_amount, daily_budget)
        if daily_budget < trade_amount_to_use:
            print("Daily budget exhausted. No more trades for today.")
            break

        # Buy signal
        if row['buy_signal']:
            print(f"Buy signal detected for {symbol}")
            execute_buy_fractional(symbol, trade_amount_to_use)
            track_spending(trade_amount_to_use)

        # Sell signal or risk management (stop-loss)
        elif row['sell_signal'] or check_risk_management(symbol, trade_amount_to_use, current_price):
            print(f"Sell signal or stop-loss triggered for {symbol}")
            execute_sell_fractional(symbol, trade_amount_to_use)

        # Adjust the trade amount based on profit
        profit = current_price - trade_amount_to_use  # Calculate profit from the trade
        adjust_trade_amount(profit)

        # Stop trading if total daily loss exceeds $50
        if total_daily_loss >= max_daily_loss:
            print(f"Max daily loss of ${max_daily_loss} reached. Stopping further trades.")
            break

# Example DataFrame structure with 'symbol', 'buy_signal', and 'sell_signal'
data = pd.DataFrame({
    'symbol': ['AAPL', 'GOOGL', 'TSLA'],
    'buy_signal': [True, False, True],
    'sell_signal': [False, True, False]
})

# Login to Robinhood
login_to_robinhood('your_username', 'your_password')

# Execute trades with the budget and risk management
execute_trades_with_budget(data)

# Logout after completing trades
r.logout()

import robin_stocks.robinhood as r
import pandas as pd
import logging
import time
from datetime import datetime

# Setup logging
logging.basicConfig(filename='day_trader_ai_errors.log', level=logging.ERROR)

# Global variables to track daily budget, daily loss, and profit
starting_daily_budget = 200  # Initial daily budget
daily_budget = starting_daily_budget
total_daily_loss = 0
max_daily_loss = 50  # Maximum allowed daily loss
profit_rollover = 0  # Profit from previous day
trade_amount = 5  # Initial trade amount

# List of top 25 tickers
top_25_tickers = [
    'AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN', 'NVDA', 'META', 'NFLX', 'INTC', 'AMD',
    'BA', 'CAT', 'DIS', 'NKE', 'XOM', 'CVX', 'WMT', 'PG', 'V', 'MA', 'JPM', 'BAC',
    'PFE', 'MRK', 'T'
]

# Function to log in to Robinhood
def login_to_robinhood(username, password):
    try:
        r.login(username=username, password=password)
        print("Logged in to Robinhood successfully!")
    except Exception as e:
        logging.error(f"Failed to log in: {e}")
        print(f"Login failed. Check the error log.")

# Function to buy fractional shares
def execute_buy_fractional(symbol, amount):
    try:
        buy_order = r.orders.order_buy_fractional_by_price(symbol, amount)
        print(f"Fractional buy order placed for {symbol}: {buy_order}")
    except Exception as e:
        logging.error(f"Error placing fractional buy order for {symbol}: {e}")

# Function to sell fractional shares
def execute_sell_fractional(symbol, amount):
    try:
        sell_order = r.orders.order_sell_fractional_by_price(symbol, amount)
        print(f"Fractional sell order placed for {symbol}: {sell_order}")
    except Exception as e:
        logging.error(f"Error placing fractional sell order for {symbol}: {e}")

# Function to track daily spending
def track_spending(amount):
    global daily_budget
    daily_budget -= amount
    print(f"Remaining daily budget: ${daily_budget}")

# Function to track and enforce daily loss limit
def track_loss_and_stop_trading(loss):
    global total_daily_loss
    total_daily_loss += loss
    print(f"Total daily loss: ${total_daily_loss}")

    # Stop trading if total daily loss exceeds $50
    if total_daily_loss >= max_daily_loss:
        print(f"Max daily loss of ${max_daily_loss} reached. Stopping further trades.")
        return True
    return False

# Function to adjust the trade amount based on profits
def adjust_trade_amount(profit):
    global trade_amount, profit_rollover
    # Only increase trade amount if there are profits
    if profit > 0:
        profit_rollover += profit
        # Adjust the trade amount using profits only
        trade_amount = 5 + profit_rollover // 10  # Adjust the scaling as needed
        print(f"New trade amount based on profits: ${trade_amount}")

# Function to fetch stock data and generate signals (simplified)
def fetch_signals():
    data = []
    for symbol in top_25_tickers:
        current_price = float(r.stocks.get_latest_price(symbol)[0])  # Get the current price
        # Placeholder for signal generation logic (you would use your actual strategy here)
        buy_signal = current_price < 150  # Example condition for a buy signal
        sell_signal = current_price > 200  # Example condition for a sell signal
        data.append({'symbol': symbol, 'buy_signal': buy_signal, 'sell_signal': sell_signal})
    return pd.DataFrame(data)

# Function to manage trades, daily budget, and risk management
def execute_trades_with_budget(data):
    global total_daily_loss, daily_budget, profit_rollover, trade_amount

    # Update daily budget with previous day's profit
    daily_budget += profit_rollover
    print(f"Today's starting budget: ${daily_budget}")

    for index, row in data.iterrows():
        symbol = row['symbol']
        current_price = float(r.stocks.get_latest_price(symbol)[0])  # Get the current price

        # Each trade starts at $5 or the current trade amount based on profit
        trade_amount_to_use = min(trade_amount, daily_budget)
        if daily_budget < trade_amount_to_use:
            print("Daily budget exhausted. No more trades for today.")
            break

        # Buy signal
        if row['buy_signal']:
            print(f"Buy signal detected for {symbol}")
            execute_buy_fractional(symbol, trade_amount_to_use)
            track_spending(trade_amount_to_use)

        # Sell signal or stop-loss
        elif row['sell_signal']:
            print(f"Sell signal detected for {symbol}")
            execute_sell_fractional(symbol, trade_amount_to_use)

        # Calculate profit/loss from the trade
        profit = current_price - trade_amount_to_use  # Simplified profit calculation
        adjust_trade_amount(profit)

        # Track loss and stop trading if daily loss exceeds $50
        if track_loss_and_stop_trading(-profit):  # Convert profit to loss
            break

# Function to run minute-by-minute trading
def run_minute_by_minute_trading():
    while is_market_open():
        data = fetch_signals()
        execute_trades_with_budget(data)
        time.sleep(60)  # Wait for 1 minute before checking again

# Function to check if the market is open
def is_market_open():
    now = datetime.now()
    start = now.replace(hour=9, minute=30, second=0, microsecond=0)
    end = now.replace(hour=16, minute=0, second=0, microsecond=0)
    return start <= now <= end

# Login to Robinhood
login_to_robinhood('your_username', 'your_password')

# Start minute-by-minute trading
run_minute_by_minute_trading()

# Logout after completing trades
r.logout()

import robin_stocks.robinhood as r
import pandas as pd
import logging
import time
from datetime import datetime

# Setup logging
logging.basicConfig(filename='day_trader_ai_errors.log', level=logging.ERROR)

# Global variables to track daily budget, daily loss, and profit
starting_daily_budget = 200  # Initial daily budget
daily_budget = starting_daily_budget
total_daily_loss = 0
max_daily_loss = 50  # Maximum allowed daily loss
profit_rollover = 0  # Profit from previous day
trade_amount = 5  # Initial trade amount

# Function to log in to Robinhood
def login_to_robinhood(username, password):
    try:
        r.login(username=username, password=password)
        print("Logged in to Robinhood successfully!")
    except Exception as e:
        logging.error(f"Failed to log in: {e}")
        print(f"Login failed. Check the error log.")

# Function to buy fractional shares
def execute_buy_fractional(symbol, amount):
    try:
        buy_order = r.orders.order_buy_fractional_by_price(symbol, amount)
        print(f"Fractional buy order placed for {symbol}: {buy_order}")
    except Exception as e:
        logging.error(f"Error placing fractional buy order for {symbol}: {e}")

# Function to sell fractional shares
def execute_sell_fractional(symbol, amount):
    try:
        sell_order = r.orders.order_sell_fractional_by_price(symbol, amount)
        print(f"Fractional sell order placed for {symbol}: {sell_order}")
    except Exception as e:
        logging.error(f"Error placing fractional sell order for {symbol}: {e}")

# Function to track and enforce daily loss limit
def track_loss_and_stop_trading(loss):
    global total_daily_loss
    total_daily_loss += loss
    print(f"Total daily loss: ${total_daily_loss}")

    # Stop trading if total daily loss exceeds $50
    if total_daily_loss >= max_daily_loss:
        print(f"Max daily loss of ${max_daily_loss} reached. Stopping further trades.")
        return True  # Stop further trades
    return False  # Continue trading

# Function to manage trades, daily budget, and risk management
def execute_trades_with_budget(data):
    global total_daily_loss, daily_budget, profit_rollover, trade_amount

    # Update daily budget with previous day's profit
    daily_budget += profit_rollover
    print(f"Today's starting budget: ${daily_budget}")

    for index, row in data.iterrows():
        symbol = row['symbol']
        current_price = float(r.stocks.get_latest_price(symbol)[0])  # Get the current price

        # Each trade starts at $5 or the current trade amount based on profit
        trade_amount_to_use = min(trade_amount, daily_budget)
        if daily_budget < trade_amount_to_use:
            print("Daily budget exhausted. No more trades for today.")
            break

        # Check for daily loss limit before any trade
        if total_daily_loss >= max_daily_loss:
            print(f"Max daily loss of ${max_daily_loss} reached. No more trades allowed today.")
            break

        # Buy signal
        if row['buy_signal']:
            print(f"Buy signal detected for {symbol}")
            execute_buy_fractional(symbol, trade_amount_to_use)
            track_spending(trade_amount_to_use)

        # Sell signal or stop-loss
        elif row['sell_signal']:
            print(f"Sell signal detected for {symbol}")
            execute_sell_fractional(symbol, trade_amount_to_use)

        # Calculate profit/loss from the trade
        profit = current_price - trade_amount_to_use  # Simplified profit calculation
        loss = trade_amount_to_use - current_price  # Calculate potential loss
        adjust_trade_amount(profit)

        # Track loss and stop trading if daily loss exceeds $50
        if track_loss_and_stop_trading(loss):
            break

# Function to track spending
def track_spending(amount):
    global daily_budget
    daily_budget -= amount
    print(f"Remaining daily budget: ${daily_budget}")

# Example DataFrame structure with 'symbol', 'buy_signal', and 'sell_signal'
data = pd.DataFrame({
    'symbol': ['AAPL', 'GOOGL', 'MSFT', 'TSLA'],
    'buy_signal': [True, False, True, False],
    'sell_signal': [False, True, False, True]
})

# Login to Robinhood
login_to_robinhood('your_username', 'your_password')

# Execute trades with the budget and risk management
execute_trades_with_budget(data)

# Logout after completing trades
r.logout()

import robin_stocks.robinhood as r
import pandas as pd
import logging
import time
from datetime import datetime

# Setup logging
logging.basicConfig(filename='day_trader_ai_errors.log', level=logging.ERROR)

# Global variables to track daily budget, daily loss, and profit
starting_daily_budget = 200  # Initial daily budget
daily_budget = starting_daily_budget
total_daily_loss = 0
max_daily_loss = 50  # Maximum allowed daily loss
profit_rollover = 0  # Profit from previous day
trade_amount = 5  # Initial trade amount
min_trade_amount = 1  # Minimum trade amount for fractional shares

# Function to log in to Robinhood
def login_to_robinhood(username, password):
    try:
        r.login(username=username, password=password)
        print("Logged in to Robinhood successfully!")
    except Exception as e:
        logging.error(f"Failed to log in: {e}")
        print(f"Login failed. Check the error log.")

# Function to buy fractional shares
def execute_buy_fractional(symbol, amount):
    if amount < min_trade_amount:
        print(f"Trade amount {amount} is below the minimum allowed for {symbol}.")
        return
    try:
        buy_order = r.orders.order_buy_fractional_by_price(symbol, amount)
        print(f"Fractional buy order placed for {symbol}: {buy_order}")
    except Exception as e:
        logging.error(f"Error placing fractional buy order for {symbol}: {e}")

# Function to sell fractional shares
def execute_sell_fractional(symbol, amount):
    if amount < min_trade_amount:
        print(f"Trade amount {amount} is below the minimum allowed for {symbol}.")
        return
    try:
        sell_order = r.orders.order_sell_fractional_by_price(symbol, amount)
        print(f"Fractional sell order placed for {symbol}: {sell_order}")
    except Exception as e:
        logging.error(f"Error placing fractional sell order for {symbol}: {e}")

# Function to track and enforce daily loss limit
def track_loss_and_stop_trading(loss):
    global total_daily_loss
    total_daily_loss += loss
    print(f"Total daily loss: ${total_daily_loss}")

    # Stop trading if total daily loss exceeds $50
    if total_daily_loss >= max_daily_loss:
        print(f"Max daily loss of ${max_daily_loss} reached. Stopping further trades.")
        return True  # Stop further trades
    return False  # Continue trading

# Function to manage trades, daily budget, and risk management
def execute_trades_with_budget(data):
    global total_daily_loss, daily_budget, profit_rollover, trade_amount

    # Update daily budget with previous day's profit
    daily_budget += profit_rollover
    print(f"Today's starting budget: ${daily_budget}")

    for index, row in data.iterrows():
        symbol = row['symbol']
        current_price = float(r.stocks.get_latest_price(symbol)[0])  # Get the current price

        # Each trade starts at $5 or the current trade amount based on profit
        trade_amount_to_use = min(trade_amount, daily_budget)
        if daily_budget < trade_amount_to_use:
            print("Daily budget exhausted. No more trades for today.")
            break

        # Check for daily loss limit before any trade
        if total_daily_loss >= max_daily_loss:
            print(f"Max daily loss of ${max_daily_loss} reached. No more trades allowed today.")
            break

        # Buy signal
        if row['buy_signal']:
            print(f"Buy signal detected for {symbol}")
            execute_buy_fractional(symbol, trade_amount_to_use)
            track_spending(trade_amount_to_use)

        # Sell signal or stop-loss
        elif row['sell_signal']:
            print(f"Sell signal detected for {symbol}")
            execute_sell_fractional(symbol, trade_amount_to_use)

        # Calculate profit/loss from the trade
        profit = current_price - trade_amount_to_use  # Simplified profit calculation
        loss = trade_amount_to_use - current_price  # Calculate potential loss
        adjust_trade_amount(profit)

        # Track loss and stop trading if daily loss exceeds $50
        if track_loss_and_stop_trading(loss):
            break

# Function to track spending
def track_spending(amount):
    global daily_budget
    daily_budget -= amount
    print(f"Remaining daily budget: ${daily_budget}")

# Example DataFrame structure with 'symbol', 'buy_signal', and 'sell_signal'
data = pd.DataFrame({
    'symbol': ['AAPL', 'GOOGL', 'MSFT', 'TSLA'],
    'buy_signal': [True, False, True, False],
    'sell_signal': [False, True, False, True]
})

# Login to Robinhood
login_to_robinhood('your_username', 'your_password')

# Execute trades with the budget and risk management
execute_trades_with_budget(data)

# Logout after completing trades
r.logout()

import robin_stocks.robinhood as r
import pandas as pd
import logging
import time
from datetime import datetime

# Setup logging
logging.basicConfig(filename='day_trader_ai_errors.log', level=logging.ERROR)

# Global variables to track daily budget, daily loss, and profit
starting_daily_budget = 200  # Initial daily budget
daily_budget = starting_daily_budget
total_daily_loss = 0
max_daily_loss = 50  # Maximum allowed daily loss
profit_rollover = 0  # Profit from previous day
trade_amount = 5  # Initial trade amount
min_trade_amount = 1  # Minimum trade amount for fractional shares

# Function to log in to Robinhood
def login_to_robinhood(username, password):
    try:
        r.login(username=username, password=password)
        print("Logged in to Robinhood successfully!")
    except Exception as e:
        logging.error(f"Failed to log in: {e}")
        print(f"Login failed. Check the error log.")

# Function to check if there are enough shares to sell
def check_holdings(symbol, quantity):
    position_data = r.account.build_holdings()
    if symbol in position_data:
        available_quantity = float(position_data[symbol]['quantity'])
        return available_quantity >= quantity
    return False

# Function to buy fractional shares
def execute_buy_fractional(symbol, amount):
    if amount < min_trade_amount:
        print(f"Trade amount {amount} is below the minimum allowed for {symbol}.")
        return
    try:
        buy_order = r.orders.order_buy_fractional_by_price(symbol, amount)
        print(f"Fractional buy order placed for {symbol}: {buy_order}")
    except Exception as e:
        logging.error(f"Error placing fractional buy order for {symbol}: {e}")

# Function to sell fractional shares
def execute_sell_fractional(symbol, amount):
    if amount < min_trade_amount:
        print(f"Trade amount {amount} is below the minimum allowed for {symbol}.")
        return
    if not check_holdings(symbol, amount):
        print(f"Not enough shares of {symbol} to sell.")
        return
    try:
        sell_order = r.orders.order_sell_fractional_by_price(symbol, amount)
        print(f"Fractional sell order placed for {symbol}: {sell_order}")
    except Exception as e:
        logging.error(f"Error placing fractional sell order for {symbol}: {e}")

# Function to track and enforce daily loss limit
def track_loss_and_stop_trading(loss):
    global total_daily_loss
    total_daily_loss += loss
    print(f"Total daily loss: ${total_daily_loss}")

    # Stop trading if total daily loss exceeds $50
    if total_daily_loss >= max_daily_loss:
        print(f"Max daily loss of ${max_daily_loss} reached. Stopping further trades.")
        return True  # Stop further trades
    return False  # Continue trading

# Function to manage trades, daily budget, and risk management
def execute_trades_with_budget(data):
    global total_daily_loss, daily_budget, profit_rollover, trade_amount

    # Update daily budget with previous day's profit
    daily_budget += profit_rollover
    print(f"Today's starting budget: ${daily_budget}")

    for index, row in data.iterrows():
        symbol = row['symbol']
        current_price = float(r.stocks.get_latest_price(symbol)[0])  # Get the current price

        # Each trade starts at $5 or the current trade amount based on profit
        trade_amount_to_use = min(trade_amount, daily_budget)
        if daily_budget < trade_amount_to_use:
            print("Daily budget exhausted. No more trades for today.")
            break

        # Check for daily loss limit before any trade
        if total_daily_loss >= max_daily_loss:
            print(f"Max daily loss of ${max_daily_loss} reached. No more trades allowed today.")
            break

        # Buy signal
        if row['buy_signal']:
            print(f"Buy signal detected for {symbol}")
            execute_buy_fractional(symbol, trade_amount_to_use)
            track_spending(trade_amount_to_use)

        # Sell signal or stop-loss
        elif row['sell_signal']:
            print(f"Sell signal detected for {symbol}")
            execute_sell_fractional(symbol, trade_amount_to_use)

        # Calculate profit/loss from the trade
        profit = current_price - trade_amount_to_use  # Simplified profit calculation
        loss = trade_amount_to_use - current_price  # Calculate potential loss
        adjust_trade_amount(profit)

        # Track loss and stop trading if daily loss exceeds $50
        if track_loss_and_stop_trading(loss):
            break

# Function to track spending
def track_spending(amount):
    global daily_budget
    daily_budget -= amount
    print(f"Remaining daily budget: ${daily_budget}")

# Example DataFrame structure with 'symbol', 'buy_signal', and 'sell_signal'
data = pd.DataFrame({
    'symbol': ['AAPL', 'GOOGL', 'MSFT', 'TSLA'],
    'buy_signal': [True, False, True, False],
    'sell_signal': [False, True, False, True]
})

# Login to Robinhood
login_to_robinhood('your_username', 'your_password')

# Execute trades with the budget and risk management
execute_trades_with_budget(data)

# Logout after completing trades
r.logout()

import robin_stocks.robinhood as r
import pandas as pd
import logging
import time
from datetime import datetime

# Setup logging
logging.basicConfig(filename='day_trader_ai_errors.log', level=logging.ERROR)

# Global variables to track daily budget, daily loss, and profit
starting_daily_budget = 200  # Initial daily budget
daily_budget = starting_daily_budget
total_daily_loss = 0
max_daily_loss = 50  # Maximum allowed daily loss
profit_rollover = 0  # Profit from previous day
trade_amount = 5  # Initial trade amount
min_trade_amount = 1  # Minimum trade amount for fractional shares

# Function to log in to Robinhood
def login_to_robinhood(username, password):
    try:
        r.login(username=username, password=password)
        print("Logged in to Robinhood successfully!")
    except Exception as e:
        logging.error(f"Failed to log in: {e}")
        print(f"Login failed. Check the error log.")

# Function to check if there are enough shares to sell
def check_holdings(symbol, quantity):
    position_data = r.account.build_holdings()
    if symbol in position_data:
        available_quantity = float(position_data[symbol]['quantity'])
        return available_quantity >= quantity
    return False

# Function to buy fractional shares
def execute_buy_fractional(symbol, amount):
    # Skip if the trade amount is too low
    if amount < min_trade_amount:
        print(f"Trade amount {amount} is below the minimum allowed for {symbol}.")
        return
    # Skip if the available budget is less than the trade amount
    if daily_budget < amount:
        print(f"Not enough budget to buy {symbol}. Skipping this trade.")
        return
    try:
        buy_order = r.orders.order_buy_fractional_by_price(symbol, amount)
        print(f"Fractional buy order placed for {symbol}: {buy_order}")
    except Exception as e:
        logging.error(f"Error placing fractional buy order for {symbol}: {e}")

# Function to sell fractional shares
def execute_sell_fractional(symbol, amount):
    # Skip if the trade amount is too low
    if amount < min_trade_amount:
        print(f"Trade amount {amount} is below the minimum allowed for {symbol}.")
        return
    # Skip if there are not enough shares to sell
    if not check_holdings(symbol, amount):
        print(f"Not enough shares of {symbol} to sell. Skipping this trade.")
        return
    try:
        sell_order = r.orders.order_sell_fractional_by_price(symbol, amount)
        print(f"Fractional sell order placed for {symbol}: {sell_order}")
    except Exception as e:
        logging.error(f"Error placing fractional sell order for {symbol}: {e}")

# Function to track and enforce daily loss limit
def track_loss_and_stop_trading(loss):
    global total_daily_loss
    total_daily_loss += loss
    print(f"Total daily loss: ${total_daily_loss}")

    # Stop trading if total daily loss exceeds $50
    if total_daily_loss >= max_daily_loss:
        print(f"Max daily loss of ${max_daily_loss} reached. Stopping further trades.")
        return True  # Stop further trades
    return False  # Continue trading

# Function to manage trades, daily budget, and risk management
def execute_trades_with_budget(data):
    global total_daily_loss, daily_budget, profit_rollover, trade_amount

    # Update daily budget with previous day's profit
    daily_budget += profit_rollover
    print(f"Today's starting budget: ${daily_budget}")

    for index, row in data.iterrows():
        symbol = row['symbol']
        current_price = float(r.st

import alpha_vantage.timeseries as av
import pandas as pd
import time

# Alpha Vantage API key
api_key = 'your_alpha_vantage_api_key'

# Initialize Alpha Vantage TimeSeries class
ts = av.TimeSeries(key=api_key, output_format='pandas')

# List of top 25 tickers
top_25_tickers = [
    'AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN', 'NVDA', 'META', 'NFLX', 'INTC', 'AMD',
    'BA', 'CAT', 'DIS', 'NKE', 'XOM', 'CVX', 'WMT', 'PG', 'V', 'MA', 'JPM', 'BAC',
    'PFE', 'MRK', 'T'
]

# Function to retrieve historical data for each stock
def get_historical_data(symbol):
    try:
        data, meta_data = ts.get_daily(symbol=symbol, outputsize='full')
        return data
    except Exception as e:
        print(f"Error retrieving data for {symbol}: {e}")
        return None

# Download historical data for each stock
historical_data = {}
for ticker in top_25_tickers:
    data = get_historical_data(ticker)
    if data is not None:
        historical_data[ticker] = data
    time.sleep(12)  # Sleep to avoid API rate limits

# Merge historical data into one DataFrame (optional)
# Example: You can select specific dates or fields if needed.
combined_data = pd.concat(historical_data, axis=1)
print(combined_data.head())

import alpha_vantage.timeseries as av
import pandas as pd
import time

# Your Alpha Vantage API key
api_key = 'yLZzzY_8ZZ6FElsmmRjSHYvuUMSmxnFB'

# Initialize Alpha Vantage TimeSeries class
ts = av.TimeSeries(key=api_key, output_format='pandas')

# List of top 25 tickers
top_25_tickers = [
    'AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN', 'NVDA', 'META', 'NFLX', 'INTC', 'AMD',
    'BA', 'CAT', 'DIS', 'NKE', 'XOM', 'CVX', 'WMT', 'PG', 'V', 'MA', 'JPM', 'BAC',
    'PFE', 'MRK', 'T'
]

# Function to retrieve historical data for each stock
def get_historical_data(symbol):
    try:
        data, meta_data = ts.get_daily(symbol=symbol, outputsize='full')
        return data
    except Exception as e:
        print(f"Error retrieving data for {symbol}: {e}")
        return None

# Download historical data for each stock
historical_data = {}
for ticker in top_25_tickers:
    data = get_historical_data(ticker)
    if data is not None:
        historical_data[ticker] = data
    time.sleep(12)  # Sleep to avoid API rate limits

# Combine historical data into one DataFrame (optional)
combined_data = pd.concat(historical_data, axis=1)
print(combined_data.head())

# Simulate trades based on historical data
def backtest_trading_strategy():
    total_profit = 0
    for ticker, data in historical_data.items():
        for date, row in data.iterrows():
            # Example buy/sell signals based on closing price
            closing_price = row['4. close']
            buy_signal = closing_price < 150  # Example buy condition
            sell_signal = closing_price > 200  # Example sell condition

            if buy_signal:
                print(f"Buy signal for {ticker} on {date}: {closing_price}")
                # Simulate buy logic here

            if sell_signal:
                print(f"Sell signal for {ticker} on {date}: {closing_price}")
                # Simulate sell logic here

            # Track profit/loss
            profit = 0  # Example calculation of profit
            total_profit += profit

    print(f"Total profit from backtesting: ${total_profit}")

# Run the backtest
backtest_trading_strategy()

!pip install alpha_vantage

import alpha_vantage.timeseries as av
import pandas as pd
import time

# Your Alpha Vantage API key
api_key = 'yLZzzY_8ZZ6FElsmmRjSHYvuUMSmxnFB'

# Initialize Alpha Vantage TimeSeries class
ts = av.TimeSeries(key=api_key, output_format='pandas')

# List of top 25 tickers
top_25_tickers = [
    'AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN', 'NVDA', 'META', 'NFLX', 'INTC', 'AMD',
    'BA', 'CAT', 'DIS', 'NKE', 'XOM', 'CVX', 'WMT', 'PG', 'V', 'MA', 'JPM', 'BAC',
    'PFE', 'MRK', 'T'
]

# Function to retrieve historical data for each stock
def get_historical_data(symbol):
    try:
        print(f"Retrieving data for {symbol}...")  # Debugging info
        data, meta_data = ts.get_daily(symbol=symbol, outputsize='full')
        return data
    except Exception as e:
        print(f"Error retrieving data for {symbol}: {e}")
        return None

# Download historical data for each stock
historical_data = {}
for ticker in top_25_tickers:
    data = get_historical_data(ticker)
    if data is not None:
        historical_data[ticker] = data
    time.sleep(12)  # Sleep to avoid API rate limits

# Combine historical data into one DataFrame (optional)
combined_data = pd.concat(historical_data, axis=1)
print(combined_data.head())

# Subset of 5 tickers for today's testing
subset_tickers = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN']

# Function to retrieve historical data for each stock
def get_historical_data(symbol):
    try:
        print(f"Retrieving data for {symbol}...")  # Debugging info
        data, meta_data = ts.get_daily(symbol=symbol, outputsize='full')
        return data
    except Exception as e:
        print(f"Error retrieving data for {symbol}: {e}")
        return None

# Download historical data for the subset
historical_data = {}
for ticker in subset_tickers:
    data = get_historical_data(ticker)
    if data is not None:
        historical_data[ticker] = data
    time.sleep(12)  # Sleep to avoid API rate limits

# Combine historical data into one DataFrame (optional)
combined_data = pd.concat(historical_data, axis=1)
print(combined_data.head())

import yfinance as yf
import pandas as pd
import time

# List of top 25 tickers
top_25_tickers = [
    'AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN', 'NVDA', 'META', 'NFLX', 'INTC', 'AMD',
    'BA', 'CAT', 'DIS', 'NKE', 'XOM', 'CVX', 'WMT', 'PG', 'V', 'MA', 'JPM', 'BAC',
    'PFE', 'MRK', 'T'
]

# Function to retrieve historical data using Yahoo Finance
def get_historical_data_yf(symbol):
    try:
        print(f"Retrieving data for {symbol}...")  # Debugging info
        stock = yf.Ticker(symbol)
        data = stock.history(period="1y")  # Adjust the period as needed
        return data
    except Exception as e:
        print(f"Error retrieving data for {symbol}: {e}")
        return None

# Download historical data for each stock
historical_data = {}
for ticker in top_25_tickers:
    data = get_historical_data_yf(ticker)
    if data is not None:
        historical_data[ticker] = data
    time.sleep(1)  # Sleep to avoid being throttled

# Combine historical data into one DataFrame (optional)
combined_data = pd.concat(historical_data, axis=1)
print(combined_data.head())

# Simulate trades based on historical data
def backtest_trading_strategy():
    total_profit = 0
    for ticker, data in historical_data.items():
        for date, row in data.iterrows():
            # Example buy/sell signals based on closing price
            closing_price = row['Close']
            buy_signal = closing_price < 150  # Example buy condition
            sell_signal = closing_price > 200  # Example sell condition

            if buy_signal:
                print(f"Buy signal for {ticker} on {date}: {closing_price}")
                # Simulate buy logic here

            if sell_signal:
                print(f"Sell signal for {ticker} on {date}: {closing_price}")
                # Simulate sell logic here

            # Track profit/loss
            profit = 0  # Example calculation of profit
            total_profit += profit

    print(f"Total profit from backtesting: ${total_profit}")

# Run the backtest
backtest_trading_strategy()

# Initialize variables to track cash and holdings
initial_cash = 10000  # Starting with $10,000
cash = initial_cash
holdings = {}  # Dictionary to store the amount of each stock held
transaction_log = []  # Log of all trades

# Simulate trades based on historical data
def backtest_trading_strategy():
    global cash
    total_profit = 0

    for ticker, data in historical_data.items():
        for date, row in data.iterrows():
            closing_price = row['Close']
            buy_signal = closing_price < 150  # Example buy condition
            sell_signal = closing_price > 200  # Example sell condition

            # If there's a buy signal
            if buy_signal and cash >= closing_price:
                # Buy one share (or more, you can customize this)
                num_shares = cash // closing_price
                cash -= num_shares * closing_price
                holdings[ticker] = holdings.get(ticker, 0) + num_shares
                print(f"Bought {num_shares} shares of {ticker} at {closing_price} on {date}")
                transaction_log.append((ticker, date, "buy", num_shares, closing_price))

            # If there's a sell signal and we hold the stock
            if sell_signal and holdings.get(ticker, 0) > 0:
                num_shares = holdings[ticker]
                cash += num_shares * closing_price
                print(f"Sold {num_shares} shares of {ticker} at {closing_price} on {date}")
                total_profit += (num_shares * closing_price) - (num_shares * row['Open'])  # Calculate profit
                holdings[ticker] = 0  # Set holdings to zero after selling
                transaction_log.append((ticker, date, "sell", num_shares, closing_price))

    print(f"Total profit from backtesting: ${total_profit}")
    print(f"Final cash balance: ${cash}")
    print(f"Transaction Log: {transaction_log}")

# Run the backtest
backtest_trading_strategy()

# Initialize variables to track cash and holdings
initial_cash = 10000  # Starting with $10,000
cash = initial_cash
holdings = {}  # Dictionary to store the amount of each stock held
transaction_log = []  # Log of all trades

# Simulate trades based on historical data
def backtest_trading_strategy():
    global cash
    total_profit = 0

    for ticker, data in historical_data.items():
        for date, row in data.iterrows():
            closing_price = row['Close']
            buy_signal = closing_price < 150  # Example buy condition
            sell_signal = closing_price > 170  # Adjusted sell condition to be more reasonable

            # If there's a buy signal
            if buy_signal and cash >= closing_price:
                # Buy one share (or more, you can customize this)
                num_shares = cash // closing_price
                cash -= num_shares * closing_price
                holdings[ticker] = holdings.get(ticker, 0) + num_shares
                print(f"Bought {num_shares} shares of {ticker} at {closing_price} on {date}")
                transaction_log.append((ticker, date, "buy", num_shares, closing_price))

            # If there's a sell signal and we hold the stock
            if sell_signal and holdings.get(ticker, 0) > 0:
                num_shares = holdings[ticker]
                sell_price = num_shares * closing_price
                cost_price = num_shares * row['Open']  # Simplified purchase price
                cash += sell_price
                profit = sell_price - cost_price
                total_profit += profit
                print(f"Sold {num_shares} shares of {ticker} at {closing_price} on {date}")
                holdings[ticker] = 0  # Set holdings to zero after selling
                transaction_log.append((ticker, date, "sell", num_shares, closing_price))

    print(f"Total profit from backtesting: ${total_profit}")
    print(f"Final cash balance: ${cash}")
    print(f"Transaction Log: {transaction_log}")

# Run the backtest
backtest_trading_strategy()

# Initialize variables to track cash, holdings, and average cost per stock
initial_cash = 10000  # Starting with $10,000
cash = initial_cash
holdings = {}  # Dictionary to store the amount of each stock held
avg_cost = {}  # Dictionary to track the average cost per stock
transaction_log = []  # Log of all trades

# Simulate trades based on historical data
def backtest_trading_strategy():
    global cash
    total_profit = 0

    for ticker, data in historical_data.items():
        for date, row in data.iterrows():
            closing_price = row['Close']
            buy_signal = closing_price < 150  # Example buy condition
            sell_signal = closing_price > 170  # Adjusted sell condition to be more reasonable

            # If there's a buy signal
            if buy_signal and cash >= closing_price:
                num_shares = cash // closing_price
                cash -= num_shares * closing_price

                # Track holdings and update average cost per stock
                holdings[ticker] = holdings.get(ticker, 0) + num_shares
                avg_cost[ticker] = ((avg_cost.get(ticker, 0) * (holdings[ticker] - num_shares)) + (num_shares * closing_price)) / holdings[ticker]

                print(f"Bought {num_shares} shares of {ticker} at {closing_price} on {date}")
                transaction_log.append((ticker, date, "buy", num_shares, closing_price))

            # If there's a sell signal and we hold the stock
            if sell_signal and holdings.get(ticker, 0) > 0:
                num_shares = holdings[ticker]
                sell_price = num_shares * closing_price
                cost_price = num_shares * avg_cost[ticker]  # Use average cost price

                # Calculate profit
                profit = sell_price - cost_price
                cash += sell_price
                total_profit += profit

                print(f"Sold {num_shares} shares of {ticker} at {closing_price} on {date}")
                holdings[ticker] = 0  # Set holdings to zero after selling
                avg_cost[ticker] = 0  # Reset average cost
                transaction_log.append((ticker, date, "sell", num_shares, closing_price))

    print(f"Total profit from backtesting: ${total_profit}")
    print(f"Final cash balance: ${cash}")
    print(f"Transaction Log: {transaction_log}")

# Run the backtest
backtest_trading_strategy()

import yfinance as yf
import pandas as pd
import time

# List of top stocks for Day Trader AI
top_stocks = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN']

# Function to retrieve minute-by-minute historical data using Yahoo Finance
def get_minute_data(symbol):
    try:
        print(f"Retrieving minute-by-minute data for {symbol}...")  # Debugging info
        stock = yf.Ticker(symbol)
        data = stock.history(period="1d", interval="1m")  # Adjust the period as needed (e.g., '5d', '1m' for 5 days of minute data)
        return data
    except Exception as e:
        print(f"Error retrieving data for {symbol}: {e}")
        return None

# Download minute-level data for each stock
minute_data = {}
for ticker in top_stocks:
    data = get_minute_data(ticker)
    if data is not None:
        minute_data[ticker] = data
    time.sleep(1)  # Sleep to avoid being throttled

# Combine minute-level data into one DataFrame (optional)
combined_data = pd.concat(minute_data, axis=1)
print(combined_data.head())

import ta  # Technical analysis library for calculating RSI

# Example function to calculate RSI
def calculate_rsi(data, window=14):
    data['RSI'] = ta.momentum.RSIIndicator(data['Close'], window=window).rsi()
    return data

# Simulate Day Trader AI with minute-level data
def simulate_day_trader_ai(data):
    total_profit = 0
    cash = 200  # Starting budget
    holdings = {}
    trade_amount = 5  # Max $5 per trade

    for ticker, minute_data in data.items():
        minute_data = calculate_rsi(minute_data)  # Calculate RSI

        for index, row in minute_data.iterrows():
            rsi = row['RSI']
            price = row['Close']

            # Buy signal: RSI < 30
            if rsi < 30 and cash >= trade_amount:
                num_shares = trade_amount / price
                cash -= trade_amount
                holdings[ticker] = holdings.get(ticker, 0) + num_shares
                print(f"Bought {num_shares:.4f} shares of {ticker} at {price} on {index}")

            # Sell signal: RSI > 70
            elif rsi > 70 and holdings.get(ticker, 0) > 0:
                num_shares = holdings[ticker]
                cash += num_shares * price
                profit = (num_shares * price) - trade_amount
                total_profit += profit
                holdings[ticker] = 0
                print(f"Sold {num_shares:.4f} shares of {ticker} at {price} on {index}")

    print(f"Total profit from simulation: ${total_profit}")
    print(f"Final cash balance: ${cash}")

# Run the simulation with minute-level data
simulate_day_trader_ai(minute_data)

!pip install ta

import ta  # Technical analysis library for calculating RSI

# Example function to calculate RSI
def calculate_rsi(data, window=14):
    data['RSI'] = ta.momentum.RSIIndicator(data['Close'], window=window).rsi()
    return data

# Simulate Day Trader AI with minute-level data
def simulate_day_trader_ai(data):
    total_profit = 0
    cash = 200  # Starting budget
    holdings = {}
    trade_amount = 5  # Max $5 per trade

    for ticker, minute_data in data.items():
        minute_data = calculate_rsi(minute_data)  # Calculate RSI

        for index, row in minute_data.iterrows():
            rsi = row['RSI']
            price = row['Close']

            # Buy signal: RSI < 30
            if rsi < 30 and cash >= trade_amount:
                num_shares = trade_amount / price
                cash -= trade_amount
                holdings[ticker] = holdings.get(ticker, 0) + num_shares
                print(f"Bought {num_shares:.4f} shares of {ticker} at {price} on {index}")

            # Sell signal: RSI > 70
            elif rsi > 70 and holdings.get(ticker, 0) > 0:
                num_shares = holdings[ticker]
                cash += num_shares * price
                profit = (num_shares * price) - trade_amount
                total_profit += profit
                holdings[ticker] = 0
                print(f"Sold {num_shares:.4f} shares of {ticker} at {price} on {index}")

    print(f"Total profit from simulation: ${total_profit}")
    print(f"Final cash balance: ${cash}")

# Run the simulation with minute-level data
simulate_day_trader_ai(minute_data)

import yfinance as yf
import ta  # For technical indicators like RSI
import pandas as pd
import time

# List of top stocks for Day Trader AI
top_stocks = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN']

# Function to retrieve minute-by-minute historical data
def get_minute_data(symbol):
    try:
        stock = yf.Ticker(symbol)
        data = stock.history(period="1d", interval="1m")  # Adjust period for more days if needed
        return data
    except Exception as e:
        print(f"Error retrieving data for {symbol}: {e}")
        return None

# Calculate RSI for the data
def calculate_rsi(data, window):
    data['RSI'] = ta.momentum.RSIIndicator(data['Close'], window=window).rsi()
    return data

# Simulate trading strategy based on RSI
def simulate_day_trader_ai(data, rsi_window):
    total_profit = 0
    cash = 200  # Starting budget
    trade_amount = 5  # $5 trades
    holdings = {}

    for ticker, minute_data in data.items():
        minute_data = calculate_rsi(minute_data, rsi_window)  # Calculate RSI

        for index, row in minute_data.iterrows():
            rsi = row['RSI']
            price = row['Close']

            # Buy signal: RSI < 30
            if rsi < 30 and cash >= trade_amount:
                num_shares = trade_amount / price
                cash -= trade_amount
                holdings[ticker] = holdings.get(ticker, 0) + num_shares
                print(f"Bought {num_shares:.4f} shares of {ticker} at {price} on {index}")

            # Sell signal: RSI > 70
            elif rsi > 70 and holdings.get(ticker, 0) > 0:
                num_shares = holdings[ticker]
                cash += num_shares * price
                profit = (num_shares * price) - trade_amount
                total_profit += profit
                holdings[ticker] = 0
                print(f"Sold {num_shares:.4f} shares of {ticker} at {price} on {index}")

    print(f"Total profit with RSI window {rsi_window}: ${total_profit}")
    return total_profit

# Optimize RSI window by testing different values
def optimize_rsi(data):
    best_rsi_window = 14  # Default RSI window
    best_profit = -float('inf')

    for window in [7, 14, 21]:  # Test RSI windows of 7, 14, and 21
        print(f"Testing RSI window: {window}")
        profit = simulate_day_trader_ai(data, window)
        if profit > best_profit:
            best_profit = profit
            best_rsi_window = window

    print(f"Best RSI window: {best_rsi_window} with profit: ${best_profit}")
    return best_rsi_window

# Fetch the minute-level data for the stocks
minute_data = {}
for ticker in top_stocks:
    data = get_minute_data(ticker)
    if data is not None:
        minute_data[ticker] = data
    time.sleep(1)  # Sleep to avoid throttling

# Optimize RSI
best_rsi = optimize_rsi(minute_data)

import numpy as np
import pandas as pd

# Actions: 0 = Hold, 1 = Buy, 2 = Sell
actions = [0, 1, 2]

# Hyperparameters for Q-learning
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 0.1  # Exploration factor

# Q-table: Initialize a table with zeros
# State size can be stock price, RSI, etc.
q_table = np.zeros((100, len(actions)))  # Example with 100 states (you can adjust the state space size)

# Reward function: Profit/Loss based on action taken
def reward_function(action, profit):
    if action == 1:  # Buy
        return profit
    elif action == 2:  # Sell
        return -profit
    else:  # Hold
        return 0

# Choosing an action using epsilon-greedy strategy
def choose_action(state, epsilon):
    if np.random.uniform(0, 1) < epsilon:
        return np.random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit

# Update Q-values using the Q-learning formula
def update_q_table(state, action, reward, next_state):
    best_next_action = np.argmax(q_table[next_state])
    q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * q_table[next_state, best_next_action] - q_table[state, action])

# Training loop
def train_agent(data):
    for index, row in data.iterrows():
        # Example state: Use price, RSI or other indicators as states
        state = int(row['RSI'])  # Simplified state (you'll adjust this)

        action = choose_action(state, epsilon)
        # Simulate the reward based on your trading logic
        reward = reward_function(action, row['Profit'])  # You need to compute profit for each trade

        next_state = int(row['RSI'])  # Next state (you'll adjust this based on future data)

        # Update Q-table
        update_q_table(state, action, reward, next_state)

# Placeholder: Load your historical data for training
historical_data = pd.read_csv('historical_stock_data.csv')  # Replace with actual data

# Train the agent
train_agent(historical_data)

import numpy as np
import pandas as pd

# Load the existing historical data (replace with actual variable holding the data)
# Assuming your DataFrame is named 'historical_data'
historical_data = existing_data  # Use the data from Alpha Vantage

# Actions: 0 = Hold, 1 = Buy, 2 = Sell
actions = [0, 1, 2]

# Hyperparameters for Q-learning
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 0.1  # Exploration factor

# Q-table: Initialize a table with zeros
# State size can be stock price, RSI, etc.
q_table = np.zeros((100, len(actions)))  # Example with 100 states (you can adjust the state space size)

# Reward function: Profit/Loss based on action taken
def reward_function(action, profit):
    if action == 1:  # Buy
        return profit
    elif action == 2:  # Sell
        return -profit
    else:  # Hold
        return 0

# Choosing an action using epsilon-greedy strategy
def choose_action(state, epsilon):
    if np.random.uniform(0, 1) < epsilon:
        return np.random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit

# Update Q-values using the Q-learning formula
def update_q_table(state, action, reward, next_state):
    best_next_action = np.argmax(q_table[next_state])
    q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * q_table[next_state, best_next_action] - q_table[state, action])

# Training loop
def train_agent(data):
    for index, row in data.iterrows():
        # Example state: Use price, RSI or other indicators as states
        state = int(row['RSI'])  # Simplified state (you'll adjust this)

        action = choose_action(state, epsilon)
        # Simulate the reward based on your trading logic
        reward = reward_function(action, row['Profit'])  # You need to compute profit for each trade

        next_state = int(row['RSI'])  # Next state (you'll adjust this based on future data)

        # Update Q-table
        update_q_table(state, action, reward, next_state)

# Assuming your existing data is loaded into 'historical_data' DataFrame
# Train the agent
train_agent(historical_data)

import numpy as np
import pandas as pd

# Load the historical stock data from your existing DataFrame (assuming it's already in your environment)
# Replace this line with the actual variable name that holds your data
historical_data = your_historical_data_variable  # Use the correct DataFrame variable here

# Actions: 0 = Hold, 1 = Buy, 2 = Sell
actions = [0, 1, 2]

# Hyperparameters for Q-learning
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 0.1  # Exploration factor

# Q-table: Initialize a table with zeros
# State size can be stock price, RSI, etc.
q_table = np.zeros((100, len(actions)))  # Example with 100 states (you can adjust the state space size)

# Reward function: Profit/Loss based on action taken
def reward_function(action, profit):
    if action == 1:  # Buy
        return profit
    elif action == 2:  # Sell
        return -profit
    else:  # Hold
        return 0

# Choosing an action using epsilon-greedy strategy
def choose_action(state, epsilon):
    if np.random.uniform(0, 1) < epsilon:
        return np.random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit

# Update Q-values using the Q-learning formula
def update_q_table(state, action, reward, next_state):
    best_next_action = np.argmax(q_table[next_state])
    q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * q_table[next_state, best_next_action] - q_table[state, action])

# Training loop
def train_agent(data):
    for index, row in data.iterrows():
        # Example state: Use price, RSI or other indicators as states
        state = int(row['RSI'])  # Simplified state (you'll adjust this)

        action = choose_action(state, epsilon)
        # Simulate the reward based on your trading logic
        reward = reward_function(action, row['Profit'])  # You need to compute profit for each trade

        next_state = int(row['RSI'])  # Next state (you'll adjust this based on future data)

        # Update Q-table
        update_q_table(state, action, reward, next_state)

# Train the agent using the historical data
train_agent(historical_data)

import numpy as np
import pandas as pd

# Use the existing DataFrame with your historical data
# Replace 'historical_stock_data' with the actual variable where your data is stored
historical_data = historical_stock_data  # Use the correct DataFrame variable here

# Actions: 0 = Hold, 1 = Buy, 2 = Sell
actions = [0, 1, 2]

# Hyperparameters for Q-learning
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 0.1  # Exploration factor

# Q-table: Initialize a table with zeros
# Assuming state size can be stock price, RSI, or other indicators
q_table = np.zeros((100, len(actions)))  # Example with 100 states (adjust based on your state space)

# Reward function: Profit/Loss based on action taken
def reward_function(action, profit):
    if action == 1:  # Buy
        return profit
    elif action == 2:  # Sell
        return -profit
    else:  # Hold
        return 0

# Choosing an action using epsilon-greedy strategy
def choose_action(state, epsilon):
    if np.random.uniform(0, 1) < epsilon:
        return np.random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit

# Update Q-values using the Q-learning formula
def update_q_table(state, action, reward, next_state):
    best_next_action = np.argmax(q_table[next_state])
    q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * q_table[next_state, best_next_action] - q_table[state, action])

# Training loop
def train_agent(data):
    for index, row in data.iterrows():
        # Example state: Use price, RSI, or other indicators as states
        state = int(row['RSI'])  # Simplified state, you may adjust this as needed

        action = choose_action(state, epsilon)
        # Simulate the reward based on your trading logic
        reward = reward_function(action, row['Profit'])  # You need to compute profit for each trade

        next_state = int(row['RSI'])  # Next state (adjust based on future data)

        # Update Q-table
        update_q_table(state, action, reward, next_state)

# Train the agent using the historical data
train_agent(historical_data)

import numpy as np
import pandas as pd

# Use the existing DataFrame where your historical data is stored
# Replace 'data' with the actual variable name for your loaded historical stock data
historical_data = data  # Update this to the correct variable if needed

# Actions: 0 = Hold, 1 = Buy, 2 = Sell
actions = [0, 1, 2]

# Hyperparameters for Q-learning
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 0.1  # Exploration factor

# Q-table: Initialize a table with zeros
# Assuming state size can be stock price, RSI, or other indicators
q_table = np.zeros((100, len(actions)))  # Example with 100 states (adjust based on your state space)

# Reward function: Profit/Loss based on action taken
def reward_function(action, profit):
    if action == 1:  # Buy
        return profit
    elif action == 2:  # Sell
        return -profit
    else:  # Hold
        return 0

# Choosing an action using epsilon-greedy strategy
def choose_action(state, epsilon):
    if np.random.uniform(0, 1) < epsilon:
        return np.random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit

# Update Q-values using the Q-learning formula
def update_q_table(state, action, reward, next_state):
    best_next_action = np.argmax(q_table[next_state])
    q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * q_table[next_state, best_next_action] - q_table[state, action])

# Training loop
def train_agent(data):
    for index, row in data.iterrows():
        # Example state: Use price, RSI, or other indicators as states
        state = int(row['RSI'])  # Simplified state, you may adjust this as needed

        action = choose_action(state, epsilon)
        # Simulate the reward based on your trading logic
        reward = reward_function(action, row['Profit'])  # You need to compute profit for each trade

        next_state = int(row['RSI'])  # Next state (adjust based on future data)

        # Update Q-table
        update_q_table(state, action, reward, next_state)

# Train the agent using the historical data
train_agent(historical_data)

import numpy as np
import pandas as pd

# Use the existing DataFrame where your historical data is stored
# Replace 'data' with the actual variable name for your loaded historical stock data
historical_data = data  # Update this to the correct variable if needed

# Actions: 0 = Hold, 1 = Buy, 2 = Sell
actions = [0, 1, 2]

# Hyperparameters for Q-learning
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 0.1  # Exploration factor

# Q-table: Initialize a table with zeros
# Assuming state size can be stock price, RSI, or other indicators
q_table = np.zeros((100, len(actions)))  # Example with 100 states (adjust based on your state space)

# Reward function: Profit/Loss based on action taken
def reward_function(action, profit):
    if action == 1:  # Buy
        return profit
    elif action == 2:  # Sell
        return -profit
    else:  # Hold
        return 0

# Choosing an action using epsilon-greedy strategy
def choose_action(state, epsilon):
    if np.random.uniform(0, 1) < epsilon:
        return np.random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit

# Update Q-values using the Q-learning formula
def update_q_table(state, action, reward, next_state):
    best_next_action = np.argmax(q_table[next_state])
    q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * q_table[next_state, best_next_action] - q_table[state, action])

# Training loop
def train_agent(data):
    for index, row in data.iterrows():
        # Check if RSI value is available
        if pd.isna(row['RSI']):
            continue  # Skip rows where RSI is NaN

        # Example state: Use price, RSI, or other indicators as states
        state = int(row['RSI'])  # Simplified state, you may adjust this as needed

        action = choose_action(state, epsilon)
        # Simulate the reward based on your trading logic
        reward = reward_function(action, row['Profit'])  # You need to compute profit for each trade

        next_state = int(row['RSI'])  # Next state (adjust based on future data)

        # Update Q-table
        update_q_table(state, action, reward, next_state)

# Drop rows with NaN in RSI if you prefer that approach
historical_data.dropna(subset=['RSI'], inplace=True)

# Train the agent using the historical data
train_agent(historical_data)

import numpy as np
import pandas as pd

# Use the existing DataFrame where your historical data is stored
historical_data = data  # Ensure this points to your actual data

# Actions: 0 = Hold, 1 = Buy, 2 = Sell
actions = [0, 1, 2]

# Hyperparameters for Q-learning
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 0.1  # Exploration factor

# Q-table: Initialize a table with zeros
q_table = np.zeros((100, len(actions)))  # Example with 100 states

# Reward function: Profit/Loss based on action taken
def reward_function(action, buy_price, current_price):
    if action == 1:  # Buy
        return 0  # No profit/loss until sold
    elif action == 2:  # Sell
        return current_price - buy_price  # Profit/loss is the price difference
    else:  # Hold
        return 0

# Choosing an action using epsilon-greedy strategy
def choose_action(state, epsilon):
    if np.random.uniform(0, 1) < epsilon:
        return np.random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit

# Update Q-values using the Q-learning formula
def update_q_table(state, action, reward, next_state):
    best_next_action = np.argmax(q_table[next_state])
    q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * q_table[next_state, best_next_action] - q_table[state, action])

# Training loop
def train_agent(data):
    buy_price = None  # Placeholder to store the price when a buy action is taken

    for index, row in data.iterrows():
        # Check if RSI value is available
        if pd.isna(row['RSI']):
            continue  # Skip rows where RSI is NaN

        state = int(row['RSI'])  # Simplified state

        action = choose_action(state, epsilon)

        current_price = row['Close']  # Use the close price as the current price

        if action == 1:  # Buy
            buy_price = current_price

        reward = reward_function(action, buy_price, current_price) if buy_price is not None else 0

        next_state = int(row['RSI'])  # Next state

        # Update Q-table
        update_q_table(state, action, reward, next_state)

# Drop rows with NaN in RSI if needed
historical_data.dropna(subset=['RSI'], inplace=True)

# Train the agent using the historical data
train_agent(historical_data)

epsilon_decay = 0.995  # Decay rate for epsilon
min_epsilon = 0.01  # Minimum value for epsilon

def choose_action(state, epsilon):
    if np.random.uniform(0, 1) < epsilon:
        return np.random.choice(actions)  # Explore
    else:
        return np.argmax(q_table[state])  # Exploit

# Update epsilon after each episode
def decay_epsilon(epsilon):
    return max(min_epsilon, epsilon * epsilon_decay)

# Adjust the reward function to incorporate better penalties and rewards
def calculate_reward(buy_price, sell_price, trade_volume, threshold=0.01):
    # Profit percentage calculation
    profit_percentage = (sell_price - buy_price) / buy_price

    # Apply a threshold: only reward significant price movements
    if abs(profit_percentage) < threshold:
        return 0  # No reward for tiny fluctuations

    # Profit case
    if profit_percentage > 0:
        reward = profit_percentage * 100  # Scale reward for profit (e.g., 10% profit gives reward of 10)
    else:
        reward = profit_percentage * 200  # Penalize losses more heavily (e.g., -10% loss gives penalty of -20)

    # Optional: Volume-based penalty (e.g., if trade volume is too small, add a slight penalty)
    if trade_volume < 0.001:  # Arbitrary small volume threshold
        reward -= 5  # Penalize for low volume

    return reward

# Example training loop with the improved reward function
def train_agent(data):
    global epsilon

    for index, row in data.iterrows():
        # State: Use RSI, or include other indicators like SMA, volume, etc.
        state = int(row['RSI'])  # Example simplified state

        action = choose_action(state, epsilon)

        # Simulate the trade (replace this with your trading logic)
        buy_price = row['Close']  # Example buy price (replace with actual buy price logic)
        sell_price = row['Close']  # Example sell price (replace with actual sell price logic)
        trade_volume = row['Volume']  # Example trade volume

        # Calculate the reward based on the new reward function
        reward = calculate_reward(buy_price, sell_price, trade_volume)

        # Update Q-table based on the reward
        next_state = int(row['RSI'])  # You can customize this
        q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * np.max(q_table[next_state]) - q_table[state, action])

        # Decay epsilon
        epsilon = decay_epsilon(epsilon)

# Define hyperparameters for Q-learning
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor (0.95 means we prioritize future rewards)
epsilon = 1.0  # Exploration rate (start at 1 to explore a lot)
min_epsilon = 0.01  # Minimum value for epsilon (we want to explore less as training progresses)
decay_rate = 0.995  # How fast we decay epsilon (controls exploration)

# Decay epsilon function to control exploration over time
def decay_epsilon(epsilon):
    return max(min_epsilon, epsilon * decay_rate)

# Modify your training loop to allow these parameters to be tweaked
def train_agent_with_parameters(data, alpha=0.1, gamma=0.95, epsilon=1.0, decay_rate=0.995):
    global q_table
    for index, row in data.iterrows():
        state = int(row['RSI'])  # State could be more sophisticated
        action = choose_action(state, epsilon)

        # Simulate the trade logic here
        buy_price = row['Close']  # Buy price (this is simplified, you would use your logic)
        sell_price = row['Close']  # Sell price
        trade_volume = row['Volume']  # Volume

        # Calculate the reward
        reward = calculate_reward(buy_price, sell_price, trade_volume)

        # Q-learning update
        next_state = int(row['RSI'])
        q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * np.max(q_table[next_state]) - q_table[state, action])

        # Decay epsilon
        epsilon = decay_epsilon(epsilon)

# Example: Running with different parameters
train_agent_with_parameters(historical_data, alpha=0.2, gamma=0.99, epsilon=1.0, decay_rate=0.999)

import pandas as pd

# Calculate additional features (SMA, EMA, MACD, etc.)
def add_indicators(data):
    # Adding a 14-period SMA
    data['SMA'] = data['Close'].rolling(window=14).mean()

    # Adding a 14-period EMA
    data['EMA'] = data['Close'].ewm(span=14, adjust=False).mean()

    # Adding MACD (12, 26 period)
    data['MACD'] = data['Close'].ewm(span=12, adjust=False).mean() - data['Close'].ewm(span=26, adjust=False).mean()

    # Adding Bollinger Bands (20-period)
    data['20-SMA'] = data['Close'].rolling(window=20).mean()
    data['stddev'] = data['Close'].rolling(window=20).std()
    data['Upper_Band'] = data['20-SMA'] + (data['stddev'] * 2)
    data['Lower_Band'] = data['20-SMA'] - (data['stddev'] * 2)

    # Fill NaN values after calculation
    data.fillna(0, inplace=True)

    return data

# Call the function to enrich your historical data
historical_data = add_indicators(historical_data)

# Now let's update the train_agent function to use these new features as part of the state representation
def train_agent_with_enhanced_state(data, alpha=0.1, gamma=0.95, epsilon=1.0, decay_rate=0.995):
    global q_table
    for index, row in data.iterrows():
        # Enhanced state with RSI, SMA, EMA, and Bollinger Bands
        state = (int(row['RSI']), int(row['SMA']), int(row['EMA']), int(row['MACD']), int(row['Upper_Band']), int(row['Lower_Band']))
        action = choose_action(state, epsilon)

        # Simulate the trade logic here
        buy_price = row['Close']
        sell_price = row['Close']
        trade_volume = row['Volume']

        # Calculate reward
        reward = calculate_reward(buy_price, sell_price, trade_volume)

        # Q-learning update
        next_state = (int(row['RSI']), int(row['SMA']), int(row['EMA']), int(row['MACD']), int(row['Upper_Band']), int(row['Lower_Band']))
        q_table[state, action] = q_table[state, action] + alpha * (reward + gamma * np.max(q_table[next_state]) - q_table[state, action])

        # Decay epsilon
        epsilon = decay_epsilon(epsilon)

# Train the agent with the enhanced state
train_agent_with_enhanced_state(historical_data)

import numpy as np

# Example function to discretize indicators to fit within Q-table bounds
def discretize(value, min_val, max_val, bins=100):
    """Discretize a value to fit within a given number of bins."""
    return int((value - min_val) / (max_val - min_val) * (bins - 1))

# Update the train_agent function with discretized state representation
def train_agent_with_discretized_state(data, alpha=0.1, gamma=0.95, epsilon=1.0, decay_rate=0.995, bins=100):
    global q_table
    for index, row in data.iterrows():
        # Discretizing the indicators into manageable state values
        rsi = discretize(row['RSI'], 0, 100, bins)  # RSI typically ranges from 0 to 100
        sma = discretize(row['SMA'], 0, max(data['SMA']), bins)  # Normalize SMA
        ema = discretize(row['EMA'], 0, max(data['EMA']), bins)  # Normalize EMA
        macd = discretize(row['MACD'], min(data['MACD']), max(data['MACD']), bins)  # Normalize MACD
        upper_band = discretize(row['Upper_Band'], 0, max(data['Upper_Band']), bins)  # Normalize Bollinger Bands
        lower_band = discretize(row['Lower_Band'], min(data['Lower_Band']), max(data['Lower_Band']), bins)

        state = (rsi, sma, ema, macd, upper_band, lower_band)  # Discretized state

        # Initialize Q-table size if not done already
        if q_table.shape[0] < bins**len(state):
            q_table = np.zeros((bins, bins, bins, bins, bins, bins, 3))  # Adjust for number of actions (hold, buy, sell)

        action = choose_action(state, epsilon)

        # Simulate the trade logic
        buy_price = row['Close']
        sell_price = row['Close']
        trade_volume = row['Volume']

        # Calculate reward
        reward = calculate_reward(buy_price, sell_price, trade_volume)

        # Q-learning update
        next_state = (rsi, sma, ema, macd, upper_band, lower_band)
        q_table[state] = q_table[state] + alpha * (reward + gamma * np.max(q_table[next_state]) - q_table[state])

        # Decay epsilon
        epsilon = decay_epsilon(epsilon)

# Train the agent with discretized state representation
train_agent_with_discretized_state(historical_data)

# Define risk management parameters
STOP_LOSS_PERCENTAGE = 0.05  # Example: 5% stop loss
TAKE_PROFIT_PERCENTAGE = 0.10  # Example: 10% take profit
MAX_DAILY_LOSS = 50  # Maximum daily loss in dollars

# Variables to track daily performance
daily_profit = 0
daily_loss = 0

def apply_risk_management(buy_price, current_price):
    global daily_profit, daily_loss

    # Calculate the stop-loss and take-profit prices
    stop_loss_price = buy_price * (1 - STOP_LOSS_PERCENTAGE)
    take_profit_price = buy_price * (1 + TAKE_PROFIT_PERCENTAGE)

    # Check if the current price hits the stop-loss or take-profit level
    if current_price <= stop_loss_price:
        print(f"Stop-Loss triggered. Selling at {current_price}")
        return "sell"  # Sell to minimize loss
    elif current_price >= take_profit_price:
        print(f"Take-Profit triggered. Selling at {current_price}")
        return "sell"  # Sell to secure profit

    return "hold"  # Continue holding the position

def check_daily_loss_limit():
    global daily_loss

    if daily_loss >= MAX_DAILY_LOSS:
        print("Max daily loss reached. Stopping trading for the day.")
        return True  # Stop trading for the day
    return False

# Example function to execute a trade with risk management
def execute_trade_with_risk_management(data):
    global daily_profit, daily_loss

    for index, row in data.iterrows():
        buy_price = row['Close']
        current_price = row['Close']  # Replace with actual live/current price in real trading

        # Apply risk management checks
        action = apply_risk_management(buy_price, current_price)

        # Update daily profit/loss
        if action == "sell":
            trade_profit = current_price - buy_price
            if trade_profit > 0:
                daily_profit += trade_profit
            else:
                daily_loss += abs(trade_profit)

            # Check if the maximum daily loss has been reached
            if check_daily_loss_limit():
                break  # Stop trading for the day

# Example execution
execute_trade_with_risk_management(historical_data)

import numpy as np

# Initialize performance tracking variables
total_profit = 0
total_loss = 0
num_wins = 0
num_losses = 0
all_trades = []  # To store profit/loss per trade

# Function to update performance metrics after each trade
def update_performance_metrics(buy_price, sell_price):
    global total_profit, total_loss, num_wins, num_losses, all_trades

    trade_result = sell_price - buy_price
    all_trades.append(trade_result)

    if trade_result > 0:
        total_profit += trade_result
        num_wins += 1
    else:
        total_loss += abs(trade_result)
        num_losses += 1

# Calculate win rate
def calculate_win_rate():
    total_trades = num_wins + num_losses
    if total_trades == 0:
        return 0
    return (num_wins / total_trades) * 100

# Calculate Sharpe Ratio
def calculate_sharpe_ratio():
    # Convert all_trades to a NumPy array
    returns = np.array(all_trades)

    # Calculate the mean and standard deviation of returns
    mean_return = np.mean(returns)
    return_std = np.std(returns)

    # Risk-free rate can be considered as 0 for simplicity
    risk_free_rate = 0

    if return_std == 0:
        return 0  # Avoid division by zero

    # Sharpe ratio formula: (mean return - risk-free rate) / std of return
    sharpe_ratio = (mean_return - risk_free_rate) / return_std
    return sharpe_ratio

# Calculate average profit/loss per trade
def calculate_average_profit_per_trade():
    total_trades = num_wins + num_losses
    if total_trades == 0:
        return 0
    return (total_profit - total_loss) / total_trades

# Function to display performance metrics
def display_performance_metrics():
    win_rate = calculate_win_rate()
    sharpe_ratio = calculate_sharpe_ratio()
    avg_profit_per_trade = calculate_average_profit_per_trade()

    print(f"Total Profit: ${total_profit:.2f}")
    print(f"Total Loss: ${total_loss:.2f}")
    print(f"Win Rate: {win_rate:.2f}%")
    print(f"Sharpe Ratio: {sharpe_ratio:.2f}")
    print(f"Average Profit/Loss per Trade: ${avg_profit_per_trade:.2f}")

# Example function to execute a trade with performance metrics
def execute_trade_with_performance_metrics(data):
    for index, row in data.iterrows():
        buy_price = row['Close']
        current_price = row['Close']  # Replace with actual live/current price in real trading

        # Simulate a trade
        action = apply_risk_management(buy_price, current_price)

        if action == "sell":
            update_performance_metrics(buy_price, current_price)

# After running all trades, display performance metrics
display_performance_metrics()

# Example function to simulate trades for performance metrics
def simulate_trades(data):
    global total_profit, total_loss, num_wins, num_losses

    # Simulate a few trades for testing
    for i in range(10):
        # Randomly simulate buy and sell prices (these should be based on real logic in production)
        buy_price = 100 + i  # Simulating increasing buy prices
        sell_price = buy_price + np.random.uniform(-5, 10)  # Randomly generate sell price

        # Update performance metrics after each trade
        update_performance_metrics(buy_price, sell_price)

# Simulate some trades to fill performance metrics
simulate_trades(historical_data)

# Display the updated performance metrics
display_performance_metrics()

from alpha_vantage.timeseries import TimeSeries
import time

api_key = 'your_alpha_vantage_key_here'
ts = TimeSeries(key=api_key, output_format='pandas')

def get_live_data(symbol):
    data, meta_data = ts.get_quote_endpoint(symbol)
    return data['05. price'][0]  # Current price

def check_signals(symbol):
    price = get_live_data(symbol)
    rsi = calculate_rsi()  # Call your RSI calculation function

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    else:
        return 'hold'

def execute_trade(signal, symbol):
    if signal == 'buy':
        # Example fractional buy logic
        r.order_buy_fractional_by_price(symbol, amount_in_dollars=5)
    elif signal == 'sell':
        # Example fractional sell logic
        r.order_sell_fractional_by_quantity(symbol, quantity_to_sell=0.02)  # Adjust quantity

def update_performance(trade_data):
    # Update profit, loss, and other metrics
    pass

daily_loss_limit = 50  # Example limit
if total_loss_today >= daily_loss_limit:
    print("Daily loss limit reached. Halting trading for the day.")
    # Logic to halt further trading

# Initialize daily loss and flag to halt trading
daily_loss_limit = 50  # Maximum allowed loss for the day
total_loss_today = 0  # Variable to track total loss
trading_halted = False  # Flag to halt trading once the loss limit is reached

# Function to check if we should halt trading
def check_daily_loss():
    global trading_halted
    if total_loss_today >= daily_loss_limit:
        print("Daily loss limit reached. Halting trading for the day.")
        trading_halted = True  # Set flag to halt trading

# Execute trade function that checks the loss limit before trading
def execute_trade(signal, symbol, trade_amount):
    global total_loss_today

    # Check if trading is halted
    if trading_halted:
        print(f"Trading halted for the day. No trade executed for {symbol}.")
        return

    # Example logic to calculate profit/loss from trade
    if signal == 'buy':
        # Assuming we store the buy price to later calculate profit/loss on sale
        buy_price = get_live_data(symbol)
        print(f"Buying {symbol} at price {buy_price}")
        r.order_buy_fractional_by_price(symbol, amount_in_dollars=trade_amount)

    elif signal == 'sell':
        # Simulate a sell, assume you calculate the loss/gain here
        sell_price = get_live_data(symbol)
        print(f"Selling {symbol} at price {sell_price}")
        r.order_sell_fractional_by_quantity(symbol, quantity_to_sell=0.02)  # Example quantity

        # Example: Calculate loss for the day (this should come from real trading results)
        loss_or_gain = sell_price - buy_price  # Simplified calculation for example
        total_loss_today += max(0, -loss_or_gain)  # Add only losses, not gains

        print(f"Total loss today: {total_loss_today}")

    # Check if trading should be halted after the trade
    check_daily_loss()

# Example real-time trading function
def run_real_time_trading(symbol, trade_amount):
    signal = check_signals(symbol)  # Generates 'buy', 'sell', or 'hold'
    execute_trade(signal, symbol, trade_amount)

# Example loop to keep trading throughout the day
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add your symbols here

for symbol in symbols:
    if not trading_halted:
        run_real_time_trading(symbol, trade_amount=5)  # $5 per trade example
    else:
        break  # Stop the loop if trading is halted

def get_live_data(symbol):
    data = get_data_for_symbol(symbol)  # Assuming this fetches the latest data for the symbol
    return data['05. price'].iloc[0]  # Access using .iloc to avoid the deprecation warning

def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window, min_periods=1).mean()
    avg_loss = loss.rolling(window=window, min_periods=1).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the latest RSI value

def check_signals(symbol):
    # Assuming you have historical data ready for the symbol
    historical_data = get_historical_data(symbol)  # Fetch historical data for the symbol

    # Calculate the RSI for the symbol
    rsi = calculate_rsi(historical_data, window=14)  # Use a 14-period window, adjust as needed

    # Determine buy/sell signals based on RSI
    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    else:
        return 'hold'

symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add your symbols here

for symbol in symbols:
    if not trading_halted:
        run_real_time_trading(symbol, trade_amount=5)  # $5 per trade example
    else:
        break  # Stop the loop if trading is halted

print(historical_data.columns)  # Print the column names to inspect them

def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()  # Use the correct column name here
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window, min_periods=1).mean()
    avg_loss = loss.rolling(window=window, min_periods=1).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the latest RSI value

import time
import logging

# Configure logging to output to a file
logging.basicConfig(filename='trading_bot_log.log', level=logging.INFO)

def get_live_data_with_retry(symbol, max_retries=3):
    retries = 0
    while retries < max_retries:
        try:
            data = get_live_data(symbol)
            return data  # Return the data if successful
        except Exception as e:
            logging.error(f"Error retrieving data for {symbol}: {e}")
            retries += 1
            time.sleep(2)  # Wait for 2 seconds before retrying
    logging.error(f"Failed to retrieve data for {symbol} after {max_retries} retries.")
    return None  # Return None if all retries fail

def run_real_time_trading_with_error_handling(symbol, trade_amount=5):
    try:
        print(f"Retrieving data for {symbol}...")
        data = get_live_data_with_retry(symbol)

        if data is None:
            logging.error(f"Skipping {symbol} due to data retrieval failure.")
            return  # Skip if data could not be retrieved

        signals = check_signals(symbol)
        execute_trade_logic(symbol, signals, trade_amount)

    except Exception as e:
        logging.error(f"Error in real-time trading for {symbol}: {e}")
        print(f"Error occurred while trading {symbol}. Check log for details.")

daily_loss_limit = 50  # Example daily loss limit
stop_loss_percentage = 5  # Example stop-loss percentage (5% of the trade value)

total_loss_today = 0  # To track daily losses

def execute_trade_with_risk_management(symbol, signals, trade_amount):
    global total_loss_today

    try:
        if total_loss_today >= daily_loss_limit:
            print(f"Daily loss limit reached. Halting trading for {symbol} today.")
            logging.warning(f"Daily loss limit reached. No more trades for {symbol}.")
            return

        # Example: Buy signal logic
        if signals['buy']:
            # Execute buy trade (pseudo-code, replace with your actual trade logic)
            buy_price = get_live_data(symbol)['price']
            print(f"Bought {symbol} at {buy_price}")

        # Example: Sell signal logic with stop-loss
        if signals['sell']:
            # Execute sell trade (pseudo-code, replace with your actual trade logic)
            sell_price = get_live_data(symbol)['price']
            buy_price = signals['buy_price']  # Price you bought at

            # Calculate the percentage loss on this trade
            loss_percentage = ((buy_price - sell_price) / buy_price) * 100

            # Check if the stop-loss percentage is exceeded
            if loss_percentage >= stop_loss_percentage:
                print(f"Stop-loss triggered for {symbol}. Selling at {sell_price}.")
                logging.warning(f"Stop-loss triggered for {symbol}. Loss: {loss_percentage}%")

            # Update the total loss for the day
            trade_loss = buy_price - sell_price
            total_loss_today += trade_loss

            print(f"Total loss for today: {total_loss_today}")

    except Exception as e:
        logging.error(f"Error in risk management for {symbol}: {e}")
        print(f"Error occurred while executing trade for {symbol}. Check log for details.")

import numpy as np
import logging

# Set up logging
logging.basicConfig(filename='trading_log.txt', level=logging.INFO, format='%(asctime)s - %(message)s')

# Initialize performance tracking variables
total_profit = 0
total_loss = 0
total_trades = 0
winning_trades = 0
losing_trades = 0
trade_results = []  # To store profit/loss per trade

def calculate_performance_metrics():
    global total_profit, total_loss, total_trades, winning_trades, losing_trades

    if total_trades == 0:
        return {
            'Total Profit': 0,
            'Total Loss': 0,
            'Win Rate': 0,
            'Sharpe Ratio': float('nan'),
            'Avg Profit/Loss per Trade': 0
        }

    win_rate = (winning_trades / total_trades) * 100
    avg_profit_loss = (total_profit - total_loss) / total_trades

    # Sharpe Ratio calculation (simplified version)
    if len(trade_results) > 1:
        avg_returns = np.mean(trade_results)
        std_returns = np.std(trade_results)
        sharpe_ratio = avg_returns / std_returns if std_returns != 0 else float('nan')
    else:
        sharpe_ratio = float('nan')

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Sharpe Ratio': sharpe_ratio,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

def log_trade(symbol, trade_type, profit_or_loss):
    global total_profit, total_loss, total_trades, winning_trades, losing_trades

    # Update performance stats
    total_trades += 1
    if profit_or_loss > 0:
        total_profit += profit_or_loss
        winning_trades += 1
    else:
        total_loss += abs(profit_or_loss)
        losing_trades += 1

    # Log the trade result
    trade_results.append(profit_or_loss)

    # Log to file
    logging.info(f"Trade {total_trades}: {trade_type} {symbol} | Profit/Loss: {profit_or_loss:.2f}")

    # Display current performance metrics
    metrics = calculate_performance_metrics()
    print(f"Current Performance Metrics: {metrics}")

# Example of how this would be used within a trade execution
def execute_trade(symbol, trade_type, trade_price, initial_price):
    global total_profit, total_loss

    if trade_type == 'buy':
        # Simulate buy logic (You may have actual buy code here)
        print(f"Bought {symbol} at {trade_price}")
        logging.info(f"Bought {symbol} at {trade_price}")

    elif trade_type == 'sell':
        # Calculate profit or loss
        profit_or_loss = trade_price - initial_price
        log_trade(symbol, 'sell', profit_or_loss)
        print(f"Sold {symbol} at {trade_price}. Profit/Loss: {profit_or_loss}")

# Example: Execute a trade and log performance
execute_trade('AAPL', 'buy', 150, None)
execute_trade('AAPL', 'sell', 155, 150)  # This results in a profit of $5

import csv

# Define CSV file to save trade logs
csv_file = 'trade_log.csv'

# Create or open the CSV file to append trades
def log_trade_to_csv(symbol, trade_type, price, profit_or_loss):
    with open(csv_file, mode='a', newline='') as file:
        writer = csv.writer(file)
        writer.writerow([symbol, trade_type, price, profit_or_loss])
    print(f"Logged trade to CSV: {symbol}, {trade_type}, {price}, {profit_or_loss}")

# Update the execute_trade function to include CSV logging
def execute_trade(symbol, trade_type, trade_price, initial_price=None):
    global total_profit, total_loss

    if trade_type == 'buy':
        # Simulate buy logic (You may have actual buy code here)
        print(f"Bought {symbol} at {trade_price}")
        logging.info(f"Bought {symbol} at {trade_price}")
        log_trade_to_csv(symbol, 'buy', trade_price, None)  # Log buy trade to CSV

    elif trade_type == 'sell':
        # Calculate profit or loss
        profit_or_loss = trade_price - initial_price
        log_trade(symbol, 'sell', profit_or_loss)
        print(f"Sold {symbol} at {trade_price}. Profit/Loss: {profit_or_loss}")
        log_trade_to_csv(symbol, 'sell', trade_price, profit_or_loss)  # Log sell trade to CSV

execute_trade('AAPL', 'buy', 150)
execute_trade('AAPL', 'sell', 155, 150)

AAPL, buy, 150, None
AAPL, sell, 155, 5

# Example trade executions
execute_trade('AAPL', 'buy', 150)
execute_trade('AAPL', 'sell', 155, 150)

def optimize_rsi(historical_data, rsi_windows, trade_amount):
    best_profit = float('-inf')
    best_window = None

    for window in rsi_windows:
        # Assume you have a function that calculates profit based on the RSI window
        total_profit = simulate_trading(historical_data, window, trade_amount)
        print(f'Testing RSI window: {window}, Total Profit: {total_profit}')

        if total_profit > best_profit:
            best_profit = total_profit
            best_window = window

    print(f'Best RSI window: {best_window} with profit: {best_profit}')
    return best_window

def execute_trade(symbol, trade_amount):
    global total_loss_today  # Assuming this variable is defined globally
    # Execute trading logic
    if total_loss_today >= daily_loss_limit:
        print("Daily loss limit reached. Halting trading for the day.")
        return  # Stop further trading
    # Continue with trade execution...

def log_performance_metrics():
    # Add more metrics as needed
    metrics = {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Sharpe Ratio': sharpe_ratio,
        'Avg Profit/Loss per Trade': avg_profit_loss,
        'Number of Trades': num_trades  # New metric
    }
    print(metrics)

try:
    # Your trading code here
except Exception as e:
    print(f"An error occurred: {e}")
    # Optionally log this error

def execute_trade(symbol, trade_amount):
    global total_loss_today  # Assuming this variable is defined globally
    try:
        # Your trading logic here
        price = get_live_data(symbol)  # Example function to get live data
        # Assuming you have a buy/sell decision based on your logic
        if should_buy(price):
            # Logic for buying
            print(f'Bought {symbol} at {price}')
        elif should_sell(price):
            # Logic for selling
            print(f'Sold {symbol} at {price}')

        # Update total loss if needed
        # total_loss_today += some_loss_amount  # Example of updating loss

    except Exception as e:
        print(f"An error occurred: {e}")
        # Optionally log this error

def log_trade(symbol, action, price, profit):
    with open('trade_log.csv', 'a') as f:
        f.write(f'{symbol},{action},{price},{profit}\n')

import logging

# Set up logging
logging.basicConfig(filename='trading_log.csv', level=logging.INFO, format='%(asctime)s,%(message)s')

def execute_trade(symbol, trade_amount):
    global total_loss_today
    try:
        price = get_live_data(symbol)
        if should_buy(price):
            logging.info(f'Bought {symbol} at {price}')
        elif should_sell(price):
            logging.info(f'Sold {symbol} at {price}')

        # Update total loss if needed

    except Exception as e:
        logging.error(f"An error occurred: {e}")

def should_sell(price, buy_price):
    stop_loss_price = buy_price * 0.95  # Sell if price drops 5%
    return price <= stop_loss_price

def backtest_strategy(historical_data):
    total_profit = 0
    for index, row in historical_data.iterrows():
        price = row['Close']
        # Implement your buy/sell logic here
        # Update total_profit accordingly
    return total_profit

def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit'] for trade in trades)
    total_loss = sum(trade['loss'] for trade in trades)
    win_rate = len([t for t in trades if t['profit'] > 0]) / len(trades) * 100 if trades else 0
    # Sharpe ratio and average profit/loss can be calculated similarly
    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        # Add other metrics here
    }

def calculate_moving_averages(data, short_window=20, long_window=50):
    data['Short_MA'] = data['Close'].rolling(window=short_window).mean()
    data['Long_MA'] = data['Close'].rolling(window=long_window).mean()

def should_buy_crossover(data):
    if data['Short_MA'].iloc[-1] > data['Long_MA'].iloc[-1]:
        return True
    return False

def should_sell_crossover(data):
    if data['Short_MA'].iloc[-1] < data['Long_MA'].iloc[-1]:
        return True
    return False

def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    data['MACD'] = data['Close'].ewm(span=short_window, adjust=False).mean() - data['Close'].ewm(span=long_window, adjust=False).mean()
    data['Signal_Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()

def should_buy_macd(data):
    if data['MACD'].iloc[-1] > data['Signal_Line'].iloc[-1]:
        return True
    return False

def should_sell_macd(data):
    if data['MACD'].iloc[-1] < data['Signal_Line'].iloc[-1]:
        return True
    return False

# Step 4: Implement Exit Strategies

# Define exit conditions
def should_exit_trade(current_price, entry_price, profit_target=1.05, stop_loss=0.95):
    """
    Check if the current price meets the exit conditions.

    Args:
    - current_price (float): The current price of the stock.
    - entry_price (float): The price at which the stock was bought.
    - profit_target (float): The price target for taking profits (default is 5% gain).
    - stop_loss (float): The price at which to cut losses (default is 5% loss).

    Returns:
    - bool: True if conditions are met for exiting the trade, False otherwise.
    """
    # Check for profit target
    if current_price >= entry_price * profit_target:
        print(f"Profit target reached. Current price: {current_price}, Entry price: {entry_price}")
        return True
    # Check for stop loss
    elif current_price <= entry_price * stop_loss:
        print(f"Stop loss triggered. Current price: {current_price}, Entry price: {entry_price}")
        return True
    return False

# Example usage in your trading loop
for symbol in symbols:
    if not trading_halted:
        # Fetch current price
        current_price = get_live_data(symbol)

        # Check if exit conditions are met for existing trades
        if symbol in open_trades:
            entry_price = open_trades[symbol]  # Retrieve the entry price
            if should_exit_trade(current_price, entry_price):
                # Logic to sell the stock and log the trade
                sell_stock(symbol, current_price)  # You'll need to implement this function
                del open_trades[symbol]  # Remove from open trades
        else:
            run_real_time_trading(symbol, trade_amount=5)  # $5 per trade example

import requests

# Function to get data for a specific symbol
def get_data_for_symbol(symbol):
    # Replace this with the appropriate URL or API endpoint
    url = f"https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol={symbol}&interval=1min&apikey={your_alpha_vantage_api_key}"
    response = requests.get(url)

    # Check if the request was successful
    if response.status_code == 200:
        data = response.json()
        # Access the latest price data
        return data['Time Series (1min)']
    else:
        print(f"Error fetching data for {symbol}: {response.status_code}")
        return None

def get_live_data(symbol):
    data = get_data_for_symbol(symbol)  # Fetch live data for the symbol
    if data:
        # Get the most recent timestamp and its corresponding price
        latest_timestamp = sorted(data.keys())[0]  # Get the latest timestamp
        return float(data[latest_timestamp]['1. open'])  # Accessing the opening price at the latest timestamp
    else:
        return None  # Return None if data fetching failed

def check_signals(symbol):
    price = get_live_data(symbol)  # Fetch current live price
    rsi = calculate_rsi(historical_data[symbol])  # Call your RSI calculation function

    # Example buy/sell conditions based on RSI
    if rsi < 30:
        print(f"Buy signal for {symbol} at {price}")
        return "buy"
    elif rsi > 70:
        print(f"Sell signal for {symbol} at {price}")
        return "sell"
    else:
        print(f"No action for {symbol}. Current price: {price}, RSI: {rsi}")
        return "hold"

for symbol in symbols:
    if not trading_halted:
        action = check_signals(symbol)  # Get the action based on signals
        current_price = get_live_data(symbol)  # Fetch current price

        if action == "buy":
            # Execute buy logic here using current_price
            print(f"Buying {symbol} at {current_price}")
            # Place the buy order code here...

        elif action == "sell":
            # Execute sell logic here using current_price
            print(f"Selling {symbol} at {current_price}")
            # Place the sell order code here...

# Define your Alpha Vantage API key
alpha_vantage_api_key = 'yLZzzY_8ZZ6FElsmmRjSHYvuUMSmxnFB'  # Use your actual API key here

def get_data_for_symbol(symbol):
    # Replace this with the appropriate URL or API endpoint
    url = f"https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol={symbol}&interval=1min&apikey={alpha_vantage_api_key}"
    response = requests.get(url)
    data = response.json()

    # Check for errors in the response
    if "Error Message" in data:
        print(f"Error retrieving data for {symbol}: {data['Error Message']}")
        return None

    # Convert the response into a DataFrame or handle it as needed
    time_series = data["Time Series (1min)"]
    df = pd.DataFrame.from_dict(time_series, orient='index')
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']

    # Convert index to datetime and change column types
    df.index = pd.to_datetime(df.index)
    df = df.astype(float)
    return df

def check_signals(symbol):
    # Fetch the current price
    price_data = get_data_for_symbol(symbol)

    if price_data is None:
        return None  # Handle cases where data is not available

    current_price = price_data['Close'].iloc[0]

    # Example logic for checking signals
    rsi = calculate_rsi(price_data)  # Calculate RSI using your function
    sma = price_data['Close'].rolling(window=20).mean().iloc[-1]  # Simple moving average

    # Example conditions
    if rsi < 30:  # Buy condition
        return 'buy'
    elif rsi > 70:  # Sell condition
        return 'sell'
    else:
        return 'hold'  # No action

for symbol in symbols:
    if not trading_halted:
        action = check_signals(symbol)  # Get the action based on signals
        current_price = get_live_data(symbol)  # Fetch current price

        if action == 'buy':
            # Execute buy trade
            execute_trade(symbol, current_price, 'buy', trade_amount)
            # Log the trade
            log_trade(symbol, 'buy', current_price, None)

        elif action == 'sell':
            # Execute sell trade
            execute_trade(symbol, current_price, 'sell', trade_amount)
            # Log the trade
            log_trade(symbol, 'sell', current_price, profit_loss)

        # Check if the daily loss limit has been reached
        if total_loss_today >= daily_loss_limit:
            print("Daily loss limit reached. Halting trading for the day.")
            trading_halted = True

import requests
import pandas as pd

def get_data_for_symbol(symbol):
    # API request URL
    url = f"https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol={symbol}&interval=1min&apikey={your_alpha_vantage_api_key}"

    try:
        response = requests.get(url)
        data = response.json()  # Convert response to JSON

        # Check if the API call was successful
        if "Time Series (1min)" not in data:
            print(f"Error retrieving data for {symbol}: {data.get('Note', 'Unknown error')}")
            return None  # Return None if the data is not available

        # Extract the time series data
        time_series = data["Time Series (1min)"]
        df = pd.DataFrame.from_dict(time_series, orient='index')
        df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']

        # Convert to numeric
        df = df.apply(pd.to_numeric, errors='coerce')
        df.index = pd.to_datetime(df.index)  # Convert the index to datetime

        return df  # Return the DataFrame with price data

    except Exception as e:
        print(f"An error occurred while fetching data for {symbol}: {e}")
        return None

def get_data_for_symbol(symbol):
    # Fetching data from Alpha Vantage
    url = f"https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol={symbol}&interval=1min&apikey={your_alpha_vantage_api_key}"
    response = requests.get(url)
    data = response.json()

    # Check if the response contains the expected key
    if "Time Series (1min)" not in data:
        print(f"Error fetching data for {symbol}: {data.get('Error Message', 'Unknown error')}")
        return None  # Return None if there's an error

    # Convert the response into a DataFrame
    time_series = data["Time Series (1min)"]
    df = pd.DataFrame.from_dict(time_series, orient='index')
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    df = df.astype(float)  # Convert data types to float for calculations
    return df

def check_signals(symbol):
    price_data = get_data_for_symbol(symbol)
    if price_data is None:
        return None  # Return if there's no data

    current_price = price_data['Close'].iloc[0]  # Get the most recent closing price
    rsi = calculate_rsi(price_data)  # Call your RSI calculation function

    if rsi < 30:
        return "buy"
    elif rsi > 70:
        return "sell"
    else:
        return "hold"

for symbol in symbols:
    if not trading_halted:
        action = check_signals(symbol)  # Get the action based on signals
        if action is None:
            continue  # Skip this iteration if there's no action to take

        current_price = get_live_data(symbol)  # Fetch current price
        # Now proceed with your trading logic based on the action

# Your Alpha Vantage API key
alpha_vantage_api_key = 'yLZzzY_8ZZ6FElsmmRjSHYvuUMSmxnFB'

def get_data_for_symbol(symbol):
    # Fetching data from Alpha Vantage
    url = f"https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol={symbol}&interval=1min&apikey={alpha_vantage_api_key}"
    response = requests.get(url)
    data = response.json()

    # Check if the response contains the expected key
    if "Time Series (1min)" not in data:
        print(f"Error fetching data for {symbol}: {data.get('Error Message', 'Unknown error')}")
        return None  # Return None if there's an error

    # Convert the response into a DataFrame
    time_series = data["Time Series (1min)"]
    df = pd.DataFrame.from_dict(time_series, orient='index')
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    df = df.astype(float)  # Convert data types to float for calculations
    return df

for symbol in symbols:
    if not trading_halted:
        action = check_signals(symbol)  # Get the action based on signals
        if action is None:
            continue  # Skip this iteration if there's no action to take

        current_price = get_live_data(symbol)  # Fetch current price
        # Proceed with your trading logic based on the action

def get_data_for_symbol(symbol):
    # Fetching data from Alpha Vantage
    url = f"https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol={symbol}&interval=1min&apikey={alpha_vantage_api_key}"
    response = requests.get(url)
    data = response.json()

    # Print the response for debugging
    print(f"Response for {symbol}: {data}")

    # Check if the response contains the expected key
    if "Time Series (1min)" not in data:
        error_message = data.get('Error Message', 'Unknown error')
        print(f"Error fetching data for {symbol}: {error_message}")
        return None  # Return None if there's an error

    # Convert the response into a DataFrame
    time_series = data["Time Series (1min)"]
    df = pd.DataFrame.from_dict(time_series, orient='index')
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    df = df.astype(float)  # Convert data types to float for calculations
    return df

for symbol in symbols:
    if not trading_halted:
        action = check_signals(symbol)  # Get the action based on signals
        if action is None:
            continue  # Skip this iteration if there's no action to take

        current_price = get_live_data(symbol)  # Fetch current price
        # Proceed with your trading logic based on the action

def check_signals(symbol):
    data = get_data_for_symbol(symbol)
    if data is None:
        return None  # Skip if there's no data

    # Calculate your indicators here (like RSI, SMA, etc.)
    rsi = calculate_rsi(data)  # Assuming you have this function defined
    # Add your other indicators calculations here...

    # Example signal logic
    if rsi < 30:
        return "buy"
    elif rsi > 70:
        return "sell"
    else:
        return "hold"

# Example for integration (assumes you have a function to place orders)
def place_order(symbol, action, amount):
    if action == "buy":
        # Code to buy the stock
        pass
    elif action == "sell":
        # Code to sell the stock
        pass

def run_real_time_trading(symbol, trade_amount):
    global total_loss_today  # Use the global variable for tracking losses
    current_price = get_live_data(symbol)

    # Check if exit conditions are met
    if symbol in trades:  # Assuming you have a dictionary of trades
        if check_exit_conditions(symbol, current_price):
            sell_price = current_price  # Get the sell price
            # Code to execute sell
            log_trade(symbol, "sell", sell_price, trades[symbol]['buy_price'])  # Log the trade

            total_profit = sell_price - trades[symbol]['buy_price']
            total_loss_today += max(0, -total_profit)  # Update daily loss

            del trades[symbol]  # Remove the trade from the active list

    # If not trading halted, check for signals
    action = check_signals(symbol)
    if action == "buy":
        # Code to execute buy
        log_trade(symbol, "buy", current_price, None)  # Log the trade

def check_signals(symbol):
    data = get_data_for_symbol(symbol)
    rsi = calculate_rsi(data)  # Assuming you have a calculate_rsi function
    current_price = data['Close'].iloc[0]  # Assuming 'Close' is the last column

    # Example trading signals based on RSI
    if rsi < 30:  # Buy signal
        print(f"Buy signal for {symbol} at {current_price}")
        return "buy"
    elif rsi > 70:  # Sell signal
        print(f"Sell signal for {symbol} at {current_price}")
        return "sell"
    else:
        return None  # Hold signal

# Initialize variables to track total profit/loss and learning insights
total_profit = 0
total_loss = 0
trades_executed = []

# Run the simulation over the past week
for date in historical_dates:  # Assuming historical_dates is a list of dates to simulate
    for symbol in symbols:
        # Fetch historical data for each symbol
        historical_data = fetch_historical_data(symbol, date)

        # Check trading signals and execute trades
        action = check_signals(symbol)  # This should return 'buy', 'sell', or 'hold'

        if action == 'buy':
            buy_price = historical_data['Close'].iloc[0]  # Example, get the first close price
            trades_executed.append((symbol, 'buy', buy_price, None))  # Log trade
            print(f"Bought {symbol} at {buy_price}")

        elif action == 'sell':
            sell_price = historical_data['Close'].iloc[-1]  # Example, get the last close price
            # Calculate profit/loss
            for trade in trades_executed:
                if trade[0] == symbol and trade[1] == 'buy':
                    profit = sell_price - trade[2]
                    total_profit += profit if profit > 0 else 0
                    total_loss += -profit if profit < 0 else 0
                    trades_executed.append((symbol, 'sell', sell_price, profit))  # Log trade
                    print(f"Sold {symbol} at {sell_price}. Profit/Loss: {profit}")
                    break

# Summary of results
print(f"\nTotal Profit: ${total_profit:.2f}")
print(f"Total Loss: ${total_loss:.2f}")
print(f"Net Profit: ${total_profit - total_loss:.2f}")

# Insights on learning
insights = {
    "Successful Strategies": [],
    "Areas for Improvement": []
}

# Example logic to determine insights based on trades
for trade in trades_executed:
    if trade[1] == 'sell' and trade[3] is not None:
        if trade[3] > 0:
            insights["Successful Strategies"].append(f"Sold {trade[0]} profitably.")
        else:
            insights["Areas for Improvement"].append(f"Consider analyzing the buy conditions for {trade[0]}.")

print("\nAI Insights on Learning:")
for key, value in insights.items():
    print(f"{key}: {', '.join(value) if value else 'None'}")

import pandas as pd
from datetime import datetime, timedelta

# Define the symbols you are trading
symbols = ['AAPL', 'GOOGL', 'MSFT']

# Define historical dates for the past week
end_date = datetime.now()
historical_dates = [(end_date - timedelta(days=i)).strftime('%Y-%m-%d') for i in range(7)]

# Initialize variables to track total profit/loss and learning insights
total_profit = 0
total_loss = 0
trades_executed = []

# Run the simulation over the past week
for date in historical_dates:
    for symbol in symbols:
        # Fetch historical data for each symbol
        historical_data = fetch_historical_data(symbol, date)  # You need to implement this function

        # Check trading signals and execute trades
        action = check_signals(symbol)  # You need to implement this function

        if action == 'buy':
            buy_price = historical_data['Close'].iloc[0]  # Example, get the first close price
            trades_executed.append((symbol, 'buy', buy_price, None))  # Log trade
            print(f"Bought {symbol} at {buy_price}")

        elif action == 'sell':
            sell_price = historical_data['Close'].iloc[-1]  # Example, get the last close price
            # Calculate profit/loss
            for trade in trades_executed:
                if trade[0] == symbol and trade[1] == 'buy':
                    profit = sell_price - trade[2]
                    total_profit += profit if profit > 0 else 0
                    total_loss += -profit if profit < 0 else 0
                    trades_executed.append((symbol, 'sell', sell_price, profit))  # Log trade
                    print(f"Sold {symbol} at {sell_price}. Profit/Loss: {profit}")
                    break

# Summary of results
print(f"\nTotal Profit: ${total_profit:.2f}")
print(f"Total Loss: ${total_loss:.2f}")
print(f"Net Profit: ${total_profit - total_loss:.2f}")

# Insights on learning
insights = {
    "Successful Strategies": [],
    "Areas for Improvement": []
}

# Example logic to determine insights based on trades
for trade in trades_executed:
    if trade[1] == 'sell' and trade[3] is not None:
        if trade[3] > 0:
            insights["Successful Strategies"].append(f"Sold {trade[0]} profitably.")
        else:
            insights["Areas for Improvement"].append(f"Consider analyzing the buy conditions for {trade[0]}.")

print("\nAI Insights on Learning:")
for key, value in insights.items():
    print(f"{key}: {', '.join(value) if value else 'None'}")

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf  # Make sure you have yfinance installed

# Define the symbols you are trading
symbols = ['AAPL', 'GOOGL', 'MSFT']

# Define historical dates for the past week
end_date = datetime.now()
historical_dates = [(end_date - timedelta(days=i)).strftime('%Y-%m-%d') for i in range(7)]

# Initialize variables to track total profit/loss and learning insights
total_profit = 0
total_loss = 0
trades_executed = []

def fetch_historical_data(symbol, date):
    """Fetch historical data for a given symbol on a specific date."""
    start_date = date
    end_date = (datetime.strptime(date, '%Y-%m-%d') + timedelta(days=1)).strftime('%Y-%m-%d')

    # Use yfinance to fetch the data
    data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
    if data.empty:
        print(f"No data found for {symbol} on {date}")
        return None
    return data

# Run the simulation over the past week
for date in historical_dates:
    for symbol in symbols:
        # Fetch historical data for each symbol
        historical_data = fetch_historical_data(symbol, date)  # Fetch data for the symbol on the specific date
        if historical_data is None:
            continue  # Skip to the next symbol if no data is found

        # Check trading signals and execute trades
        action = check_signals(symbol)  # Assuming you have this function implemented

        if action == 'buy':
            buy_price = historical_data['Close'].iloc[0]  # Example, get the first close price
            trades_executed.append((symbol, 'buy', buy_price, None))  # Log trade
            print(f"Bought {symbol} at {buy_price}")

        elif action == 'sell':
            sell_price = historical_data['Close'].iloc[-1]  # Example, get the last close price
            # Calculate profit/loss
            for trade in trades_executed:
                if trade[0] == symbol and trade[1] == 'buy':
                    profit = sell_price - trade[2]
                    total_profit += profit if profit > 0 else 0
                    total_loss += -profit if profit < 0 else 0
                    trades_executed.append((symbol, 'sell', sell_price, profit))  # Log trade
                    print(f"Sold {symbol} at {sell_price}. Profit/Loss: {profit}")
                    break

# Summary of results
print(f"\nTotal Profit: ${total_profit:.2f}")
print(f"Total Loss: ${total_loss:.2f}")
print(f"Net Profit: ${total_profit - total_loss:.2f}")

# Insights on learning
insights = {
    "Successful Strategies": [],
    "Areas for Improvement": []
}

# Example logic to determine insights based on trades
for trade in trades_executed:
    if trade[1] == 'sell' and trade[3] is not None:
        if trade[3] > 0:
            insights["Successful Strategies"].append(f"Sold {trade[0]} profitably.")
        else:
            insights["Areas for Improvement"].append(f"Consider analyzing the buy conditions for {trade[0]}.")

print("\nAI Insights on Learning:")
for key, value in insights.items():
    print(f"{key}: {', '.join(value) if value else 'None'}")

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Define the symbols you are trading
symbols = ['AAPL', 'GOOGL', 'MSFT']

# Define historical dates for the past week (change the range to avoid future dates)
end_date = datetime.now() - timedelta(days=1)  # Avoid today's date to prevent future fetch issues
historical_dates = [(end_date - timedelta(days=i)).strftime('%Y-%m-%d') for i in range(7)]

# Initialize variables to track total profit/loss and learning insights
total_profit = 0
total_loss = 0
trades_executed = []

def fetch_historical_data(symbol, date):
    """Fetch historical data for a given symbol on a specific date."""
    start_date = date
    end_date = (datetime.strptime(date, '%Y-%m-%d') + timedelta(days=1)).strftime('%Y-%m-%d')

    # Use yfinance to fetch the data
    data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
    if data.empty:
        print(f"No data found for {symbol} on {date}")
        return None
    return data

# Run the simulation over the past week
for date in historical_dates:
    for symbol in symbols:
        # Fetch historical data for each symbol
        historical_data = fetch_historical_data(symbol, date)  # Fetch data for the symbol on the specific date
        if historical_data is None:
            continue  # Skip to the next symbol if no data is found

        # Check trading signals and execute trades
        action = check_signals(symbol)  # Assuming you have this function implemented

        if action == 'buy':
            buy_price = historical_data['Close'].iloc[0]  # Example, get the first close price
            trades_executed.append((symbol, 'buy', buy_price, None))  # Log trade
            print(f"Bought {symbol} at {buy_price}")

        elif action == 'sell':
            sell_price = historical_data['Close'].iloc[-1]  # Example, get the last close price
            # Calculate profit/loss
            for trade in trades_executed:
                if trade[0] == symbol and trade[1] == 'buy':
                    profit = sell_price - trade[2]
                    total_profit += profit if profit > 0 else 0
                    total_loss += -profit if profit < 0 else 0
                    trades_executed.append((symbol, 'sell', sell_price, profit))  # Log trade
                    print(f"Sold {symbol} at {sell_price}. Profit/Loss: {profit}")
                    break

# Summary of results
print(f"\nTotal Profit: ${total_profit:.2f}")
print(f"Total Loss: ${total_loss:.2f}")
print(f"Net Profit: ${total_profit - total_loss:.2f}")

# Insights on learning
insights = {
    "Successful Strategies": [],
    "Areas for Improvement": []
}

# Example logic to determine insights based on trades
for trade in trades_executed:
    if trade[1] == 'sell' and trade[3] is not None:
        if trade[3] > 0:
            insights["Successful Strategies"].append(f"Sold {trade[0]} profitably.")
        else:
            insights["Areas for Improvement"].append(f"Consider analyzing the buy conditions for {trade[0]}.")

print("\nAI Insights on Learning:")
for key, value in insights.items():
    print(f"{key}: {', '.join(value) if value else 'None'}")

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Define the symbols you are trading
symbols = ['AAPL', 'GOOGL', 'MSFT']

# Define historical dates for the past week (avoid future dates)
end_date = datetime.now() - timedelta(days=1)
historical_dates = [(end_date - timedelta(days=i)).strftime('%Y-%m-%d') for i in range(7)]

# Initialize variables to track total profit/loss and learning insights
total_profit = 0
total_loss = 0
trades_executed = []

def fetch_historical_data(symbol, date):
    """Fetch historical data for a given symbol on a specific date using Yahoo Finance."""
    start_date = date
    end_date = (datetime.strptime(date, '%Y-%m-%d') + timedelta(days=1)).strftime('%Y-%m-%d')

    # Use yfinance to fetch the data
    try:
        data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
        if data.empty:
            print(f"No data found for {symbol} on {date}")
            return None
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol} on {date}: {e}")
        return None

# Run the simulation over the past week
for date in historical_dates:
    for symbol in symbols:
        # Fetch historical data for each symbol
        historical_data = fetch_historical_data(symbol, date)
        if historical_data is None:
            continue  # Skip to the next symbol if no data is found

        # Check trading signals and execute trades
        action = check_signals(symbol)  # Assuming you have this function implemented

        if action == 'buy':
            buy_price = historical_data['Close'].iloc[0]  # Get the first close price
            trades_executed.append((symbol, 'buy', buy_price, None))  # Log trade
            print(f"Bought {symbol} at {buy_price}")

        elif action == 'sell':
            sell_price = historical_data['Close'].iloc[-1]  # Get the last close price
            # Calculate profit/loss
            for trade in trades_executed:
                if trade[0] == symbol and trade[1] == 'buy':
                    profit = sell_price - trade[2]
                    total_profit += profit if profit > 0 else 0
                    total_loss += -profit if profit < 0 else 0
                    trades_executed.append((symbol, 'sell', sell_price, profit))  # Log trade
                    print(f"Sold {symbol} at {sell_price}. Profit/Loss: {profit}")
                    break

# Summary of results
print(f"\nTotal Profit: ${total_profit:.2f}")
print(f"Total Loss: ${total_loss:.2f}")
print(f"Net Profit: ${total_profit - total_loss:.2f}")

# Insights on learning
insights = {
    "Successful Strategies": [],
    "Areas for Improvement": []
}

# Example logic to determine insights based on trades
for trade in trades_executed:
    if trade[1] == 'sell' and trade[3] is not None:
        if trade[3] > 0:
            insights["Successful Strategies"].append(f"Sold {trade[0]} profitably.")
        else:
            insights["Areas for Improvement"].append(f"Consider analyzing the buy conditions for {trade[0]}.")

print("\nAI Insights on Learning:")
for key, value in insights.items():
    print(f"{key}: {', '.join(value) if value else 'None'}")

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Define the symbols you are trading
symbols = ['AAPL', 'GOOGL', 'MSFT']

# Define historical dates for the past week (avoid future dates)
end_date = datetime.now() - timedelta(days=1)
historical_dates = [(end_date - timedelta(days=i)).strftime('%Y-%m-%d') for i in range(7)]

# Initialize variables to track total profit/loss and learning insights
total_profit = 0
total_loss = 0
trades_executed = []

def fetch_historical_data(symbol, date):
    """Fetch historical data for a given symbol on a specific date using Yahoo Finance."""
    start_date = date
    end_date = (datetime.strptime(date, '%Y-%m-%d') + timedelta(days=1)).strftime('%Y-%m-%d')

    # Use yfinance to fetch the data
    try:
        data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
        if data.empty:
            print(f"No data found for {symbol} on {date}")
            return None
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol} on {date}: {e}")
        return None

# Run the simulation over the past week
for date in historical_dates:
    for symbol in symbols:
        # Fetch historical data for each symbol
        historical_data = fetch_historical_data(symbol, date)
        if historical_data is None:
            continue  # Skip to the next symbol if no data is found

        # Check trading signals and execute trades
        action = check_signals(symbol)  # Assuming you have this function implemented

        if action == 'buy':
            buy_price = historical_data['Close'].iloc[0]  # Get the first close price
            trades_executed.append((symbol, 'buy', buy_price, None))  # Log trade
            print(f"Bought {symbol} at {buy_price}")

        elif action == 'sell':
            sell_price = historical_data['Close'].iloc[-1]  # Get the last close price
            # Calculate profit/loss
            for trade in trades_executed:
                if trade[0] == symbol and trade[1] == 'buy':
                    profit = sell_price - trade[2]
                    total_profit += profit if profit > 0 else 0
                    total_loss += -profit if profit < 0 else 0
                    trades_executed.append((symbol, 'sell', sell_price, profit))  # Log trade
                    print(f"Sold {symbol} at {sell_price}. Profit/Loss: {profit}")
                    break

# Summary of results
print(f"\nTotal Profit: ${total_profit:.2f}")
print(f"Total Loss: ${total_loss:.2f}")
print(f"Net Profit: ${total_profit - total_loss:.2f}")

# Insights on learning
insights = {
    "Successful Strategies": [],
    "Areas for Improvement": []
}

# Example logic to determine insights based on trades
for trade in trades_executed:
    if trade[1] == 'sell' and trade[3] is not None:
        if trade[3] > 0:
            insights["Successful Strategies"].append(f"Sold {trade[0]} profitably.")
        else:
            insights["Areas for Improvement"].append(f"Consider analyzing the buy conditions for {trade[0]}.")

print("\nAI Insights on Learning:")
for key, value in insights.items():
    print(f"{key}: {', '.join(value) if value else 'None'}")

import yfinance as yf
import pandas as pd

# Define the top 25 stocks to trade
symbols = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'FB', 'BRK.B', 'JNJ', 'JPM', 'V',
           'PG', 'NVDA', 'HD', 'UNH', 'DIS', 'PYPL', 'NFLX', 'VZ', 'PEP', 'CMCSA',
           'INTC', 'CSCO', 'MRK', 'T', 'NKE']

def fetch_historical_data(symbol, start_date, end_date):
    """Fetch historical data from Yahoo Finance."""
    data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
    return data

def get_live_data(symbol):
    """Get the current price for a given stock."""
    data = yf.download(symbol, period='1d', interval='1m')
    if not data.empty:
        return data['Close'].iloc[-1]  # Get the last available price
    else:
        raise ValueError(f"No data found for {symbol}")

# Example of fetching historical data for a specific date range
historical_data = fetch_historical_data('AAPL', '2024-10-01', '2024-10-08')
print(historical_data)

# Loop through the top 25 stocks for trading
for symbol in symbols:
    current_price = get_live_data(symbol)
    # Additional trading logic here...

def get_live_data(symbol):
    """Get the current price for a given stock."""
    try:
        data = yf.download(symbol, period='1d', interval='1m')
        if not data.empty:
            return data['Close'].iloc[-1]  # Get the last available price
        else:
            raise ValueError(f"No data found for {symbol}")
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return None  # Return None to indicate failure to get the price

# Loop through the top 25 stocks for trading
for symbol in symbols:
    if not trading_halted:
        current_price = get_live_data(symbol)
        if current_price is None:
            continue  # Skip this symbol if there was an error retrieving data

        # Check trading signals and execute trades
        action = check_signals(symbol)  # Get the action based on signals

        if action == 'buy':
            # Execute buy logic here
            pass
        elif action == 'sell':
            # Execute sell logic here
            pass

import yfinance as yf
import pandas as pd
import numpy as np

# List of top 25 stocks
symbols = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'FB', 'NFLX', 'NVDA', 'BRK-B', 'JPM',
           'V', 'JNJ', 'WMT', 'PG', 'DIS', 'MA', 'VZ', 'PYPL', 'ADBE', 'CMCSA', 'INTC',
           'T', 'CSCO', 'XOM']

# Function to fetch live data
def get_live_data(symbol):
    try:
        data = yf.Ticker(symbol).history(period="1d")
        return data['Close'].iloc[-1]  # Get the last available price
    except Exception as e:
        print(f"Error fetching live data for {symbol}: {e}")
        return None

# Function to fetch historical data
def fetch_historical_data(symbol):
    try:
        data = yf.download(symbol, start="2023-10-01", end="2024-10-07", interval='1m')
        return data
    except Exception as e:
        print(f"Error fetching historical data for {symbol}: {e}")
        return None

# Function to calculate RSI
def calculate_rsi(data, window=14):
    if data is None or data.empty:
        print("No data available for RSI calculation.")
        return None

    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    average_gain = gain.rolling(window=window).mean()
    average_loss = loss.rolling(window=window).mean()

    rs = average_gain / average_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Function to check trading signals
def check_signals(symbol):
    historical_data = fetch_historical_data(symbol)
    rsi = calculate_rsi(historical_data)

    if rsi is None:
        return None  # Skip if RSI cannot be calculated

    if rsi < 30:
        return 'buy'  # Buy signal
    elif rsi > 70:
        return 'sell'  # Sell signal
    else:
        return 'hold'  # No action

# Example function for trading loop
def trading_loop():
    for symbol in symbols:
        current_price = get_live_data(symbol)
        if current_price is None:
            continue  # Skip this symbol if there was an error retrieving data

        action = check_signals(symbol)  # Get the action based on signals

        if action == 'buy':
            print(f"Buying {symbol} at {current_price}")
            # Implement buying logic here
        elif action == 'sell':
            print(f"Selling {symbol} at {current_price}")
            # Implement selling logic here

# Start trading loop
trading_loop()

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Define the symbols for the top 25 stocks
symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN', 'FB', 'NFLX', 'NVDA', 'DIS', 'ADBE', 'PYPL', 'CMCSA', 'INTC', 'CSCO', 'PEP', 'NFLX', 'NKE', 'V', 'MA', 'CRM', 'XOM', 'IBM', 'WMT', 'PFE']

# Define the historical dates (last week)
end_date = datetime.now()
start_date = end_date - timedelta(days=7)

# Initialize a variable to store performance metrics
performance_metrics = {
    'Total Profit': 0,
    'Total Loss': 0,
    'Win Rate': 0,
    'Avg Profit/Loss per Trade': 0,
}

# Function to fetch historical data
def fetch_historical_data(symbol, start, end):
    return yf.download(symbol, start=start, end=end, interval='1m')

# Loop through the top 25 stocks for trading
for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)
    if historical_data.empty:
        print(f"No data found for {symbol} in the specified date range.")
        continue

    # Implement your trading logic here based on historical data
    # For example:
    # Check trading signals and execute trades
    # Update performance metrics based on executed trades
    # Example: performance_metrics['Total Profit'] += profit_from_trade

# Calculate overall performance metrics
total_trades = performance_metrics['Total Profit'] + performance_metrics['Total Loss']
if total_trades > 0:
    performance_metrics['Win Rate'] = (performance_metrics['Total Profit'] / total_trades) * 100
    performance_metrics['Avg Profit/Loss per Trade'] = (performance_metrics['Total Profit'] + performance_metrics['Total Loss']) / total_trades

# Print performance metrics
print("Performance Metrics:", performance_metrics)

# Inside your trading logic
for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)
    if historical_data.empty:
        print(f"No data found for {symbol} in the specified date range.")
        continue

    action = check_signals(symbol)  # Get the action based on signals
    if action == 'buy':
        print(f"Buying signal for {symbol} at {current_price}")
        # Execute buy logic...
    elif action == 'sell':
        print(f"Selling signal for {symbol} at {current_price}")
        # Execute sell logic...
    else:
        print(f"No action for {symbol}. Current price: {current_price}")

def check_signals(symbol, start_date, end_date):
    historical_data = fetch_historical_data(symbol, start_date, end_date)
    if historical_data is None or historical_data.empty:
        print(f"No historical data found for {symbol}.")
        return None

    rsi = calculate_rsi(historical_data)

    # Example logic for buy/sell signals
    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    else:
        return None  # No action

for symbol in symbols:
    current_price = get_live_data(symbol)

    # Check trading signals and execute trades
    action = check_signals(symbol, start_date, end_date)  # Pass the start and end dates
    if action is None:
        continue  # Skip this iteration if there's no action to take

    if action == 'buy':
        print(f"Buying signal for {symbol} at {current_price}")
        # Execute buy logic...
    elif action == 'sell':
        print(f"Selling signal for {symbol} at {current_price}")
        # Execute sell logic...

def check_signals(symbol, start_date, end_date):
    historical_data = fetch_historical_data(symbol, start_date, end_date)
    if historical_data is None or historical_data.empty:
        print(f"No historical data found for {symbol}.")
        return None

    rsi = calculate_rsi(historical_data)

    # Assuming `calculate_rsi` returns a Series; get the last value
    current_rsi = rsi.iloc[-1] if not rsi.empty else None

    if current_rsi is None:
        print(f"RSI calculation failed for {symbol}.")
        return None

    # Example logic for buy/sell signals
    if current_rsi < 30:
        return 'buy'
    elif current_rsi > 70:
        return 'sell'
    else:
        return None  # No action

import pandas as pd
from datetime import datetime, timedelta

# Initialize a list to keep track of trades
trades = []

# Define the function to log trades
def log_trade(symbol, action, price, profit_loss):
    with open('trading_log.csv', 'a') as f:
        f.write(f"{symbol},{action},{price},{profit_loss}\n")  # Log the trade details

# Define the performance metrics calculation
def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit_loss'] for trade in trades if trade['profit_loss'] > 0)
    total_loss = sum(-trade['profit_loss'] for trade in trades if trade['profit_loss'] < 0)
    total_trades = len(trades)

    win_rate = (len([t for t in trades if t['profit_loss'] > 0]) / total_trades) * 100 if total_trades > 0 else 0
    avg_profit_loss = (total_profit - total_loss) / total_trades if total_trades > 0 else 0

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

# Example function for fetching historical data (implement this as per your requirements)
def fetch_historical_data(symbol, start_date, end_date):
    # Fetch data logic here...
    # Returning a placeholder DataFrame for the sake of example
    return pd.DataFrame()

# Example function for checking signals (implement this as per your requirements)
def check_signals(symbol, historical_data):
    # Check signals logic here...
    return 'buy'  # Placeholder action

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

    # Simulate trading logic
    action = check_signals(symbol, historical_data)  # Get the action based on signals
    current_price = get_live_data(symbol)  # Fetch current price

    if action == 'buy':
        profit_loss = None  # Will calculate this later on sell
        log_trade(symbol, 'buy', current_price, profit_loss)  # Log the buy trade
    elif action == 'sell':
        previous_buy_price = current_price  # Placeholder for the example
        profit_loss = current_price - previous_buy_price
        log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade

        trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate AI insights
def generate_ai_insights(trades):
    insights = []
    if len(trades) == 0:
        insights.append("No trades made this week.")
    else:
        insights.append(f"Total trades made: {len(trades)}")
        insights.append(f"Total profit: {performance_metrics['Total Profit']}")
        insights.append(f"Total loss: {performance_metrics['Total Loss']}")
        insights.append(f"Win rate: {performance_metrics['Win Rate']:.2f}%")
        insights.append(f"Average profit/loss per trade: {performance_metrics['Avg Profit/Loss per Trade']:.2f}")

    return insights

# Print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

import pandas as pd
from datetime import datetime, timedelta

# Initialize a list to keep track of trades
trades = []

# Define the function to log trades
def log_trade(symbol, action, price, profit_loss):
    with open('trading_log.csv', 'a') as f:
        f.write(f"{symbol},{action},{price},{profit_loss}\n")  # Log the trade details

# Define the performance metrics calculation
def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit_loss'] for trade in trades if trade['profit_loss'] > 0)
    total_loss = sum(-trade['profit_loss'] for trade in trades if trade['profit_loss'] < 0)
    total_trades = len(trades)

    win_rate = (len([t for t in trades if t['profit_loss'] > 0]) / total_trades) * 100 if total_trades > 0 else 0
    avg_profit_loss = (total_profit - total_loss) / total_trades if total_trades > 0 else 0

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

# Example function for fetching historical data (implement this as per your requirements)
def fetch_historical_data(symbol, start_date, end_date):
    # Placeholder implementation - replace with actual data fetching logic
    return pd.DataFrame()

# Example function for checking signals (implement this as per your requirements)
def check_signals(symbol, historical_data):
    # Check signals logic here...
    return 'buy'  # Placeholder action

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

# List of top stocks (example, adjust as needed)
symbols = ['AAPL', 'GOOGL', 'MSFT', 'FB']

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

        # Ensure we have data to work with
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        # Simulate trading logic
        action = check_signals(symbol, historical_data)  # Get the action based on signals
        current_price = get_live_data(symbol)  # Fetch current price

        if action == 'buy':
            profit_loss = None  # Will calculate this later on sell
            log_trade(symbol, 'buy', current_price, profit_loss)  # Log the buy trade
        elif action == 'sell':
            previous_buy_price = current_price  # Placeholder for the example
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade

            trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        continue  # Skip to the next symbol

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate AI insights
def generate_ai_insights(trades):
    insights = []
    if len(trades) == 0:
        insights.append("No trades made this week.")
    else:
        insights.append(f"Total trades made: {len(trades)}")
        insights.append(f"Total profit: {performance_metrics['Total Profit']}")
        insights.append(f"Total loss: {performance_metrics['Total Loss']}")
        insights.append(f"Win rate: {performance_metrics['Win Rate']:.2f}%")
        insights.append(f"Average profit/loss per trade: {performance_metrics['Avg Profit/Loss per Trade']:.2f}")

    return insights

# Print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

import yfinance as yf

def fetch_historical_data(symbol, start_date, end_date):
    # Fetch historical data using Yahoo Finance
    try:
        data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
        return data
    except Exception as e:
        print(f"Error fetching historical data for {symbol}: {e}")
        return pd.DataFrame()  # Return an empty DataFrame on error

test_data = fetch_historical_data('AAPL', '2024-10-01', '2024-10-07')
print(test_data)

# Ensure your imports and function definitions are above this

# Simulate the system check over a larger date range if needed
start_date = datetime.now() - timedelta(days=14)  # Adjusted to 14 days
end_date = datetime.now()

# List of top stocks
symbols = ['AAPL', 'GOOGL', 'MSFT', 'FB']

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)

        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        action = check_signals(symbol, historical_data)
        current_price = get_live_data(symbol)

        if action == 'buy':
            profit_loss = None
            log_trade(symbol, 'buy', current_price, profit_loss)
        elif action == 'sell':
            previous_buy_price = current_price  # Placeholder for the example
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)
            trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})

    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")

# Calculate and print performance metrics again
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate and print AI insights again
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

def fetch_historical_data(symbol, start_date, end_date):
    # Fetch daily data using Yahoo Finance
    try:
        data = yf.download(symbol, start=start_date, end=end_date, interval='1h')  # Change interval to '1h'
        return data
    except Exception as e:
        print(f"Error fetching historical data for {symbol}: {e}")
        return pd.DataFrame()  # Return an empty DataFrame on error

# Simulate the system check over the past week with hourly data
start_date = datetime.now() - timedelta(days=7)  # Adjusted to 7 days
end_date = datetime.now()

# List of top stocks (ensure these are actively trading)
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Removed 'FB' for this example

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)

        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        action = check_signals(symbol, historical_data)
        current_price = get_live_data(symbol)

        if action == 'buy':
            profit_loss = None
            log_trade(symbol, 'buy', current_price, profit_loss)
        elif action == 'sell':
            previous_buy_price = current_price  # Placeholder for the example
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)
            trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})

    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")

# Calculate and print performance metrics again
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate and print AI insights again
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

print(historical_data.head())  # This will display the first few rows of the historical data for verification

def check_signals(symbol, historical_data):
    # Calculate RSI or any other indicators
    rsi = calculate_rsi(historical_data)

    print(f"{symbol} - RSI: {rsi}")  # Debugging output to see RSI value

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Initialize a list to keep track of trades
trades = []

# Define the function to log trades
def log_trade(symbol, action, price, profit_loss):
    with open('trading_log.csv', 'a') as f:
        f.write(f"{symbol},{action},{price},{profit_loss}\n")  # Log the trade details

# Define the performance metrics calculation
def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit_loss'] for trade in trades if trade['profit_loss'] > 0)
    total_loss = sum(-trade['profit_loss'] for trade in trades if trade['profit_loss'] < 0)
    total_trades = len(trades)

    win_rate = (len([t for t in trades if t['profit_loss'] > 0]) / total_trades) * 100 if total_trades > 0 else 0
    avg_profit_loss = (total_profit - total_loss) / total_trades if total_trades > 0 else 0

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

# Function to fetch historical data from Yahoo Finance
def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
    return data

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the last RSI value

# Function to check trading signals
def check_signals(symbol, historical_data):
    rsi = calculate_rsi(historical_data)
    print(f"{symbol} - RSI: {rsi}")  # Debugging output

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

# List of top stocks (example, adjust as needed)
symbols = ['AAPL', 'GOOGL', 'MSFT', 'FB']

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

        # Ensure we have data to work with
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        # Simulate trading logic
        action = check_signals(symbol, historical_data)  # Get the action based on signals
        current_price = historical_data['Adj Close'].iloc[-1]  # Fetch last available price

        if action == 'buy':
            profit_loss = None  # Will calculate this later on sell
            log_trade(symbol, 'buy', current_price, profit_loss)  # Log the buy trade
        elif action == 'sell':
            previous_buy_price = current_price  # Placeholder for the example
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade

            trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        continue  # Skip to the next symbol

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate AI insights
def generate_ai_insights(trades):
    insights = []
    if len(trades) == 0:
        insights.append("No trades made this week.")
    else:
        insights.append(f"Total trades made: {len(trades)}")
        insights.append(f"Total profit: {performance_metrics['Total Profit']}")
        insights.append(f"Total loss: {performance_metrics['Total Loss']}")
        insights.append(f"Win rate: {performance_metrics['Win Rate']:.2f}%")
        insights.append(f"Average profit/loss per trade: {performance_metrics['Avg Profit/Loss per Trade']:.2f}")

    return insights

# Print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Initialize a list to keep track of trades
trades = []

# Define the function to log trades
def log_trade(symbol, action, price, profit_loss):
    with open('trading_log.csv', 'a') as f:
        f.write(f"{symbol},{action},{price},{profit_loss}\n")  # Log the trade details

# Define the performance metrics calculation
def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit_loss'] for trade in trades if trade['profit_loss'] > 0)
    total_loss = sum(-trade['profit_loss'] for trade in trades if trade['profit_loss'] < 0)
    total_trades = len(trades)

    win_rate = (len([t for t in trades if t['profit_loss'] > 0]) / total_trades) * 100 if total_trades > 0 else 0
    avg_profit_loss = (total_profit - total_loss) / total_trades if total_trades > 0 else 0

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

# Function to fetch historical data from Yahoo Finance
def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
    return data

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the last RSI value

# Function to check trading signals
def check_signals(symbol, historical_data):
    rsi = calculate_rsi(historical_data)
    print(f"{symbol} - RSI: {rsi}")  # Debugging output

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

# List of top stocks (example, adjust as needed)
symbols = ['AAPL', 'GOOGL', 'MSFT', 'FB']

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

        # Ensure we have data to work with
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        # Simulate trading logic
        action = check_signals(symbol, historical_data)  # Get the action based on signals
        current_price = historical_data['Adj Close'].iloc[-1]  # Fetch last available price

        if action == 'buy':
            profit_loss = None  # Will calculate this later on sell
            log_trade(symbol, 'buy', current_price, profit_loss)  # Log the buy trade
            print(f"Buying {symbol} at {current_price}")
        elif action == 'sell':
            previous_buy_price = current_price  # Placeholder for the example
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
            trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
            print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")

    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        continue  # Skip to the next symbol

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate AI insights
def generate_ai_insights(trades):
    insights = []
    if len(trades) == 0:
        insights.append("No trades made this week.")
    else:
        insights.append(f"Total trades made: {len(trades)}")
        insights.append(f"Total profit: {performance_metrics['Total Profit']}")
        insights.append(f"Total loss: {performance_metrics['Total Loss']}")
        insights.append(f"Win rate: {performance_metrics['Win Rate']:.2f}%")
        insights.append(f"Average profit/loss per trade: {performance_metrics['Avg Profit/Loss per Trade']:.2f}")

    return insights

# Print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

def get_data_for_symbol(symbol):
    try:
        # Attempt to fetch data from Yahoo Finance
        data = yf.download(symbol, period='7d', interval='1m')  # Fetch 1-minute data for the past week
        if data.empty:
            raise ValueError(f"No data found for {symbol}")
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return None  # Return None if there's an error

def get_live_data(symbol):
    try:
        data = get_data_for_symbol(symbol)
        if data is not None:
            return data['Close'].iloc[-1]  # Get the last available price
        else:
            raise ValueError(f"No live data available for {symbol}")
    except Exception as e:
        print(f"Error fetching live data for {symbol}: {e}")
        return None  # Return None if there's an error

# Initialize daily trading variables
daily_budget = 200  # Maximum budget per day
daily_loss_limit = 50  # Maximum loss per day
total_loss_today = 0  # Track total loss for today
trade_amount = 5  # Fixed trade amount

def execute_trade(symbol, action, price):
    global daily_budget, total_loss_today, trade_amount  # Use global variables

    if action == 'buy':
        if daily_budget >= trade_amount:  # Check if there’s enough budget for the trade
            shares_to_buy = trade_amount // price  # Calculate number of shares to buy
            total_cost = shares_to_buy * price
            log_trade(symbol, 'buy', price, None)  # Log the buy trade
            daily_budget -= total_cost  # Deduct from daily budget
            print(f"Buying {shares_to_buy} shares of {symbol} at {price}, total cost: {total_cost}")

    elif action == 'sell':
        # Logic for selling shares
        # Assuming you have some way to determine the previous buy price
        previous_buy_price = price  # Replace with actual buy price logic
        profit_loss = price - previous_buy_price  # Calculate profit/loss
        log_trade(symbol, 'sell', price, profit_loss)  # Log the sell trade

        if profit_loss < 0:
            total_loss_today += abs(profit_loss)  # Track loss for today
            if total_loss_today >= daily_loss_limit:
                print("Daily loss limit reached. Halting trading for the day.")
                return  # Halts further trading for the day

        print(f"Selling shares of {symbol} at {price}, Profit/Loss: {profit_loss}")

# Update your trading logic to use execute_trade
for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)

        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        action = check_signals(symbol, historical_data)  # Get the action based on signals
        current_price = get_live_data(symbol)  # Fetch current price

        if action == 'buy':
            execute_trade(symbol, 'buy', current_price)  # Execute buy trade
        elif action == 'sell':
            execute_trade(symbol, 'sell', current_price)  # Execute sell trade

    except Exception as e:
        print(f"Error processing {symbol}: {e}")

import yfinance as yf
from datetime import datetime, timedelta
import pandas as pd

# Define the symbols for the top 25 stocks (removing FB for this example)
symbols = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'NFLX', 'NVDA', 'BRK-B', 'JPM',
           'V', 'JNJ', 'WMT', 'PG', 'DIS', 'MA', 'VZ', 'PYPL', 'ADBE', 'CMCSA',
           'INTC', 'T', 'CSCO', 'XOM']

def fetch_historical_data(symbol, start_date, end_date):
    """Fetch historical data using Yahoo Finance."""
    try:
        data = yf.download(symbol, start=start_date, end=end_date, interval='1h')  # Change interval to '1h'
        if data.empty:
            raise ValueError(f"No historical data found for {symbol}")
        return data
    except Exception as e:
        print(f"Error fetching historical data for {symbol}: {e}")
        return pd.DataFrame()  # Return an empty DataFrame on error

def get_live_data(symbol):
    """Get the current price for a given stock."""
    try:
        data = yf.download(symbol, period='1d', interval='1m')
        if not data.empty:
            return data['Close'].iloc[-1]  # Get the last available price
        else:
            raise ValueError(f"No data found for {symbol}")
    except Exception as e:
        print(f"Error fetching live data for {symbol}: {e}")
        return None  # Return None if there's an error

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

trades = []  # Initialize a list to keep track of trades
performance_metrics = {
    'Total Profit': 0,
    'Total Loss': 0,
    'Win Rate': 0,
    'Avg Profit/Loss per Trade': 0,
}

for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
    if historical_data.empty:
        print(f"No historical data found for {symbol}. Skipping...")
        continue

    # Simulate trading logic
    action = check_signals(symbol, historical_data)  # Get the action based on signals
    current_price = get_live_data(symbol)  # Fetch current price

    if action == 'buy':
        profit_loss = None  # Will calculate this later on sell
        log_trade(symbol, 'buy', current_price, profit_loss)  # Log the buy trade
        print(f"Buying {symbol} at {current_price}")
    elif action == 'sell':
        previous_buy_price = current_price  # Placeholder for the example
        profit_loss = current_price - previous_buy_price
        log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
        trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
        print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate and print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

# Define a better selling strategy based on price movements
def execute_trade(symbol, action, current_price, previous_buy_price=None):
    if action == 'buy':
        print(f"Buying {symbol} at {current_price}")
        # Log the buy trade logic
        log_trade(symbol, 'buy', current_price, None)
    elif action == 'sell' and previous_buy_price is not None:
        profit_loss = current_price - previous_buy_price
        print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
        log_trade(symbol, 'sell', current_price, profit_loss)
        return profit_loss
    return 0

# Update your loop for checking signals and executing trades
for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)
    if historical_data.empty:
        print(f"No historical data found for {symbol}. Skipping...")
        continue

    action = check_signals(symbol, historical_data)
    current_price = get_live_data(symbol)

    if action == 'buy':
        execute_trade(symbol, action, current_price)
    elif action == 'sell':
        previous_buy_price = ...  # Retrieve the price from a previous buy action
        execute_trade(symbol, action, current_price, previous_buy_price)

# Initialize a dictionary to track buy prices for each stock
buy_prices = {}

# Define the function to execute trades
def execute_trade(symbol, action, current_price):
    if action == 'buy':
        print(f"Buying {symbol} at {current_price}")
        log_trade(symbol, 'buy', current_price, None)
        buy_prices[symbol] = current_price  # Store the buy price
    elif action == 'sell':
        if symbol in buy_prices:  # Ensure there's a buy price recorded
            previous_buy_price = buy_prices[symbol]
            profit_loss = current_price - previous_buy_price
            print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
            log_trade(symbol, 'sell', current_price, profit_loss)
            # Optionally remove the symbol from buy_prices after selling
            del buy_prices[symbol]  # Remove from the dictionary after selling
        else:
            print(f"No buy price recorded for {symbol}. Cannot sell.")

# Updated loop for checking signals and executing trades
for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)
    if historical_data.empty:
        print(f"No historical data found for {symbol}. Skipping...")
        continue

    action = check_signals(symbol, historical_data)
    current_price = get_live_data(symbol)

    if action == 'buy':
        execute_trade(symbol, action, current_price)
    elif action == 'sell':
        execute_trade(symbol, action, current_price)

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Initialize a list to keep track of trades and a dictionary to store buy prices
trades = []
buy_prices = {}

# Define the function to log trades
def log_trade(symbol, action, price, profit_loss):
    with open('trading_log.csv', 'a') as f:
        f.write(f"{symbol},{action},{price},{profit_loss}\n")  # Log the trade details

# Define the performance metrics calculation
def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit_loss'] for trade in trades if trade['profit_loss'] > 0)
    total_loss = sum(-trade['profit_loss'] for trade in trades if trade['profit_loss'] < 0)
    total_trades = len(trades)

    win_rate = (len([t for t in trades if t['profit_loss'] > 0]) / total_trades) * 100 if total_trades > 0 else 0
    avg_profit_loss = (total_profit - total_loss) / total_trades if total_trades > 0 else 0

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

# Function to fetch historical data from Yahoo Finance
def fetch_historical_data(symbol, start_date, end_date):
    return yf.download(symbol, start=start_date, end=end_date, interval='1m')

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the last RSI value

# Function to check trading signals
def check_signals(symbol, historical_data):
    rsi = calculate_rsi(historical_data)
    print(f"{symbol} - RSI: {rsi}")  # Debugging output

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

# List of top stocks (example, adjust as needed)
symbols = ['AAPL', 'GOOGL', 'MSFT', 'FB']

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

        # Ensure we have data to work with
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        # Simulate trading logic
        action = check_signals(symbol, historical_data)  # Get the action based on signals
        current_price = historical_data['Adj Close'].iloc[-1]  # Fetch last available price

        if action == 'buy':
            print(f"Buying {symbol} at {current_price}")
            log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
            buy_prices[symbol] = current_price  # Store the buy price
        elif action == 'sell':
            if symbol in buy_prices:  # Ensure there's a buy price recorded
                previous_buy_price = buy_prices[symbol]
                profit_loss = current_price - previous_buy_price
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
                trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
                del buy_prices[symbol]  # Remove from buy prices after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        continue  # Skip to the next symbol

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate AI insights
def generate_ai_insights(trades):
    insights = []
    if len(trades) == 0:
        insights.append("No trades made this week.")
    else:
        insights.append(f"Total trades made: {len(trades)}")
        insights.append(f"Total profit: {performance_metrics['Total Profit']}")
        insights.append(f"Total loss: {performance_metrics['Total Loss']}")
        insights.append(f"Win rate: {performance_metrics['Win Rate']:.2f}%")
        insights.append(f"Average profit/loss per trade: {performance_metrics['Avg Profit/Loss per Trade']:.2f}")

    return insights

# Print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

# ... [Keep previous imports and function definitions]

# Modify the trading loop to include selling logic
for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        # Get current price
        current_price = historical_data['Adj Close'].iloc[-1]  # Fetch last available price

        # Check signals
        action = check_signals(symbol, historical_data)  # Get the action based on signals

        if action == 'buy':
            print(f"Buying {symbol} at {current_price}")
            log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
            buy_prices[symbol] = current_price  # Store the buy price
        elif action == 'sell':
            if symbol in buy_prices:  # Ensure there's a buy price recorded
                previous_buy_price = buy_prices[symbol]
                profit_loss = current_price - previous_buy_price
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
                trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
                del buy_prices[symbol]  # Remove from buy prices after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate and print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Initialize a list to keep track of trades and buy prices
trades = []
buy_prices = {}  # Dictionary to keep track of buy prices

# Define the function to log trades
def log_trade(symbol, action, price, profit_loss):
    with open('trading_log.csv', 'a') as f:
        f.write(f"{symbol},{action},{price},{profit_loss}\n")  # Log the trade details

# Define the performance metrics calculation
def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit_loss'] for trade in trades if trade['profit_loss'] > 0)
    total_loss = sum(-trade['profit_loss'] for trade in trades if trade['profit_loss'] < 0)
    total_trades = len(trades)

    win_rate = (len([t for t in trades if t['profit_loss'] > 0]) / total_trades) * 100 if total_trades > 0 else 0
    avg_profit_loss = (total_profit - total_loss) / total_trades if total_trades > 0 else 0

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

# Function to fetch historical data from Yahoo Finance
def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
    return data

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the last RSI value

# Function to check trading signals
def check_signals(symbol, historical_data):
    rsi = calculate_rsi(historical_data)
    print(f"{symbol} - RSI: {rsi}")  # Debugging output

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

# List of top stocks (example, adjust as needed)
symbols = ['AAPL', 'GOOGL', 'MSFT', 'FB']

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

        # Ensure we have data to work with
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        # Simulate trading logic
        action = check_signals(symbol, historical_data)  # Get the action based on signals
        current_price = historical_data['Adj Close'].iloc[-1]  # Fetch last available price

        if action == 'buy':
            print(f"Buying {symbol} at {current_price}")
            log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
            buy_prices[symbol] = current_price  # Store the buy price
        elif action == 'sell':
            if symbol in buy_prices:  # Ensure there's a buy price recorded
                previous_buy_price = buy_prices[symbol]
                profit_loss = current_price - previous_buy_price
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
                trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
                del buy_prices[symbol]  # Remove from buy prices after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate AI insights
def generate_ai_insights(trades):
    insights = []
    if len(trades) == 0:
        insights.append("No trades made this week.")
    else:
        insights.append(f"Total trades made: {len(trades)}")
        insights.append(f"Total profit: {performance_metrics['Total Profit']}")
        insights.append(f"Total loss: {performance_metrics['Total Loss']}")
        insights.append(f"Win rate: {performance_metrics['Win Rate']:.2f}%")
        insights.append(f"Average profit/loss per trade: {performance_metrics['Avg Profit/Loss per Trade']:.2f}")

    return insights

# Print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Initialize a list to keep track of trades and buy prices
trades = []
buy_prices = {}  # Dictionary to keep track of buy prices

# Define the function to log trades
def log_trade(symbol, action, price, profit_loss):
    with open('trading_log.csv', 'a') as f:
        f.write(f"{symbol},{action},{price},{profit_loss}\n")  # Log the trade details

# Define the performance metrics calculation
def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit_loss'] for trade in trades if trade['profit_loss'] > 0)
    total_loss = sum(-trade['profit_loss'] for trade in trades if trade['profit_loss'] < 0)
    total_trades = len(trades)

    win_rate = (len([t for t in trades if t['profit_loss'] > 0]) / total_trades) * 100 if total_trades > 0 else 0
    avg_profit_loss = (total_profit - total_loss) / total_trades if total_trades > 0 else 0

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

# Function to fetch historical data from Yahoo Finance
def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
    return data

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the last RSI value

# Function to check trading signals
def check_signals(symbol, historical_data):
    rsi = calculate_rsi(historical_data)
    print(f"{symbol} - RSI: {rsi}")  # Debugging output

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

# List of top stocks (example, adjust as needed)
symbols = ['AAPL', 'GOOGL', 'MSFT', 'FB']

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

        # Ensure we have data to work with
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        # Simulate trading logic
        action = check_signals(symbol, historical_data)  # Get the action based on signals
        current_price = historical_data['Adj Close'].iloc[-1]  # Fetch last available price

        if action == 'buy':
            print(f"Buying {symbol} at {current_price}")
            log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
            buy_prices[symbol] = current_price  # Store the buy price
        elif action == 'sell':
            if symbol in buy_prices:  # Ensure there's a buy price recorded
                previous_buy_price = buy_prices[symbol]
                profit_loss = current_price - previous_buy_price
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
                trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
                del buy_prices[symbol]  # Remove from buy prices after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate AI insights
def generate_ai_insights(trades):
    insights = []
    if len(trades) == 0:
        insights.append("No trades made this week.")
    else:
        insights.append(f"Total trades made: {len(trades)}")
        insights.append(f"Total profit: {performance_metrics['Total Profit']}")
        insights.append(f"Total loss: {performance_metrics['Total Loss']}")
        insights.append(f"Win rate: {performance_metrics['Win Rate']:.2f}%")
        insights.append(f"Average profit/loss per trade: {performance_metrics['Avg Profit/Loss per Trade']:.2f}")

    return insights

# Print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Initialize a list to keep track of trades and buy prices
trades = []
buy_prices = {}  # Dictionary to keep track of buy prices

# Define the function to log trades
def log_trade(symbol, action, price, profit_loss):
    with open('trading_log.csv', 'a') as f:
        f.write(f"{symbol},{action},{price},{profit_loss}\n")  # Log the trade details

# Define the performance metrics calculation
def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit_loss'] for trade in trades if trade['profit_loss'] > 0)
    total_loss = sum(-trade['profit_loss'] for trade in trades if trade['profit_loss'] < 0)
    total_trades = len(trades)

    win_rate = (len([t for t in trades if t['profit_loss'] > 0]) / total_trades) * 100 if total_trades > 0 else 0
    avg_profit_loss = (total_profit - total_loss) / total_trades if total_trades > 0 else 0

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

# Function to fetch historical data from Yahoo Finance
def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
    return data

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the last RSI value

# Function to check trading signals
def check_signals(symbol, historical_data):
    rsi = calculate_rsi(historical_data)
    print(f"{symbol} - RSI: {rsi}")  # Debugging output

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

# List of top stocks (example, adjust as needed)
symbols = ['AAPL', 'GOOGL', 'MSFT', 'FB']

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

        # Ensure we have data to work with
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        # Simulate trading logic
        action = check_signals(symbol, historical_data)  # Get the action based on signals
        current_price = historical_data['Adj Close'].iloc[-1]  # Fetch last available price

        if action == 'buy':
            print(f"Buying {symbol} at {current_price}")
            log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
            buy_prices[symbol] = current_price  # Store the buy price
        elif action == 'sell':
            if symbol in buy_prices:  # Ensure there's a buy price recorded
                previous_buy_price = buy_prices[symbol]
                profit_loss = current_price - previous_buy_price
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
                trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
                del buy_prices[symbol]  # Remove from buy prices after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate AI insights
def generate_ai_insights(trades):
    insights = []
    if len(trades) == 0:
        insights.append("No trades made this week.")
    else:
        insights.append(f"Total trades made: {len(trades)}")
        insights.append(f"Total profit: {performance_metrics['Total Profit']}")
        insights.append(f"Total loss: {performance_metrics['Total Loss']}")
        insights.append(f"Win rate: {performance_metrics['Win Rate']:.2f}%")
        insights.append(f"Average profit/loss per trade: {performance_metrics['Avg Profit/Loss per Trade']:.2f}")

    return insights

# Print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf

# Initialize a list to keep track of trades and buy prices
trades = []
buy_prices = {}  # Dictionary to keep track of buy prices

# Define the function to log trades
def log_trade(symbol, action, price, profit_loss):
    with open('trading_log.csv', 'a') as f:
        f.write(f"{symbol},{action},{price},{profit_loss}\n")  # Log the trade details

# Define the performance metrics calculation
def calculate_performance_metrics(trades):
    total_profit = sum(trade['profit_loss'] for trade in trades if trade['profit_loss'] > 0)
    total_loss = sum(-trade['profit_loss'] for trade in trades if trade['profit_loss'] < 0)
    total_trades = len(trades)

    win_rate = (len([t for t in trades if t['profit_loss'] > 0]) / total_trades) * 100 if total_trades > 0 else 0
    avg_profit_loss = (total_profit - total_loss) / total_trades if total_trades > 0 else 0

    return {
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Win Rate': win_rate,
        'Avg Profit/Loss per Trade': avg_profit_loss
    }

# Function to fetch historical data from Yahoo Finance
def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
    return data

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the last RSI value

# Function to check trading signals
def check_signals(symbol, historical_data):
    rsi = calculate_rsi(historical_data)
    print(f"{symbol} - RSI: {rsi}")  # Debugging output

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

# Simulating the system check over the past week
start_date = datetime.now() - timedelta(days=7)
end_date = datetime.now()

# List of top stocks (example, adjust as needed)
symbols = ['AAPL', 'GOOGL', 'MSFT', 'FB']

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

        # Ensure we have data to work with
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        # Simulate trading logic
        action = check_signals(symbol, historical_data)  # Get the action based on signals
        current_price = historical_data['Adj Close'].iloc[-1]  # Fetch last available price

        if action == 'buy':
            print(f"Buying {symbol} at {current_price}")
            log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
            buy_prices[symbol] = current_price  # Store the buy price
        elif action == 'sell':
            if symbol in buy_prices:  # Ensure there's a buy price recorded
                previous_buy_price = buy_prices[symbol]
                profit_loss = current_price - previous_buy_price
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
                trades.append({'symbol': symbol, 'action': 'sell', 'profit_loss': profit_loss})
                del buy_prices[symbol]  # Remove from buy prices after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")

# Calculate and print performance metrics
performance_metrics = calculate_performance_metrics(trades)
print("Performance Metrics:", performance_metrics)

# Generate AI insights
def generate_ai_insights(trades):
    insights = []
    if len(trades) == 0:
        insights.append("No trades made this week.")
    else:
        insights.append(f"Total trades made: {len(trades)}")
        insights.append(f"Total profit: {performance_metrics['Total Profit']}")
        insights.append(f"Total loss: {performance_metrics['Total Loss']}")
        insights.append(f"Win rate: {performance_metrics['Win Rate']:.2f}%")
        insights.append(f"Average profit/loss per trade: {performance_metrics['Avg Profit/Loss per Trade']:.2f}")

    return insights

# Print AI insights
ai_insights = generate_ai_insights(trades)
print("AI Insights:")
for insight in ai_insights:
    print("-", insight)

import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf
import matplotlib.pyplot as plt

# Define the symbols for the top 25 stocks
symbols = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'FB', 'NFLX', 'NVDA', 'DIS', 'ADBE',
           'PYPL', 'CMCSA', 'INTC', 'CSCO', 'PEP', 'NKE', 'V', 'MA', 'CRM', 'XOM', 'IBM',
           'WMT', 'PFE']

# Function to fetch historical data from Yahoo Finance
def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1d')
    return data

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Initialize a DataFrame to store RSI values
rsi_data = {}

# Set the date range for the analysis
start_date = datetime.now() - timedelta(days=30)
end_date = datetime.now()

# Loop through the symbols and calculate RSI
for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)

    if historical_data.empty:
        print(f"No data found for {symbol}. Skipping...")
        continue

    rsi = calculate_rsi(historical_data)
    rsi_data[symbol] = rsi.iloc[-1]  # Store the most recent RSI value

# Convert the RSI data to a DataFrame for visualization
rsi_df = pd.DataFrame(rsi_data.items(), columns=['Symbol', 'RSI'])
print(rsi_df)

# Visualize the RSI values
plt.figure(figsize=(12, 6))
plt.bar(rsi_df['Symbol'], rsi_df['RSI'], color='skyblue')
plt.axhline(30, color='red', linestyle='--', label='Buy Threshold (30)')
plt.axhline(70, color='green', linestyle='--', label='Sell Threshold (70)')
plt.title('Current RSI Values for Top Stocks')
plt.xlabel('Stock Symbol')
plt.ylabel('RSI Value')
plt.xticks(rotation=45)
plt.legend()
plt.tight_layout()
plt.show()

def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the last RSI value

def optimize_rsi(symbol, historical_data, window_sizes):
    best_window = None
    best_profit = float('-inf')  # Initialize to negative infinity for comparison

    for window in window_sizes:
        print(f"Testing RSI window: {window}")

        # Perform trading logic with the specified RSI window
        trades = []
        for index in range(1, len(historical_data)):
            current_price = historical_data['Adj Close'].iloc[index]
            rsi = calculate_rsi(historical_data.iloc[:index + 1], window)

            if rsi < 30:  # Buy condition
                trades.append({'symbol': symbol, 'action': 'buy', 'price': current_price})
            elif rsi > 70:  # Sell condition
                if trades:  # Check if there's an open buy
                    buy_price = trades[-1]['price']  # Get last buy price
                    profit_loss = current_price - buy_price
                    trades.append({'symbol': symbol, 'action': 'sell', 'price': current_price, 'profit_loss': profit_loss})

        # Calculate total profit for this window
        total_profit = sum(trade['profit_loss'] for trade in trades if 'profit_loss' in trade)

        print(f"Total profit for RSI window {window}: ${total_profit:.2f}")

        # Check if this is the best window
        if total_profit > best_profit:
            best_profit = total_profit
            best_window = window

    print(f"Best RSI window: {best_window} with total profit: ${best_profit:.2f}")
    return best_window

# Example usage
window_sizes = [10, 14, 20, 25]  # Different window sizes to test
best_window = optimize_rsi('AAPL', historical_data, window_sizes)

# Function to check trading signals with optimized RSI window
def check_signals(symbol, historical_data):
    rsi = calculate_rsi(historical_data, window=10)  # Use the optimized RSI window
    print(f"{symbol} - RSI: {rsi}")  # Debugging output

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

# Example of how to incorporate this in your trading loop
for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
    if historical_data.empty:
        print(f"No historical data found for {symbol}. Skipping...")
        continue

    action = check_signals(symbol, historical_data)  # Get the action based on signals
    current_price = get_live_data(symbol)  # Fetch current price

    if action == 'buy':
        profit_loss = None  # To be calculated on sell
        log_trade(symbol, 'buy', current_price, profit_loss)  # Log buy trade
    elif action == 'sell':
        # Logic for selling (need to track previous buy price)
        previous_buy_price = ...  # Retrieve the buy price from your storage
        profit_loss = current_price - previous_buy_price
        log_trade(symbol, 'sell', current_price, profit_loss)  # Log sell trade

# Initialize a dictionary to track buy prices
buy_prices = {}

# Function to check trading signals with optimized RSI window
def check_signals(symbol, historical_data):
    rsi = calculate_rsi(historical_data)
    print(f"{symbol} - RSI: {rsi}")  # Debugging output

    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    return None

# Example of how to incorporate this in your trading loop
for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
    if historical_data.empty:
        print(f"No historical data found for {symbol}. Skipping...")
        continue

    action = check_signals(symbol, historical_data)  # Get the action based on signals
    current_price = get_live_data(symbol)  # Fetch current price

    if action == 'buy':
        # Log buy trade and store the buy price
        log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
        buy_prices[symbol] = current_price  # Store the buy price
        print(f"Buying {symbol} at {current_price}")
    elif action == 'sell':
        if symbol in buy_prices:  # Check if the buy price is recorded
            previous_buy_price = buy_prices[symbol]  # Retrieve the buy price
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
            print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
            del buy_prices[symbol]  # Remove the stock from tracking after selling
        else:
            print(f"No buy price recorded for {symbol}. Cannot sell.")

# Initialize a dictionary to track buy prices
buy_prices = {}

# Loop through the top stocks to check for trading signals
for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        current_price = get_live_data(symbol)  # Fetch current price
        action = check_signals(symbol, historical_data)  # Get action based on RSI

        if action == 'buy':
            if symbol not in buy_prices:  # Buy only if not already bought
                log_trade(symbol, 'buy', current_price, None)  # Log buy trade
                buy_prices[symbol] = current_price  # Store the buy price
                print(f"Buying {symbol} at {current_price}")
            else:
                print(f"{symbol} already bought at {buy_prices[symbol]}. No new buy action.")

        elif action == 'sell':
            if symbol in buy_prices:  # Check if buy price is recorded
                previous_buy_price = buy_prices[symbol]  # Retrieve the buy price
                profit_loss = current_price - previous_buy_price
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log sell trade
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                del buy_prices[symbol]  # Remove the stock from tracking after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error processing {symbol}: {e}")

# Initialize a dictionary to track buy prices
buy_prices = {}

# Loop through the top stocks to check for trading signals
for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        current_price = get_live_data(symbol)  # Fetch current price
        action = check_signals(symbol, historical_data)  # Get action based on RSI

        if action == 'buy':
            if symbol not in buy_prices:  # Buy only if not already bought
                log_trade(symbol, 'buy', current_price, None)  # Log buy trade
                buy_prices[symbol] = current_price  # Store the buy price
                print(f"Buying {symbol} at {current_price}")
            else:
                print(f"{symbol} already bought at {buy_prices[symbol]}. No new buy action.")

        elif action == 'sell':
            if symbol in buy_prices:  # Check if buy price is recorded
                previous_buy_price = buy_prices[symbol]  # Retrieve the buy price
                profit_loss = current_price - previous_buy_price
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log sell trade
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                del buy_prices[symbol]  # Remove the stock from tracking after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error processing {symbol}: {e}")

# Initialize a dictionary to track buy prices
buy_prices = {}

# Loop through the top stocks to check for trading signals
for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        current_price = get_live_data(symbol)  # Fetch current price
        action = check_signals(symbol, historical_data)  # Get action based on RSI

        if action == 'buy':
            if symbol not in buy_prices:  # Buy only if not already bought
                log_trade(symbol, 'buy', current_price, None)  # Log buy trade
                buy_prices[symbol] = current_price  # Store the buy price
                print(f"Buying {symbol} at {current_price}")
            else:
                print(f"{symbol} already bought at {buy_prices[symbol]}. No new buy action.")

        elif action == 'sell':
            if symbol in buy_prices:  # Check if buy price is recorded
                previous_buy_price = buy_prices[symbol]  # Retrieve the buy price
                profit_loss = current_price - previous_buy_price
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log sell trade
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                del buy_prices[symbol]  # Remove the stock from tracking after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error processing {symbol}: {e}")

# After processing all symbols, print any remaining buy prices
print("Remaining buy prices:", buy_prices)

# Initialize a dictionary to track buy prices
buy_prices = {}

# Loop through the top stocks to check for trading signals
for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        current_price = get_live_data(symbol)  # Fetch current price
        action = check_signals(symbol, historical_data)  # Get action based on RSI

        if action == 'buy':
            if symbol not in buy_prices:  # Buy only if not already bought
                log_trade(symbol, 'buy', current_price, None)  # Log buy trade
                buy_prices[symbol] = current_price  # Store the buy price
                print(f"Buying {symbol} at {current_price}")
            else:
                print(f"{symbol} already bought at {buy_prices[symbol]}. No new buy action.")

        elif action == 'sell':
            if symbol in buy_prices:  # Check if buy price is recorded
                previous_buy_price = buy_prices[symbol]  # Retrieve the buy price
                profit_loss = current_price - previous_buy_price
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log sell trade
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                del buy_prices[symbol]  # Remove the stock from tracking after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error processing {symbol}: {e}")

# After processing all symbols, print any remaining buy prices
print("Remaining buy prices:", buy_prices)

# Initialize a dictionary to track buy prices
buy_prices = {}

# Loop through the top stocks to check for trading signals
for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        current_price = get_live_data(symbol)  # Fetch current price
        print(f"Current price for {symbol} is {current_price}")  # Debugging output

        action = check_signals(symbol, historical_data)  # Get action based on RSI
        print(f"{symbol} - Action determined: {action}")  # Debugging output

        if action == 'buy':
            if symbol not in buy_prices:  # Buy only if not already bought
                log_trade(symbol, 'buy', current_price, None)  # Log buy trade
                buy_prices[symbol] = current_price  # Store the buy price
                print(f"Buying {symbol} at {current_price}")
            else:
                print(f"{symbol} already bought at {buy_prices[symbol]}. No new buy action.")

        elif action == 'sell':
            if symbol in buy_prices:  # Check if buy price is recorded
                previous_buy_price = buy_prices[symbol]  # Retrieve the buy price
                profit_loss = current_price - previous_buy_price
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log sell trade
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                del buy_prices[symbol]  # Remove the stock from tracking after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error processing {symbol}: {e}")

# After processing all symbols, print any remaining buy prices
print("Remaining buy prices:", buy_prices)

# Initialize a dictionary to track buy prices
buy_prices = {}

# Loop through the top stocks to check for trading signals
for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        current_price = get_live_data(symbol)  # Fetch current price
        print(f"Current price for {symbol} is {current_price}")  # Debugging output

        action = check_signals(symbol, historical_data)  # Get action based on RSI
        print(f"{symbol} - Action determined: {action}")  # Debugging output

        if action == 'buy':
            if symbol not in buy_prices:  # Buy only if not already bought
                log_trade(symbol, 'buy', current_price, None)  # Log buy trade
                buy_prices[symbol] = current_price  # Store the buy price
                print(f"Buying {symbol} at {current_price}")
            else:
                print(f"{symbol} already bought at {buy_prices[symbol]}. No new buy action.")

        elif action == 'sell':
            if symbol in buy_prices:  # Check if buy price is recorded
                previous_buy_price = buy_prices[symbol]  # Retrieve the buy price
                profit_loss = current_price - previous_buy_price
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log sell trade
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                del buy_prices[symbol]  # Remove the stock from tracking after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error processing {symbol}: {e}")

# After processing all symbols, print any remaining buy prices
print("Remaining buy prices:", buy_prices)

# Initialize a dictionary to track buy prices
buy_prices = {}

# Loop through the top stocks to check for trading signals
for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        current_price = get_live_data(symbol)  # Fetch current price
        print(f"Current price for {symbol} is {current_price}")  # Debugging output

        action = check_signals(symbol, historical_data)  # Get action based on RSI
        print(f"{symbol} - Action determined: {action}")  # Debugging output

        if action == 'buy':
            if symbol not in buy_prices:  # Buy only if not already bought
                log_trade(symbol, 'buy', current_price, None)  # Log buy trade
                buy_prices[symbol] = current_price  # Store the buy price
                print(f"Buying {symbol} at {current_price}")
            else:
                print(f"{symbol} already bought at {buy_prices[symbol]}. No new buy action.")

        elif action == 'sell':
            if symbol in buy_prices:  # Check if buy price is recorded
                previous_buy_price = buy_prices[symbol]  # Retrieve the buy price
                profit_loss = current_price - previous_buy_price
                log_trade(symbol, 'sell', current_price, profit_loss)  # Log sell trade
                print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
                del buy_prices[symbol]  # Remove the stock from tracking after selling
            else:
                print(f"No buy price recorded for {symbol}. Cannot sell.")

    except Exception as e:
        print(f"Error processing {symbol}: {e}")

# After processing all symbols, print any remaining buy prices
print("Remaining buy prices:", buy_prices)

def determine_action(rsi):
    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    else:
        return 'hold'  # or None

for symbol in symbols:
    current_price = get_live_data(symbol)
    rsi = calculate_rsi(fetch_historical_data(symbol))  # Fetch historical data and calculate RSI

    action = determine_action(rsi)

    if action == 'buy':
        log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
        print(f"Buying {symbol} at {current_price}")
    elif action == 'sell':
        if symbol in previous_buy_prices:  # Check if a buy price exists
            previous_buy_price = previous_buy_prices[symbol]
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
            print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
        else:
            print(f"No buy price recorded for {symbol}. Cannot sell.")
    else:
        print(f"{symbol} - Action determined: {action}")  # Debugging output

from datetime import datetime, timedelta

# Define your date range
end_date = datetime.now()
start_date = end_date - timedelta(days=7)  # or however many days you want to fetch

for symbol in symbols:
    current_price = get_live_data(symbol)

    # Fetch historical data and calculate RSI
    historical_data = fetch_historical_data(symbol, start_date, end_date)
    rsi = calculate_rsi(historical_data)

    action = determine_action(rsi)

    if action == 'buy':
        log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
        previous_buy_prices[symbol] = current_price  # Save the buy price
        print(f"Buying {symbol} at {current_price}")
    elif action == 'sell':
        if symbol in previous_buy_prices:  # Check if a buy price exists
            previous_buy_price = previous_buy_prices[symbol]
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
            print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
            del previous_buy_prices[symbol]  # Remove the buy price after selling
        else:
            print(f"No buy price recorded for {symbol}. Cannot sell.")
    else:
        print(f"{symbol} - Action determined: {action}")  # Debugging output

# Adjust the symbols list to remove 'FB'
symbols = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'NFLX', 'NVDA', 'DIS', 'ADBE', 'PYPL',
           'CMCSA', 'INTC', 'CSCO', 'PEP', 'NKE', 'V', 'MA', 'CRM', 'XOM', 'IBM', 'WMT', 'PFE']

# Define your date range
end_date = datetime.now()
start_date = end_date - timedelta(days=7)

previous_buy_prices = {}  # Dictionary to track previous buy prices

for symbol in symbols:
    current_price = get_live_data(symbol)

    # Fetch historical data and calculate RSI
    historical_data = fetch_historical_data(symbol, start_date, end_date)

    if historical_data.empty:
        print(f"No historical data found for {symbol}. Skipping...")
        continue  # Skip to the next symbol if no data is found

    rsi = calculate_rsi(historical_data)

    # Check for valid RSI before determining action
    if pd.isna(rsi):
        print(f"RSI calculation failed for {symbol}. Skipping...")
        continue  # Skip if RSI calculation failed

    action = determine_action(rsi)

    if action == 'buy':
        log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
        previous_buy_prices[symbol] = current_price  # Save the buy price
        print(f"Buying {symbol} at {current_price}")
    elif action == 'sell':
        if symbol in previous_buy_prices:  # Check if a buy price exists
            previous_buy_price = previous_buy_prices[symbol]
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
            print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
            del previous_buy_prices[symbol]  # Remove the buy price after selling
        else:
            print(f"No buy price recorded for {symbol}. Cannot sell.")
    else:
        print(f"{symbol} - Action determined: {action}")  # Debugging output

# Define your date range
end_date = datetime.now()
start_date = end_date - timedelta(days=7)

previous_buy_prices = {}  # Dictionary to track previous buy prices

for symbol in symbols:
    current_price = get_live_data(symbol)

    # Fetch historical data
    historical_data = fetch_historical_data(symbol, start_date, end_date)

    # Check if historical data is sufficient
    if historical_data.empty or len(historical_data) < 25:  # Ensure we have enough data for RSI window of 14 or more
        print(f"No sufficient historical data found for {symbol}. Skipping...")
        continue  # Skip to the next symbol if no data is found

    rsi = calculate_rsi(historical_data)

    # Check for valid RSI before determining action
    if pd.isna(rsi):
        print(f"RSI calculation failed for {symbol}. Skipping...")
        continue  # Skip if RSI calculation failed

    action = determine_action(rsi)

    if action == 'buy':
        log_trade(symbol, 'buy', current_price, None)  # Log the buy trade
        previous_buy_prices[symbol] = current_price  # Save the buy price
        print(f"Buying {symbol} at {current_price}")
    elif action == 'sell':
        if symbol in previous_buy_prices:  # Check if a buy price exists
            previous_buy_price = previous_buy_prices[symbol]
            profit_loss = current_price - previous_buy_price
            log_trade(symbol, 'sell', current_price, profit_loss)  # Log the sell trade
            print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
            del previous_buy_prices[symbol]  # Remove the buy price after selling
        else:
            print(f"No buy price recorded for {symbol}. Cannot sell.")
    else:
        print(f"{symbol} - Action determined: {action}")  # Debugging output

def is_symbol_valid(symbol):
    try:
        # Attempt to fetch the ticker data
        data = yf.Ticker(symbol).info
        return data['regularMarketPrice'] is not None
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return False

# Filter symbols to remove delisted or invalid ones
symbols = [symbol for symbol in symbols if is_symbol_valid(symbol)]

def fetch_historical_data(symbol, start_date, end_date):
    try:
        data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
        if data.empty:
            print(f"No historical data found for {symbol}.")
            return None
        return data
    except Exception as e:
        print(f"Error fetching historical data for {symbol}: {e}")
        return None

def calculate_rsi(data, window=14):
    if data is None or data.empty:
        print("No data available for RSI calculation.")
        return None

    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi.iloc[-1] if not rsi.empty else None  # Return the last RSI value

def determine_action(rsi):
    if rsi is None:
        return "hold"
    elif rsi < 30:
        return "buy"
    elif rsi > 70:
        return "sell"
    else:
        return "hold"

def fetch_historical_data(symbol, start_date, end_date):
    """Fetch historical data using Yahoo Finance, with error handling."""
    try:
        data = yf.download(symbol, start=start_date, end=end_date, interval='1m')
        if data.empty:
            print(f"No historical data found for {symbol}.")
            return pd.DataFrame()  # Return an empty DataFrame if no data
        return data
    except Exception as e:
        print(f"Error fetching historical data for {symbol}: {e}")
        return pd.DataFrame()  # Return an empty DataFrame on error

def calculate_rsi(data, window=14):
    if data.empty:
        print("No data available for RSI calculation.")
        return None

    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    # Handle division by zero
    if avg_loss.iloc[-1] == 0:
        print("Average loss is zero, returning None for RSI.")
        return None

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the last RSI value

def determine_action(rsi, buy_price):
    if rsi is None:
        return "hold"  # If RSI calculation failed, hold

    if rsi < 30:
        return 'buy'  # Buy signal
    elif rsi > 70:
        if buy_price is not None:
            return 'sell'  # Sell signal if we have a buy price
        else:
            print("No buy price recorded. Cannot sell.")
            return "hold"  # Cannot sell without a buy price
    else:
        return 'hold'  # No action

for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
    rsi = calculate_rsi(historical_data)  # Calculate RSI
    current_price = get_live_data(symbol)  # Fetch current price

    action = determine_action(rsi, buy_prices.get(symbol))  # Pass the buy price for the symbol

    print(f"{symbol} - Action determined: {action}")

    if action == 'buy':
        buy_prices[symbol] = current_price  # Store the buy price
        print(f"Buying {symbol} at {current_price}")
    elif action == 'sell':
        profit_loss = current_price - buy_prices[symbol]  # Calculate profit/loss
        print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
        del buy_prices[symbol]  # Remove the buy price after selling

import logging

# Set up logging
logging.basicConfig(
    filename='trading_bot.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)
    rsi = calculate_rsi(historical_data)
    current_price = get_live_data(symbol)

    action = determine_action(rsi, buy_prices.get(symbol))

    logging.info(f"{symbol} - Action determined: {action}")

    if action == 'buy':
        buy_prices[symbol] = current_price
        logging.info(f"Buying {symbol} at {current_price}")
    elif action == 'sell':
        profit_loss = current_price - buy_prices[symbol]
        logging.info(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
        del buy_prices[symbol]
    else:
        logging.info(f"No action taken for {symbol}.")

def get_live_data(symbol):
    try:
        data = yf.Ticker(symbol)
        price = data.history(period="1d")['Close'].iloc[-1]
        logging.info(f"Fetched live data for {symbol}: {price}")
        return price
    except Exception as e:
        logging.error(f"Error fetching live data for {symbol}: {e}")
        return None  # Return None or handle as appropriate

def execute_trade(symbol, action, current_price, previous_buy_price):
    try:
        if action == 'buy':
            log_trade(symbol, 'buy', current_price, None)
        elif action == 'sell' and previous_buy_price is not None:
            profit_loss = current_price - previous_buy_price
            logging.info(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")
            log_trade(symbol, 'sell', current_price, profit_loss)
        else:
            logging.warning(f"No previous buy price recorded for {symbol}. Cannot sell.")
    except Exception as e:
        logging.error(f"Error executing trade for {symbol}: {e}")

for symbol in symbols:
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)
        if historical_data is not None:
            rsi = calculate_rsi(historical_data)
            current_price = get_live_data(symbol)

            if rsi is not None and current_price is not None:
                action = determine_action(rsi, buy_prices.get(symbol))
                logging.info(f"{symbol} - Action determined: {action}")

                execute_trade(symbol, action, current_price, buy_prices.get(symbol))
            else:
                logging.warning(f"RSI or current price is None for {symbol}. Skipping...")
        else:
            logging.warning(f"No historical data found for {symbol}. Skipping...")
    except Exception as e:
        logging.error(f"Unexpected error processing {symbol}: {e}")

import unittest
from your_trading_bot_file import fetch_historical_data, calculate_rsi, get_live_data, execute_trade

import unittest
from day_trader_ai import fetch_historical_data, calculate_rsi, get_live_data, execute_trade

import unittest
from day_trader_ai import fetch_historical_data, calculate_rsi, get_live_data, execute_trade  # Update this line

class TestTradingBot(unittest.TestCase):

    def test_fetch_historical_data(self):
        # Test fetching historical data for a valid symbol
        historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-12-31')
        self.assertIsNotNone(historical_data)  # Ensure we got data

    def test_calculate_rsi(self):
        # Test calculating RSI with dummy data
        data = [1, 2, 3, 4, 5]  # Dummy data
        rsi = calculate_rsi(data)
        self.assertIsInstance(rsi, float)  # Check if RSI is a float

    def test_get_live_data(self):
        # Test getting live data for a valid symbol
        price = get_live_data('AAPL')
        self.assertIsNotNone(price)  # Ensure we got a price

    def test_execute_trade_buy(self):
        # Test execute trade for buying
        execute_trade('AAPL', 'buy', 150.0, None)  # This should log a buy trade

    def test_execute_trade_sell(self):
        # Test execute trade for selling
        execute_trade('AAPL', 'sell', 155.0, 150.0)  # This should log a sell trade

if __name__ == '__main__':
    unittest.main()

def test_fetch_historical_data():
    symbol = 'AAPL'
    start_date = '2023-01-01'
    end_date = '2023-01-31'
    data = fetch_historical_data(symbol, start_date, end_date)
    assert not data.empty, "Data should not be empty"

def test_calculate_rsi():
    symbol = 'AAPL'
    historical_data = fetch_historical_data(symbol, '2023-01-01', '2023-01-31')
    rsi = calculate_rsi(historical_data)
    assert rsi is not None, "RSI should be calculated"

# Run tests
test_fetch_historical_data()
test_calculate_rsi()

import yfinance as yf

def fetch_historical_data(symbol, start_date, end_date, interval='1d'):
    """Fetch historical data for a given symbol."""
    try:
        data = yf.download(symbol, start=start_date, end=end_date, interval=interval)
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return pd.DataFrame()  # Return an empty DataFrame on error

def test_fetch_historical_data():
    symbol = 'AAPL'
    start_date = '2023-01-01'
    end_date = '2023-01-07'  # Shorten the date range to avoid API limits
    data = fetch_historical_data(symbol, start_date, end_date, interval='1d')  # Use daily data
    assert not data.empty, "Data should not be empty"

def test_calculate_rsi():
    symbol = 'AAPL'
    historical_data = fetch_historical_data(symbol, '2023-01-01', '2023-01-07', interval='1d')  # Daily data
    if not historical_data.empty:
        rsi = calculate_rsi(historical_data['Close'])  # Assuming Close price is used for RSI
        assert rsi is not None, "RSI should be calculated"
    else:
        print("No historical data available for RSI calculation.")

def execute_trade(symbol, action, current_price):
    """Execute a trade action (buy/sell) for the specified symbol."""
    try:
        if action == 'buy':
            # Execute buy logic here
            print(f"Buying {symbol} at {current_price}")
            # Add your code to execute the buy order (e.g., using Robinhood API)
        elif action == 'sell':
            # Execute sell logic here
            print(f"Selling {symbol} at {current_price}")
            # Add your code to execute the sell order (e.g., using Robinhood API)
    except Exception as e:
        print(f"Error executing trade for {symbol}: {e}")

def determine_action(rsi):
    """Determine action based on RSI value."""
    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    else:
        return 'hold'

# Main trading loop
while True:
    for symbol in symbols:
        current_price = get_live_data(symbol)
        historical_data = fetch_historical_data(symbol, start_date, end_date)

        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        rsi = calculate_rsi(historical_data['Close'])
        action = determine_action(rsi)

        # Execute trade based on the action determined
        if action in ['buy', 'sell']:
            execute_trade(symbol, action, current_price)
        else:
            print(f"{symbol} - Action determined: {action}")

    time.sleep(60)  # Wait for a minute before checking again

pip install aiohttp

import asyncio
import aiohttp
import pandas as pd

async def fetch_historical_data(symbol, start_date, end_date):
    async with aiohttp.ClientSession() as session:
        url = f'https://api.example.com/historical?symbol={symbol}&start={start_date}&end={end_date}'
        async with session.get(url) as response:
            data = await response.json()
            # Process and return your DataFrame here
            return pd.DataFrame(data)

async def get_live_data(symbol):
    async with aiohttp.ClientSession() as session:
        url = f'https://api.example.com/live?symbol={symbol}'
        async with session.get(url) as response:
            data = await response.json()
            return data['price']

async def main():
    symbols = ['AAPL', 'GOOGL', 'MSFT']
    start_date = '2023-01-01'
    end_date = '2023-01-31'

    # Fetch historical data for all symbols asynchronously
    historical_data_tasks = [fetch_historical_data(symbol, start_date, end_date) for symbol in symbols]
    historical_data = await asyncio.gather(*historical_data_tasks)

    # Print historical data for verification
    for data in historical_data:
        print(data)

    # Get live data for all symbols asynchronously
    live_data_tasks = [get_live_data(symbol) for symbol in symbols]
    live_data = await asyncio.gather(*live_data_tasks)

    # Print live prices
    for symbol, price in zip(symbols, live_data):
        print(f'{symbol} live price: {price}')

# Run the main function
asyncio.run(main())

import asyncio
import aiohttp
import pandas as pd

async def fetch_historical_data(symbol, start_date, end_date):
    async with aiohttp.ClientSession() as session:
        url = f'https://api.example.com/historical?symbol={symbol}&start={start_date}&end={end_date}'
        async with session.get(url) as response:
            data = await response.json()
            # Process and return your DataFrame here
            return pd.DataFrame(data)

async def get_live_data(symbol):
    async with aiohttp.ClientSession() as session:
        url = f'https://api.example.com/live?symbol={symbol}'
        async with session.get(url) as response:
            data = await response.json()
            return data['price']

async def main():
    symbols = ['AAPL', 'GOOGL', 'MSFT']
    start_date = '2023-01-01'
    end_date = '2023-01-31'

    # Fetch historical data for all symbols asynchronously
    historical_data_tasks = [fetch_historical_data(symbol, start_date, end_date) for symbol in symbols]
    historical_data = await asyncio.gather(*historical_data_tasks)

    # Print historical data for verification
    for data in historical_data:
        print(data)

    # Get live data for all symbols asynchronously
    live_data_tasks = [get_live_data(symbol) for symbol in symbols]
    live_data = await asyncio.gather(*live_data_tasks)

    # Print live prices
    for symbol, price in zip(symbols, live_data):
        print(f'{symbol} live price: {price}')

# Run the main function using await
await main()

import asyncio
import yfinance as yf

# Function to fetch historical data
async def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1d')
    return data

# Function to calculate RSI
async def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Main function
async def main():
    symbol = 'AAPL'
    start_date = '2023-01-01'
    end_date = '2023-01-31'

    historical_data = await fetch_historical_data(symbol, start_date, end_date)
    if historical_data.empty:
        print(f"No historical data found for {symbol}.")
        return

    rsi = await calculate_rsi(historical_data)
    print(f"RSI for {symbol}: {rsi.iloc[-1]}")

# Run the main function
if __name__ == '__main__':
    asyncio.run(main())

import asyncio
import yfinance as yf

# Function to fetch historical data
async def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1d')
    return data

# Function to calculate RSI
async def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Main function
async def main():
    symbol = 'AAPL'
    start_date = '2023-01-01'
    end_date = '2023-01-31'

    historical_data = await fetch_historical_data(symbol, start_date, end_date)
    if historical_data.empty:
        print(f"No historical data found for {symbol}.")
        return

    rsi = await calculate_rsi(historical_data)
    print(f"RSI for {symbol}: {rsi.iloc[-1]}")

# Run the main function in the current event loop
await main()

import pandas as pd

# RSI calculation
def calculate_rsi(data, period=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Moving Average calculation
def calculate_moving_average(data, period=30):
    return data['Close'].rolling(window=period).mean()

# Bollinger Bands calculation
def calculate_bollinger_bands(data, period=20, num_std_dev=2):
    sma = data['Close'].rolling(window=period).mean()
    rstd = data['Close'].rolling(window=period).std()
    upper_band = sma + (num_std_dev * rstd)
    lower_band = sma - (num_std_dev * rstd)
    return upper_band, lower_band

# MACD calculation
def calculate_macd(data, fast_period=12, slow_period=26, signal_period=9):
    ema_fast = data['Close'].ewm(span=fast_period, adjust=False).mean()
    ema_slow = data['Close'].ewm(span=slow_period, adjust=False).mean()
    macd = ema_fast - ema_slow
    signal = macd.ewm(span=signal_period, adjust=False).mean()
    return macd, signal

# Stochastic Oscillator calculation
def calculate_stochastic_oscillator(data, k_period=14, d_period=3):
    low_min = data['Low'].rolling(window=k_period).min()
    high_max = data['High'].rolling(window=k_period).max()
    stoch_k = 100 * ((data['Close'] - low_min) / (high_max - low_min))
    stoch_d = stoch_k.rolling(window=d_period).mean()
    return stoch_k, stoch_d

# Volume calculation (simple moving average of volume)
def calculate_volume_average(data, period=20):
    return data['Volume'].rolling(window=period).mean()

def fetch_historical_data(symbol, start_date, end_date):
    # Fetch historical data from Yahoo Finance
    # Note: Ensure you have appropriate error handling
    data = yf.download(symbol, start=start_date, end=end_date, interval='1d')
    return data

def analyze_indicators(data):
    indicators = {}
    indicators['RSI'] = calculate_rsi(data)
    indicators['SMA'] = calculate_moving_average(data)
    indicators['Upper BB'], indicators['Lower BB'] = calculate_bollinger_bands(data)
    indicators['MACD'], indicators['Signal'] = calculate_macd(data)
    indicators['Stoch K'], indicators['Stoch D'] = calculate_stochastic_oscillator(data)
    indicators['Volume Avg'] = calculate_volume_average(data)

    return indicators

def determine_action(indicators):
    # Example logic for decision-making based on indicators
    action = "hold"  # Default action

    # Using RSI
    if indicators['RSI'].iloc[-1] < 30:
        action = "buy"
    elif indicators['RSI'].iloc[-1] > 70:
        action = "sell"

    # You can add more logic here to check other indicators

    return action

def execute_trades(symbols, start_date, end_date):
    for symbol in symbols:
        # Fetch historical data
        data = fetch_historical_data(symbol, start_date, end_date)

        if data.empty:
            print(f"No data for {symbol}. Skipping...")
            continue

        # Analyze indicators
        indicators = analyze_indicators(data)

        # Determine action
        action = determine_action(indicators)

        print(f"{symbol} - Action determined: {action}")

        # Execute trade logic here based on the action
        # e.g., execute_trade(symbol, action)

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']
start_date = '2024-01-01'
end_date = '2024-10-10'
execute_trades(symbols, start_date, end_date)

import robin_stocks.robinhood as rh

def execute_trade(symbol, action, current_price):
    if action == "buy":
        # Buy logic - ensure you have enough funds
        try:
            rh.order_buy_fractional_by_price(symbol, current_price, timeInForce='gfd')
            print(f"Bought {symbol} at {current_price}")
            log_trade(symbol, action, current_price)
        except Exception as e:
            print(f"Error executing buy for {symbol}: {e}")

    elif action == "sell":
        # Sell logic - ensure you own the stock
        try:
            rh.order_sell_fractional_by_price(symbol, current_price, timeInForce='gfd')
            print(f"Sold {symbol} at {current_price}")
            log_trade(symbol, action, current_price)
        except Exception as e:
            print(f"Error executing sell for {symbol}: {e}")

def log_trade(symbol, action, price):
    # Log trade details (this could be a print statement or saving to a file)
    print(f"Trade executed: {action} {symbol} at {price}")

def execute_trades(symbols, start_date, end_date):
    for symbol in symbols:
        # Fetch historical data
        data = fetch_historical_data(symbol, start_date, end_date)

        if data.empty:
            print(f"No data for {symbol}. Skipping...")
            continue

        # Analyze indicators
        indicators = analyze_indicators(data)

        # Determine action
        action = determine_action(indicators)

        # Get current price
        current_price = get_live_data(symbol)

        print(f"{symbol} - Action determined: {action}")

        # Execute trade based on action
        execute_trade(symbol, action, current_price)

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']
start_date = '2024-01-01'
end_date = '2024-10-10'
execute_trades(symbols, start_date, end_date)

class TradingBot:
    def __init__(self, total_capital=200, max_daily_loss=50):
        self.total_capital = total_capital
        self.max_daily_loss = max_daily_loss
        self.current_loss = 0
        self.daily_profit_loss = 0  # Track daily performance
        self.trades = []

    def calculate_position_size(self, trade_amount_percentage):
        # Calculate the amount to trade based on a percentage of total capital
        return self.total_capital * trade_amount_percentage

    def execute_trade(self, symbol, action, price, amount):
        # Logic for executing the trade
        if action == 'buy':
            # Deduct capital for the buy
            self.trades.append({'symbol': symbol, 'action': action, 'price': price, 'amount': amount})
            print(f"Buying {symbol} at {price}")
        elif action == 'sell':
            # Logic for selling, including updating daily profit/loss
            last_trade = next((trade for trade in reversed(self.trades) if trade['symbol'] == symbol), None)
            if last_trade:
                profit_loss = (price - last_trade['price']) * last_trade['amount']
                self.daily_profit_loss += profit_loss
                print(f"Selling {symbol} at {price} - Profit/Loss: {profit_loss}")

        # Check if daily loss exceeds the max allowed
        if self.daily_profit_loss < -self.max_daily_loss:
            print("Daily loss limit reached. Halting trading for today.")
            # Add logic to stop further trading for the day

    def reset_daily_performance(self):
        self.daily_profit_loss = 0  # Reset daily performance at the end of the day

class TradingBot:
    def __init__(self, total_capital=200, max_daily_loss=50):
        self.total_capital = total_capital
        self.max_daily_loss = max_daily_loss
        self.current_loss = 0
        self.daily_profit_loss = 0  # Track daily performance
        self.trades = []  # List to log trades

    def execute_trade(self, symbol, action, price, amount):
        # Existing trade logic
        # ...
        profit_loss = 0
        if action == 'sell':
            last_trade = next((trade for trade in reversed(self.trades) if trade['symbol'] == symbol), None)
            if last_trade:
                profit_loss = (price - last_trade['price']) * last_trade['amount']
                self.daily_profit_loss += profit_loss
                self.log_trade(symbol, action, price, amount, profit_loss)

        # Check if daily loss exceeds the max allowed
        if self.daily_profit_loss < -self.max_daily_loss:
            print("Daily loss limit reached. Halting trading for today.")
            # Stop further trading for the day

    def log_trade(self, symbol, action, price, amount, profit_loss):
        # Log trade details
        self.trades.append({
            'symbol': symbol,
            'action': action,
            'price': price,
            'amount': amount,
            'profit_loss': profit_loss
        })

    def calculate_performance_metrics(self):
        total_profit = sum(trade['profit_loss'] for trade in self.trades)
        total_trades = len(self.trades)
        win_trades = len([trade for trade in self.trades if trade['profit_loss'] > 0])
        win_rate = win_trades / total_trades * 100 if total_trades > 0 else 0
        avg_profit_loss = total_profit / total_trades if total_trades > 0 else 0

        return {
            'Total Profit/Loss': total_profit,
            'Win Rate (%)': win_rate,
            'Average Profit/Loss per Trade': avg_profit_loss
        }

    def reset_daily_performance(self):
        self.daily_profit_loss = 0  # Reset daily performance at the end of the day

def calculate_indicators(historical_data):
    # Calculate RSI
    rsi = calculate_rsi(historical_data)

    # Calculate Moving Averages (e.g., short-term and long-term)
    short_ma = historical_data['close'].rolling(window=5).mean()  # Short-term MA
    long_ma = historical_data['close'].rolling(window=20).mean()  # Long-term MA

    return {
        'RSI': rsi,
        'Short_MA': short_ma,
        'Long_MA': long_ma
    }

def determine_action(indicators):
    if indicators['RSI'] < 30:
        return 'buy'
    elif indicators['RSI'] > 70:
        return 'sell'
    elif indicators['Short_MA'] > indicators['Long_MA']:
        return 'buy'  # Bullish signal
    elif indicators['Short_MA'] < indicators['Long_MA']:
        return 'sell'  # Bearish signal
    else:
        return 'hold'

def calculate_indicators(historical_data):
    # Calculate RSI
    rsi = calculate_rsi(historical_data)

    # Calculate Moving Averages (short-term and long-term)
    short_ma = historical_data['close'].rolling(window=5).mean()  # Short-term MA
    long_ma = historical_data['close'].rolling(window=20).mean()  # Long-term MA

    return {
        'RSI': rsi,
        'Short_MA': short_ma,
        'Long_MA': long_ma
    }

def determine_action(indicators):
    action = 'hold'  # Default action
    if indicators['RSI'] < 30:
        action = 'buy'
    elif indicators['RSI'] > 70:
        action = 'sell'
    elif indicators['Short_MA'].iloc[-1] > indicators['Long_MA'].iloc[-1]:  # Check the last value
        action = 'buy'  # Bullish signal
    elif indicators['Short_MA'].iloc[-1] < indicators['Long_MA'].iloc[-1]:  # Check the last value
        action = 'sell'  # Bearish signal

    return action

for symbol in symbols:
    current_price = get_live_data(symbol)  # Fetch live data
    historical_data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data
    indicators = calculate_indicators(historical_data)  # Calculate indicators
    action = determine_action(indicators)  # Determine action based on indicators

    # Execute trade based on action
    if action == 'buy':
        execute_trade(symbol, action, current_price)
    elif action == 'sell':
        execute_trade(symbol, action, current_price)

def fetch_historical_data(symbol, start_date, end_date):
    # Your existing logic to fetch data here
    data = ...  # Replace with your code to fetch data
    print(data.head())  # Add this line to inspect the data
    return data

def calculate_indicators(historical_data):
    # Calculate RSI
    rsi = calculate_rsi(historical_data)

    # Calculate Moving Averages (short-term and long-term)
    short_ma = historical_data['Close'].rolling(window=5).mean()  # Use 'Close' instead of 'close'
    long_ma = historical_data['Close'].rolling(window=20).mean()  # Use 'Close' instead of 'close'

    return {
        'RSI': rsi,
        'Short_MA': short_ma,
        'Long_MA': long_ma
    }

def determine_action(indicators):
    rsi = indicators['RSI']
    short_ma = indicators['Short_MA']
    long_ma = indicators['Long_MA']

    # Determine buy/sell actions
    if rsi < 30 and short_ma.iloc[-1] > long_ma.iloc[-1]:
        return 'buy'
    elif rsi > 70 and short_ma.iloc[-1] < long_ma.iloc[-1]:
        return 'sell'
    else:
        return 'hold'

async def main():
    symbols = [...]  # Your list of symbols

    for symbol in symbols:
        current_price = get_live_data(symbol)
        historical_data = fetch_historical_data(symbol, start_date, end_date)

        if historical_data.empty:
            print(f"No historical data found for {symbol}. Skipping...")
            continue

        indicators = calculate_indicators(historical_data)
        action = determine_action(indicators)

        print(f"{symbol} - Action determined: {action}")

        # Execute trade based on action
        if action == 'buy':
            execute_trade(symbol, 'buy', current_price)
        elif action == 'sell':
            execute_trade(symbol, 'sell', current_price)

import logging

# Set up logging configuration
logging.basicConfig(filename='trading_bot.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

def log_trade(symbol, action, price):
    message = f"Executed {action} for {symbol} at price {price}"
    logging.info(message)
    print(message)  # Print to console as well

# Execute trade based on action
        if action == 'buy':
            execute_trade(symbol, 'buy', current_price)
            log_trade(symbol, 'buy', current_price)
        elif action == 'sell':
            execute_trade(symbol, 'sell', current_price)
            log_trade(symbol, 'sell', current_price)

try:
            # Execute trade based on action
            if action == 'buy':
                execute_trade(symbol, 'buy', current_price)
                log_trade(symbol, 'buy', current_price)
            elif action == 'sell':
                execute_trade(symbol, 'sell', current_price)
                log_trade(symbol, 'sell', current_price)
        except Exception as e:
            logging.error(f"Error executing trade for {symbol}: {e}")

# Performance metrics
total_profit = 0.0
total_trades = 0
winning_trades = 0

try:
            # Execute trade based on action
            if action == 'buy':
                execute_trade(symbol, 'buy', current_price)
                log_trade(symbol, 'buy', current_price)
            elif action == 'sell':
                profit_loss = current_price - previous_buy_price  # Calculate profit/loss
                execute_trade(symbol, 'sell', current_price)
                log_trade(symbol, 'sell', current_price)

                # Update performance metrics
                total_trades += 1
                total_profit += profit_loss

                if profit_loss > 0:
                    winning_trades += 1
        except Exception as e:
            logging.error(f"Error executing trade for {symbol}: {e}")

def print_performance_metrics():
    global total_trades, winning_trades, total_profit
    if total_trades > 0:
        win_rate = (winning_trades / total_trades) * 100
        avg_profit_loss = total_profit / total_trades
    else:
        win_rate = 0
        avg_profit_loss = 0

    logging.info(f"Total Profit: {total_profit:.2f}")
    logging.info(f"Total Trades: {total_trades}")
    logging.info(f"Winning Trades: {winning_trades}")
    logging.info(f"Win Rate: {win_rate:.2f}%")
    logging.info(f"Average Profit/Loss per Trade: {avg_profit_loss:.2f}")

try:
    # Fetch historical data
    historical_data = fetch_historical_data(symbol, start_date, end_date)
    rsi = calculate_rsi(historical_data)

    # Determine action based on RSI
    action = determine_action(rsi)

    # Execute trade based on the action determined
    if action == 'buy':
        execute_trade(symbol, 'buy', current_price)
        log_trade(symbol, 'buy', current_price)
    elif action == 'sell':
        profit_loss = current_price - previous_buy_price
        execute_trade(symbol, 'sell', current_price)
        log_trade(symbol, 'sell', current_price)

except Exception as e:
    logging.error(f"Error occurred for {symbol}: {e}")

def fetch_data_with_retry(symbol, retries=3):
    for attempt in range(retries):
        try:
            return fetch_historical_data(symbol, start_date, end_date)
        except Exception as e:
            logging.warning(f"Attempt {attempt + 1} failed for {symbol}: {e}")
            if attempt < retries - 1:
                time.sleep(2)  # Wait before retrying
    return None  # Return None if all attempts fail

historical_data = fetch_data_with_retry(symbol)
if historical_data is None:
    logging.error(f"Failed to fetch data for {symbol} after multiple attempts.")
    continue  # Skip to the next symbol

def fetch_historical_data(symbol, start_date, end_date):
    # Your implementation to fetch historical data
    # Make sure it returns a DataFrame
    try:
        data = yf.download(symbol, start=start_date, end=end_date, interval='1d')  # Change to your desired frequency
        return data
    except Exception as e:
        logging.error(f"Failed to fetch data for {symbol}: {e}")
        return None  # Return None if there is an error

for symbol in symbols:
    historical_data = fetch_data_with_retry(symbol)
    if historical_data is None:
        logging.error(f"Failed to fetch data for {symbol} after multiple attempts.")
        continue  # Now this 'continue' is correctly used within the loop

    rsi = calculate_rsi(historical_data)
    if rsi is None:
        logging.error(f"RSI calculation failed for {symbol}. Skipping...")
        continue  # Continue to the next symbol

    action = determine_action(rsi)

    # Execute trade based on the action determined
    if action == 'buy':
        execute_trade(symbol, 'buy', current_price)
        log_trade(symbol, 'buy', current_price)
    elif action == 'sell':
        profit_loss = current_price - previous_buy_price
        execute_trade(symbol, 'sell', current_price)
        log_trade(symbol, 'sell', current_price)

historical_data = fetch_historical_data(symbol, start_date, end_date)
print(historical_data.head())  # This will help you verify the structure

def calculate_rsi(data, window=14):
    if data is None or data.empty:
        logging.warning("No data available for RSI calculation.")
        return None

    # Check if 'Close' column exists
    if 'Close' not in data.columns:
        logging.warning("Close column missing from data for RSI calculation.")
        return None

    # Calculate price changes
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    # Calculate the RSI
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the most recent RSI value

# Ensure the index is a datetime index
data.index = pd.to_datetime(data.index, errors='coerce')

# Drop rows with invalid datetime entries if necessary
data = data.dropna(subset=[data.index.name])

# Convert the index to datetime if it's not already
data.index = pd.to_datetime(data.index, errors='coerce')

# Now drop rows with invalid datetime entries
data = data.dropna(subset=['Close'])  # Assuming 'Close' is the column of interest

print(data.head())  # Check the first few rows of the cleaned DataFrame

def fetch_historical_data(symbol, start_date, end_date):
    # Fetch the historical data (you might already have this function)
    try:
        historical_data = yf.download(symbol, start=start_date, end=end_date, interval='1d')
        return historical_data
    except Exception as e:
        logging.error(f"Failed to fetch historical data for {symbol}: {e}")
        return None

def calculate_rsi(data, window=14):
    if data is None or data.empty:
        logging.warning("No data available for RSI calculation.")
        return None

    # Ensure the index is a datetime index
    data.index = pd.to_datetime(data.index, errors='coerce')

    # Drop rows with missing values in the 'Close' column
    data = data.dropna(subset=['Close'])

    # Calculate price changes
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    # Calculate the RSI
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return rsi.iloc[-1]  # Return the most recent RSI value

# Example usage
for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)

    if historical_data is None or historical_data.empty:
        logging.error(f"No historical data for {symbol}. Skipping...")
        continue

    rsi_value = calculate_rsi(historical_data)

    if rsi_value is None:
        logging.error(f"RSI calculation failed for {symbol}. Skipping...")
        continue

    action = determine_action(rsi_value)
    # Continue with your trading logic...

def determine_action(rsi):
    if rsi < 30:
        return 'buy'
    elif rsi > 70:
        return 'sell'
    else:
        return 'hold'

for symbol in symbols:
    historical_data = fetch_historical_data(symbol, start_date, end_date)

    if historical_data is None or historical_data.empty:
        logging.error(f"No historical data for {symbol}. Skipping...")
        continue

    rsi_value = calculate_rsi(historical_data)

    if rsi_value is None:
        logging.error(f"RSI calculation failed for {symbol}. Skipping...")
        continue

    # Now we call the updated determine_action function
    action = determine_action(rsi_value)

    # Log the action
    print(f"{symbol} - RSI: {rsi_value} - Action: {action}")

    # Continue with your trading logic...

def execute_trade(symbol, action, current_price):
    if action == 'buy':
        # Check if there's enough capital and execute a buy order
        logging.info(f"Buying {symbol} at {current_price}")
        # Your buy execution logic here (e.g., Robinhood API call)

    elif action == 'sell':
        # Execute a sell order
        logging.info(f"Selling {symbol} at {current_price}")
        # Your sell execution logic here (e.g., Robinhood API call)

    elif action == 'hold':
        logging.info(f"Holding {symbol}. No action taken.")

# In your main trading loop, call this function with the action
for symbol in symbols:
    # Fetch data, calculate RSI, determine action...

    execute_trade(symbol, action, current_price)

# Risk management parameters
MAX_DAILY_LOSS = 50  # Maximum loss allowed per day
MAX_TRADE_AMOUNT = 5  # Maximum amount per trade

# Initialize tracking variables
daily_loss = 0  # Track daily losses

def execute_trade(symbol, action, current_price):
    global daily_loss
    trade_amount = min(MAX_TRADE_AMOUNT, total_capital)  # Ensure we don't exceed total capital

    if action == 'buy':
        if daily_loss < MAX_DAILY_LOSS:
            # Execute buy order logic
            logging.info(f"Buying {symbol} at {current_price} for ${trade_amount}")
            # Update daily_loss if there's a loss
        else:
            logging.info(f"Cannot buy {symbol}. Daily loss limit reached.")

    elif action == 'sell':
        # Execute sell order logic
        logging.info(f"Selling {symbol} at {current_price} for ${trade_amount}")

    elif action == 'hold':
        logging.info(f"Holding {symbol}. No action taken.")

import logging

# Set up logging
logging.basicConfig(
    filename='trading_bot.log',  # Log file name
    level=logging.INFO,           # Log level
    format='%(asctime)s - %(levelname)s - %(message)s'  # Log format
)

def execute_trade(symbol, action, current_price):
    global daily_loss
    trade_amount = min(MAX_TRADE_AMOUNT, total_capital)  # Ensure we don't exceed total capital

    if action == 'buy':
        if daily_loss < MAX_DAILY_LOSS:
            # Execute buy order logic
            logging.info(f"Buying {symbol} at {current_price} for ${trade_amount}")
            # Update daily_loss if there's a loss
        else:
            logging.info(f"Cannot buy {symbol}. Daily loss limit reached.")

    elif action == 'sell':
        # Execute sell order logic
        logging.info(f"Selling {symbol} at {current_price} for ${trade_amount}")

    elif action == 'hold':
        logging.info(f"Holding {symbol}. No action taken.")

total_profit = 0
total_trades = 0
win_trades = 0
loss_trades = 0

def execute_trade(symbol, action, current_price):
    global daily_loss, total_profit, total_trades, win_trades, loss_trades
    trade_amount = min(MAX_TRADE_AMOUNT, total_capital)  # Ensure we don't exceed total capital

    if action == 'buy':
        if daily_loss < MAX_DAILY_LOSS:
            # Execute buy order logic
            logging.info(f"Buying {symbol} at {current_price} for ${trade_amount}")
            # Update daily_loss if there's a loss
        else:
            logging.info(f"Cannot buy {symbol}. Daily loss limit reached.")

    elif action == 'sell':
        # Here you would calculate profit/loss based on buy price
        # Example calculation (this needs to be properly implemented)
        profit_loss = current_price - previous_buy_price  # Replace with actual logic
        total_profit += profit_loss
        total_trades += 1

        if profit_loss > 0:
            win_trades += 1
        else:
            loss_trades += 1

        logging.info(f"Selling {symbol} at {current_price} for ${trade_amount}. Profit/Loss: {profit_loss}")

    elif action == 'hold':
        logging.info(f"Holding {symbol}. No action taken.")

def execute_trade(symbol, action, current_price):
    global daily_loss, total_profit, total_trades, win_trades, loss_trades
    trade_amount = min(MAX_TRADE_AMOUNT, total_capital)  # Ensure we don't exceed total capital

    if action == 'buy':
        if daily_loss < MAX_DAILY_LOSS:
            # Execute buy order logic
            logging.info(f"Buying {symbol} at {current_price} for ${trade_amount}")
            # Update daily_loss if there's a loss
        else:
            logging.info(f"Cannot buy {symbol}. Daily loss limit reached.")

    elif action == 'sell':
        # Here you would calculate profit/loss based on buy price
        # Example calculation (this needs to be properly implemented)
        profit_loss = current_price - previous_buy_price  # Replace with actual logic
        total_profit += profit_loss
        total_trades += 1

        if profit_loss > 0:
            win_trades += 1
        else:
            loss_trades += 1

        logging.info(f"Selling {symbol} at {current_price} for ${trade_amount}. Profit/Loss: {profit_loss}")

    elif action == 'hold':
        logging.info(f"Holding {symbol}. No action taken.")

def fetch_historical_data(symbol, start_date, end_date):
    # Your existing logic to fetch historical data...
    historical_data = ...  # Replace with actual data fetching code
    # Add RSI and other indicators here
    return historical_data

historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-12-31')
backtest_strategy(historical_data)

import yfinance as yf

def fetch_historical_data(symbol, start_date, end_date):
    try:
        # Fetch the historical data
        data = yf.download(symbol, start=start_date, end=end_date)
        # Ensure data is valid
        if data.empty:
            logging.warning(f"No data fetched for {symbol} from {start_date} to {end_date}.")
            return None
        # Calculate RSI and add as a column
        data['RSI'] = calculate_rsi(data)  # Assuming calculate_rsi is defined
        data['Symbol'] = symbol  # Add a column for the symbol
        return data
    except Exception as e:
        logging.error(f"Error fetching historical data for {symbol}: {str(e)}")
        return None

historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-12-31')
if historical_data is not None:
    backtest_strategy(historical_data)
else:
    logging.error("Failed to retrieve historical data.")

def backtest_strategy(historical_data):
    if historical_data is None or 'Close' not in historical_data.columns:
        logging.error("Invalid historical data for backtesting.")
        return

    total_profit = 0
    total_trades = 0
    win_trades = 0
    loss_trades = 0

    for index, row in historical_data.iterrows():
        price = row['Close']
        rsi = row['RSI']
        # Implement your buy/sell logic here

import pandas as pd

# Function to calculate the Average True Range (ATR)
def calculate_atr(historical_data, window=14):
    high_low = historical_data['High'] - historical_data['Low']
    high_close = abs(historical_data['High'] - historical_data['Close'].shift())
    low_close = abs(historical_data['Low'] - historical_data['Close'].shift())

    true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    atr = true_range.rolling(window=window, min_periods=1).mean()
    return atr

# Function to determine stop-loss and take-profit based on ATR
def determine_risk_management(price, atr, risk_multiplier=1.5):
    # Stop-loss at 1x ATR below the price
    stop_loss = price - atr
    # Take-profit at a multiple (e.g., 1.5x) ATR above the price
    take_profit = price + (atr * risk_multiplier)

    return stop_loss, take_profit

# Example usage in the trade execution
def execute_trade(symbol, action, price, atr):
    stop_loss, take_profit = determine_risk_management(price, atr)

    if action == 'buy':
        print(f"Buying {symbol} at {price} with Stop Loss: {stop_loss}, Take Profit: {take_profit}")
        # Execute the buy logic...
    elif action == 'sell':
        print(f"Selling {symbol} at {price} with Stop Loss: {stop_loss}, Take Profit: {take_profit}")
        # Execute the sell logic...

import asyncio
import aiohttp

# Function to fetch live data asynchronously for a single symbol
async def fetch_live_data_async(symbol):
    url = f"https://api.yourdatasource.com/{symbol}/live_data"  # Replace with actual API endpoint
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            data = await response.json()
            return data

# Asynchronous function to handle trading for a single symbol
async def handle_ticker(symbol, capital_per_trade):
    # Fetch live data
    data = await fetch_live_data_async(symbol)

    # Calculate indicators (RSI, SMA, etc.) using historical data
    historical_data = await fetch_historical_data_async(symbol)
    indicators = calculate_indicators(historical_data)

    # Determine action (buy/sell/hold)
    action = determine_action(indicators)

    # Execute trade if action is buy/sell
    if action in ['buy', 'sell']:
        current_price = data['current_price']  # Extract live price
        atr = calculate_atr(historical_data)
        execute_trade(symbol, action, current_price, atr, capital_per_trade)

# Main function to trade across multiple tickers asynchronously
async def trade_multiple_tickers(tickers, capital_per_trade):
    tasks = []
    for symbol in tickers:
        tasks.append(handle_ticker(symbol, capital_per_trade))
    await asyncio.gather(*tasks)

# Execute the trading function for your top 25 tickers
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'NFLX', 'NVDA', 'DIS', 'ADBE', 'PYPL',
           'CMCSA', 'INTC', 'CSCO', 'PEP', 'NKE', 'V', 'MA', 'CRM', 'XOM', 'IBM', 'WMT', 'PFE']
capital_per_trade = 5  # Allocate $5 per trade
daily_budget = 200

if __name__ == '__main__':
    asyncio.run(trade_multiple_tickers(tickers, capital_per_trade))

!pip install nest_asyncio

import nest_asyncio
import asyncio
import aiohttp

# Apply nest_asyncio to avoid the event loop error
nest_asyncio.apply()

# Function to fetch live data asynchronously for a single symbol
async def fetch_live_data_async(symbol):
    url = f"https://api.yourdatasource.com/{symbol}/live_data"  # Replace with actual API endpoint
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            data = await response.json()
            return data

# Asynchronous function to handle trading for a single symbol
async def handle_ticker(symbol, capital_per_trade):
    # Fetch live data
    data = await fetch_live_data_async(symbol)

    # Calculate indicators (RSI, SMA, etc.) using historical data
    historical_data = await fetch_historical_data_async(symbol)
    indicators = calculate_indicators(historical_data)

    # Determine action (buy/sell/hold)
    action = determine_action(indicators)

    # Execute trade if action is buy/sell
    if action in ['buy', 'sell']:
        current_price = data['current_price']  # Extract live price
        atr = calculate_atr(historical_data)
        execute_trade(symbol, action, current_price, atr, capital_per_trade)

# Main function to trade across multiple tickers asynchronously
async def trade_multiple_tickers(tickers, capital_per_trade):
    tasks = []
    for symbol in tickers:
        tasks.append(handle_ticker(symbol, capital_per_trade))
    await asyncio.gather(*tasks)

# Execute the trading function for your top 25 tickers
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'NFLX', 'NVDA', 'DIS', 'ADBE', 'PYPL',
           'CMCSA', 'INTC', 'CSCO', 'PEP', 'NKE', 'V', 'MA', 'CRM', 'XOM', 'IBM', 'WMT', 'PFE']
capital_per_trade = 5  # Allocate $5 per trade
daily_budget = 200

# Running the function
await trade_multiple_tickers(tickers, capital_per_trade)

import aiohttp

# Function to fetch live data synchronously for a single symbol
def fetch_live_data(symbol):
    url = f"https://api.yourdatasource.com/{symbol}/live_data"  # Replace with actual API endpoint
    response = requests.get(url)
    data = response.json()
    return data

# Function to handle trading for a single symbol
def handle_ticker(symbol, capital_per_trade):
    # Fetch live data
    data = fetch_live_data(symbol)

    # Calculate indicators (RSI, SMA, etc.) using historical data
    historical_data = fetch_historical_data(symbol)
    indicators = calculate_indicators(historical_data)

    # Determine action (buy/sell/hold)
    action = determine_action(indicators)

    # Execute trade if action is buy/sell
    if action in ['buy', 'sell']:
        current_price = data['current_price']  # Extract live price
        atr = calculate_atr(historical_data)
        execute_trade(symbol, action, current_price, atr, capital_per_trade)

# Main function to trade across multiple tickers synchronously
def trade_multiple_tickers(tickers, capital_per_trade):
    for symbol in tickers:
        handle_ticker(symbol, capital_per_trade)

# Execute the trading function for your top 25 tickers
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'NFLX', 'NVDA', 'DIS', 'ADBE', 'PYPL',
           'CMCSA', 'INTC', 'CSCO', 'PEP', 'NKE', 'V', 'MA', 'CRM', 'XOM', 'IBM', 'WMT', 'PFE']
capital_per_trade = 5  # Allocate $5 per trade
daily_budget = 200

# Running the function synchronously
trade_multiple_tickers(tickers, capital_per_trade)



import requests  # Add this line to fix the error

# Function to fetch live data synchronously for a single symbol
def fetch_live_data(symbol):
    url = f"https://api.yourdatasource.com/{symbol}/live_data"  # Replace with actual API endpoint
    response = requests.get(url)
    data = response.json()
    return data

# Function to handle trading for a single symbol
def handle_ticker(symbol, capital_per_trade):
    # Fetch live data
    data = fetch_live_data(symbol)

    # Calculate indicators (RSI, SMA, etc.) using historical data
    historical_data = fetch_historical_data(symbol)
    indicators = calculate_indicators(historical_data)

    # Determine action (buy/sell/hold)
    action = determine_action(indicators)

    # Execute trade if action is buy/sell
    if action in ['buy', 'sell']:
        current_price = data['current_price']  # Extract live price
        atr = calculate_atr(historical_data)
        execute_trade(symbol, action, current_price, atr, capital_per_trade)

# Main function to trade across multiple tickers synchronously
def trade_multiple_tickers(tickers, capital_per_trade):
    for symbol in tickers:
        handle_ticker(symbol, capital_per_trade)

# Execute the trading function for your top 25 tickers
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'NFLX', 'NVDA', 'DIS', 'ADBE', 'PYPL',
           'CMCSA', 'INTC', 'CSCO', 'PEP', 'NKE', 'V', 'MA', 'CRM', 'XOM', 'IBM', 'WMT', 'PFE']
capital_per_trade = 5  # Allocate $5 per trade
daily_budget = 200

# Running the function synchronously
trade_multiple_tickers(tickers, capital_per_trade)

import requests

# Function to fetch historical data synchronously for a single symbol
def fetch_historical_data(symbol, start_date, end_date):
    # Replace with actual data fetching from your historical data source
    url = f"https://api.yourhistoricaldatasource.com/{symbol}/historical_data?start={start_date}&end={end_date}"  # Mock endpoint
    response = requests.get(url)
    data = response.json()
    return data

# Function to handle trading for a single symbol using historical data
def handle_ticker(symbol, capital_per_trade, start_date, end_date):
    # Fetch historical data
    historical_data = fetch_historical_data(symbol, start_date, end_date)

    # Calculate indicators (RSI, SMA, etc.) using historical data
    indicators = calculate_indicators(historical_data)

    # Determine action (buy/sell/hold)
    action = determine_action(indicators)

    # Simulate trade execution based on historical prices
    if action in ['buy', 'sell']:
        current_price = historical_data[-1]['close']  # Use the most recent historical price
        atr = calculate_atr(historical_data)
        execute_trade(symbol, action, current_price, atr, capital_per_trade)

# Main function to trade across multiple tickers using historical data
def trade_multiple_tickers(tickers, capital_per_trade, start_date, end_date):
    for symbol in tickers:
        handle_ticker(symbol, capital_per_trade, start_date, end_date)

# Execute the trading function for your top 25 tickers using historical data
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'NFLX', 'NVDA', 'DIS', 'ADBE', 'PYPL',
           'CMCSA', 'INTC', 'CSCO', 'PEP', 'NKE', 'V', 'MA', 'CRM', 'XOM', 'IBM', 'WMT', 'PFE']
capital_per_trade = 5  # Allocate $5 per trade
daily_budget = 200

# Define a historical date range for testing
start_date = '2023-01-01'
end_date = '2023-12-31'

# Running the function with historical data
trade_multiple_tickers(tickers, capital_per_trade, start_date, end_date)

import yfinance as yf

# Function to fetch historical data using Yahoo Finance
def fetch_historical_data(symbol, start_date, end_date):
    try:
        stock = yf.Ticker(symbol)
        historical_data = stock.history(start=start_date, end=end_date)

        if historical_data.empty:
            raise ValueError(f"No data found for {symbol} between {start_date} and {end_date}.")

        return historical_data
    except Exception as e:
        raise ValueError(f"Error fetching data for {symbol}: {e}")

# Function to handle trading for a single symbol using historical data
def handle_ticker(symbol, capital_per_trade, start_date, end_date):
    try:
        historical_data = fetch_historical_data(symbol, start_date, end_date)
        # Perform trading logic based on historical data
        # You can add your trading logic here
        print(f"Fetched data for {symbol} from {start_date} to {end_date}")
    except ValueError as e:
        print(e)

# Main function to trade across multiple tickers using historical data
def trade_multiple_tickers(tickers, capital_per_trade, start_date, end_date):
    for symbol in tickers:
        handle_ticker(symbol, capital_per_trade, start_date, end_date)

# Define the parameters
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']
capital_per_trade = 5  # Allocate $5 per trade
start_date = '2023-01-01'
end_date = '2023-12-31'

# Running the function with Yahoo Finance historical data
trade_multiple_tickers(tickers, capital_per_trade, start_date, end_date)

import yfinance as yf
import pandas as pd

def calculate_indicators(data):
    # Calculate RSI
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    data['RSI'] = 100 - (100 / (1 + rs))

    # Calculate Moving Averages
    data['SMA_50'] = data['Close'].rolling(window=50).mean()
    data['SMA_200'] = data['Close'].rolling(window=200).mean()

    # Calculate MACD
    ema_12 = data['Close'].ewm(span=12, adjust=False).mean()
    ema_26 = data['Close'].ewm(span=26, adjust=False).mean()
    data['MACD'] = ema_12 - ema_26
    data['Signal_Line'] = data['MACD'].ewm(span=9, adjust=False).mean()

    # Calculate Bollinger Bands
    data['20_SMA'] = data['Close'].rolling(window=20).mean()
    data['Upper_Band'] = data['20_SMA'] + 2*data['Close'].rolling(window=20).std()
    data['Lower_Band'] = data['20_SMA'] - 2*data['Close'].rolling(window=20).std()

    # Calculate Stochastic Oscillator
    data['Lowest_Low'] = data['Low'].rolling(window=14).min()
    data['Highest_High'] = data['High'].rolling(window=14).max()
    data['%K'] = (data['Close'] - data['Lowest_Low']) * 100 / (data['Highest_High'] - data['Lowest_Low'])
    data['%D'] = data['%K'].rolling(window=3).mean()

    # Calculate Volume-based indicators (e.g., OBV)
    data['Volume_Change'] = data['Volume'].diff()

    return data

# Example usage:
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']
for ticker in tickers:
    historical_data = yf.download(ticker, start='2023-01-01', end='2023-12-31')
    data_with_indicators = calculate_indicators(historical_data)
    print(f"Indicators calculated for {ticker}")

def determine_action(data):
    actions = []
    for index, row in data.iterrows():
        action = 'hold'  # Default action is to hold

        # RSI Rule
        if row['RSI'] < 30:
            action = 'buy'
        elif row['RSI'] > 70:
            action = 'sell'

        # Moving Average Crossover Rule
        if row['SMA_50'] > row['SMA_200']:
            action = 'buy'
        elif row['SMA_50'] < row['SMA_200']:
            action = 'sell'

        # MACD Rule
        if row['MACD'] > row['Signal_Line']:
            action = 'buy'
        elif row['MACD'] < row['Signal_Line']:
            action = 'sell'

        # Bollinger Bands Rule
        if row['Close'] < row['Lower_Band']:
            action = 'buy'
        elif row['Close'] > row['Upper_Band']:
            action = 'sell'

        # Stochastic Oscillator Rule
        if row['%K'] > row['%D']:
            action = 'buy'
        elif row['%K'] < row['%D']:
            action = 'sell'

        actions.append(action)

    data['Action'] = actions
    return data

# Example usage with data containing indicators
for ticker in tickers:
    data_with_indicators = calculate_indicators(yf.download(ticker, start='2023-01-01', end='2023-12-31'))
    data_with_actions = determine_action(data_with_indicators)
    print(f"Actions determined for {ticker}")
    print(data_with_actions[['Close', 'RSI', 'SMA_50', 'SMA_200', 'MACD', 'Signal_Line', 'Action']].tail())

import numpy as np
import pandas as pd
import random

# Define Q-learning parameters
alpha = 0.1  # Learning rate
gamma = 0.9  # Discount factor
epsilon = 0.1  # Exploration rate (for epsilon-greedy)

# Define actions
ACTIONS = ['buy', 'sell', 'hold']

# Initialize the Q-table
Q_table = {}

# Function to get a state representation (RSI, SMA, Price, etc.)
def get_state(indicators):
    rsi = indicators['RSI']
    sma50 = indicators['SMA_50']
    price = indicators['Close']
    # You can include other indicators here as well
    state = (rsi, sma50, price)
    return state

# Choose an action using epsilon-greedy policy
def choose_action(state):
    if state not in Q_table:
        Q_table[state] = {action: 0 for action in ACTIONS}

    if random.uniform(0, 1) < epsilon:
        # Explore: choose a random action
        action = random.choice(ACTIONS)
    else:
        # Exploit: choose the action with the highest Q-value
        action = max(Q_table[state], key=Q_table[state].get)

    return action

# Reward function based on profit/loss
def calculate_reward(profit_or_loss):
    return profit_or_loss  # You can scale or adjust this reward

# Q-learning update rule
def update_Q_table(state, action, reward, next_state):
    if next_state not in Q_table:
        Q_table[next_state] = {action: 0 for action in ACTIONS}

    # Update the Q-value for the current state-action pair
    max_future_q = max(Q_table[next_state].values())
    current_q = Q_table[state][action]
    Q_table[state][action] = current_q + alpha * (reward + gamma * max_future_q - current_q)

# Simulation of the Q-learning process over historical data
def q_learning_simulation(historical_data):
    total_profit = 0
    current_position = None  # Keeps track of whether we have an open position

    for index, row in historical_data.iterrows():
        # Get the current state
        state = get_state(row)

        # Choose an action (buy, sell, or hold)
        action = choose_action(state)

        # Execute the action
        if action == 'buy' and current_position is None:
            buy_price = row['Close']
            current_position = buy_price
        elif action == 'sell' and current_position is not None:
            sell_price = row['Close']
            profit_or_loss = sell_price - current_position
            total_profit += profit_or_loss

            # Reward for selling
            reward = calculate_reward(profit_or_loss)
            next_state = get_state(row)
            update_Q_table(state, action, reward, next_state)

            # Reset the position
            current_position = None
        else:
            # Hold action or when no valid buy/sell conditions exist
            reward = 0
            next_state = get_state(row)
            update_Q_table(state, action, reward, next_state)

    return total_profit

# Running the simulation on a sample dataset (historical_data should be fetched for a specific stock)
# Example usage:
# historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-12-31')
# total_profit = q_learning_simulation(historical_data)
# print("Total Profit from Q-learning:", total_profit)

# List of tickers for the top 25 stocks (you can adjust this list)
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']  # Add the other stocks as needed

# Function to fetch data for multiple tickers and run Q-learning simulation
def run_q_learning_for_multiple_tickers(tickers):
    total_profit = 0

    for ticker in tickers:
        print(f"Fetching data for {ticker}...")
        historical_data = fetch_historical_data(ticker, '2023-01-01', '2023-12-31')  # Adjust date range as needed

        if historical_data is not None:
            print(f"Running Q-learning simulation for {ticker}...")
            profit = q_learning_simulation(historical_data)
            total_profit += profit
            print(f"Total profit for {ticker}: {profit}")
        else:
            print(f"No data found for {ticker}. Skipping...")

    print(f"Total profit across all tickers: {total_profit}")

# Example usage:
run_q_learning_for_multiple_tickers(tickers)

import pandas as pd

def fetch_and_calculate_indicators(symbol, start_date, end_date):
    # Fetch historical data
    data = fetch_historical_data(symbol, start_date, end_date)

    if data is None or data.empty:
        print(f"No data found for {symbol}")
        return None

    # Calculate indicators (like RSI)
    data['RSI'] = calculate_rsi(data['Close'], window=14)  # Assuming 14-day RSI
    data['SMA_50'] = data['Close'].rolling(window=50).mean()
    data['SMA_200'] = data['Close'].rolling(window=200).mean()
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])

    # Remove rows with NaN values (due to rolling windows)
    data = data.dropna()

    return data

def run_q_learning_for_multiple_tickers(tickers):
    total_profit = 0

    for ticker in tickers:
        print(f"Fetching data for {ticker} and calculating indicators...")
        historical_data = fetch_and_calculate_indicators(ticker, '2023-01-01', '2023-12-31')  # Adjust date range

        if historical_data is not None and 'RSI' in historical_data.columns:
            print(f"Running Q-learning simulation for {ticker}...")
            profit = q_learning_simulation(historical_data)
            total_profit += profit
            print(f"Total profit for {ticker}: {profit}")
        else:
            print(f"RSI or data not available for {ticker}. Skipping...")

    print(f"Total profit across all tickers: {total_profit}")

# Example usage:
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']  # Add more tickers as needed
run_q_learning_for_multiple_tickers(tickers)

def calculate_rsi(prices, window=14):
    delta = prices.diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

import pandas as pd

# Define RSI calculation
def calculate_rsi(prices, window=14):
    delta = prices.diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def fetch_and_calculate_indicators(symbol, start_date, end_date):
    # Fetch historical data
    data = fetch_historical_data(symbol, start_date, end_date)

    if data is None or data.empty:
        print(f"No data found for {symbol}")
        return None

    # Calculate indicators (like RSI)
    data['RSI'] = calculate_rsi(data['Close'], window=14)  # Assuming 14-day RSI
    data['SMA_50'] = data['Close'].rolling(window=50).mean()
    data['SMA_200'] = data['Close'].rolling(window=200).mean()
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])

    # Remove rows with NaN values (due to rolling windows)
    data = data.dropna()

    return data

def run_q_learning_for_multiple_tickers(tickers):
    total_profit = 0

    for ticker in tickers:
        print(f"Fetching data for {ticker} and calculating indicators...")
        historical_data = fetch_and_calculate_indicators(ticker, '2023-01-01', '2023-12-31')  # Adjust date range

        if historical_data is not None and 'RSI' in historical_data.columns:
            print(f"Running Q-learning simulation for {ticker}...")
            profit = q_learning_simulation(historical_data)
            total_profit += profit
            print(f"Total profit for {ticker}: {profit}")
        else:
            print(f"RSI or data not available for {ticker}. Skipping...")

    print(f"Total profit across all tickers: {total_profit}")

# Example usage:
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']  # Add more tickers as needed
run_q_learning_for_multiple_tickers(tickers)

def calculate_macd(prices, slow=26, fast=12, signal=9):
    exp1 = prices.ewm(span=fast, adjust=False).mean()  # Fast EMA
    exp2 = prices.ewm(span=slow, adjust=False).mean()  # Slow EMA
    macd = exp1 - exp2  # MACD line
    signal_line = macd.ewm(span=signal, adjust=False).mean()  # Signal line
    return macd, signal_line

import pandas as pd

# Define RSI calculation
def calculate_rsi(prices, window=14):
    delta = prices.diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Define MACD calculation
def calculate_macd(prices, slow=26, fast=12, signal=9):
    exp1 = prices.ewm(span=fast, adjust=False).mean()  # Fast EMA
    exp2 = prices.ewm(span=slow, adjust=False).mean()  # Slow EMA
    macd = exp1 - exp2  # MACD line
    signal_line = macd.ewm(span=signal, adjust=False).mean()  # Signal line
    return macd, signal_line

def fetch_and_calculate_indicators(symbol, start_date, end_date):
    # Fetch historical data
    data = fetch_historical_data(symbol, start_date, end_date)

    if data is None or data.empty:
        print(f"No data found for {symbol}")
        return None

    # Calculate indicators (like RSI and MACD)
    data['RSI'] = calculate_rsi(data['Close'], window=14)  # Assuming 14-day RSI
    data['SMA_50'] = data['Close'].rolling(window=50).mean()
    data['SMA_200'] = data['Close'].rolling(window=200).mean()
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])

    # Remove rows with NaN values (due to rolling windows)
    data = data.dropna()

    return data

def run_q_learning_for_multiple_tickers(tickers):
    total_profit = 0

    for ticker in tickers:
        print(f"Fetching data for {ticker} and calculating indicators...")
        historical_data = fetch_and_calculate_indicators(ticker, '2023-01-01', '2023-12-31')  # Adjust date range

        if historical_data is not None and 'RSI' in historical_data.columns:
            print(f"Running Q-learning simulation for {ticker}...")
            profit = q_learning_simulation(historical_data)
            total_profit += profit
            print(f"Total profit for {ticker}: {profit}")
        else:
            print(f"RSI or data not available for {ticker}. Skipping...")

    print(f"Total profit across all tickers: {total_profit}")

# Example usage:
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']  # Add more tickers as needed
run_q_learning_for_multiple_tickers(tickers)

import numpy as np

# Define the initial Q-learning parameters
learning_rates = [0.01, 0.05, 0.1]  # Alpha: learning rate
discount_factors = [0.9, 0.95, 0.99]  # Gamma: discount factor
exploration_rates = [0.1, 0.3, 0.5]  # Epsilon: exploration rate

# Initialize results tracking
best_total_profit = float('-inf')
best_params = {}

def optimize_q_learning(tickers, learning_rates, discount_factors, exploration_rates):
    global best_total_profit, best_params

    for alpha in learning_rates:
        for gamma in discount_factors:
            for epsilon in exploration_rates:
                print(f"Running with Alpha: {alpha}, Gamma: {gamma}, Epsilon: {epsilon}")

                total_profit = 0  # Reset total profit for each run

                # Run the Q-learning simulation for each ticker
                for ticker in tickers:
                    profit = run_q_learning(ticker, alpha, gamma, epsilon)
                    total_profit += profit

                # Track the best performance
                if total_profit > best_total_profit:
                    best_total_profit = total_profit
                    best_params = {'alpha': alpha, 'gamma': gamma, 'epsilon': epsilon}

    print(f"Best parameters: {best_params} with total profit: {best_total_profit}")

# Example tickers and running optimization
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']
optimize_q_learning(tickers, learning_rates, discount_factors, exploration_rates)

import random

# Simulating the run_q_learning function for each ticker
def run_q_learning(ticker, alpha, gamma, epsilon):
    print(f"Running Q-learning for {ticker} with Alpha: {alpha}, Gamma: {gamma}, Epsilon: {epsilon}")

    # Simulate historical data and indicators
    historical_data = fetch_and_calculate_indicators(ticker, '2023-01-01', '2023-12-31')

    # Simulate Q-learning process (this is where the real logic would go)
    # For now, we'll simulate profits and losses based on random choice
    # In a real scenario, this would use indicators and update Q-values.

    total_profit = 0  # Track the profit for this ticker

    # Simulate trading over the data
    for index, row in historical_data.iterrows():
        # Example: use random to decide buy/sell based on exploration rate
        if random.random() < epsilon:
            action = 'buy' if random.random() > 0.5 else 'sell'
        else:
            # Use some logic to decide based on the data (dummy logic for now)
            action = 'buy' if row['RSI'] < 30 else 'sell' if row['RSI'] > 70 else 'hold'

        # Simulate a profit/loss for each trade
        if action == 'buy':
            total_profit += random.uniform(1, 10)  # Random profit for buying
        elif action == 'sell':
            total_profit -= random.uniform(1, 10)  # Random loss for selling

    return total_profit  # Return the simulated profit for this ticker

# Example usage with the previously defined optimization
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']
optimize_q_learning(tickers, learning_rates, discount_factors, exploration_rates)

def run_q_learning(ticker, alpha, gamma, epsilon):
    print(f"Running Q-learning for {ticker} with Alpha: {alpha}, Gamma: {gamma}, Epsilon: {epsilon}")

    # Simulate historical data and indicators
    historical_data = fetch_and_calculate_indicators(ticker, '2023-01-01', '2023-12-31')

    # Initialize variables for tracking
    total_profit = 0
    wins = 0
    losses = 0
    trades = 0

    # Simulate trading over the data
    for index, row in historical_data.iterrows():
        # Example: use random to decide buy/sell based on exploration rate
        if random.random() < epsilon:
            action = 'buy' if random.random() > 0.5 else 'sell'
        else:
            action = 'buy' if row['RSI'] < 30 else 'sell' if row['RSI'] > 70 else 'hold'

        # Simulate a profit/loss for each trade
        if action == 'buy':
            profit = random.uniform(1, 10)  # Random profit for buying
            total_profit += profit
            wins += 1
            trades += 1
        elif action == 'sell':
            loss = random.uniform(1, 10)  # Random loss for selling
            total_profit -= loss
            losses += 1
            trades += 1

    return total_profit, wins, losses, trades

def optimize_q_learning(tickers, learning_rates, discount_factors, exploration_rates):
    best_params = None
    best_profit = float('-inf')

    # Run optimization over each combination of parameters
    for alpha in learning_rates:
        for gamma in discount_factors:
            for epsilon in exploration_rates:
                print(f"\nRunning with Alpha: {alpha}, Gamma: {gamma}, Epsilon: {epsilon}")
                total_profit = 0
                total_wins = 0
                total_losses = 0
                total_trades = 0

                # Run the Q-learning simulation for each ticker
                for ticker in tickers:
                    profit, wins, losses, trades = run_q_learning(ticker, alpha, gamma, epsilon)
                    total_profit += profit
                    total_wins += wins
                    total_losses += losses
                    total_trades += trades

                    print(f"Ticker: {ticker}, Profit: {profit}, Wins: {wins}, Losses: {losses}, Trades: {trades}")

                # Update the best parameters if current one is better
                if total_profit > best_profit:
                    best_profit = total_profit
                    best_params = {'alpha': alpha, 'gamma': gamma, 'epsilon': epsilon}

                print(f"Total Profit: {total_profit}, Win Rate: {total_wins / total_trades:.2%}, "
                      f"Loss

def run_q_learning(ticker, alpha, gamma, epsilon):
    print(f"Running Q-learning for {ticker} with Alpha: {alpha}, Gamma: {gamma}, Epsilon: {epsilon}")

    # Simulate historical data and indicators
    historical_data = fetch_and_calculate_indicators(ticker, '2023-01-01', '2023-12-31')

    # Initialize variables for tracking
    total_profit = 0
    wins = 0
    losses = 0
    trades = 0

    # Simulate trading over the data
    for index, row in historical_data.iterrows():
        # Example: use random to decide buy/sell based on exploration rate
        if random.random() < epsilon:
            action = 'buy' if random.random() > 0.5 else 'sell'
        else:
            action = 'buy' if row['RSI'] < 30 else 'sell' if row['RSI'] > 70 else 'hold'

        # Simulate a profit/loss for each trade
        if action == 'buy':
            profit = random.uniform(1, 10)  # Random profit for buying
            total_profit += profit
            wins += 1
            trades += 1
        elif action == 'sell':
            loss = random.uniform(1, 10)  # Random loss for selling
            total_profit -= loss
            losses += 1
            trades += 1

    return total_profit, wins, losses, trades

def optimize_q_learning(tickers, learning_rates, discount_factors, exploration_rates):
    best_params = None
    best_profit = float('-inf')

    # Run optimization over each combination of parameters
    for alpha in learning_rates:
        for gamma in discount_factors:
            for epsilon in exploration_rates:
                print(f"\nRunning with Alpha: {alpha}, Gamma: {gamma}, Epsilon: {epsilon}")
                total_profit = 0
                total_wins = 0
                total_losses = 0
                total_trades = 0

                # Run the Q-learning simulation for each ticker
                for ticker in tickers:
                    profit, wins, losses, trades = run_q_learning(ticker, alpha, gamma, epsilon)
                    total_profit += profit
                    total_wins += wins
                    total_losses += losses
                    total_trades += trades

                    print(f"Ticker: {ticker}, Profit: {profit}, Wins: {wins}, Losses: {losses}, Trades: {trades}")

                # Update the best parameters if current one is better
                if total_profit > best_profit:
                    best_profit = total_profit
                    best_params = {'alpha': alpha, 'gamma': gamma, 'epsilon': epsilon}

                print(f"Total Profit: {total_profit}, Win Rate: {total_wins / total_trades:.2%}, "
                      f"Loss Rate: {total_losses / total_trades:.2%}")

    print(f"\nBest parameters: {best_params} with total profit: {best_profit}")

def run_q_learning(ticker, alpha, gamma, epsilon):
    print(f"Running Q-learning for {ticker} with Alpha: {alpha}, Gamma: {gamma}, Epsilon: {epsilon}")

    # Simulate historical data and indicators
    historical_data = fetch_and_calculate_indicators(ticker, '2023-01-01', '2023-12-31')

    # Initialize variables for tracking
    total_profit = 0
    wins = 0
    losses = 0
    trades = 0

    # Simulate trading over the data
    for index, row in historical_data.iterrows():
        # Example: use random to decide buy/sell based on exploration rate
        if random.random() < epsilon:
            action = 'buy' if random.random() > 0.5 else 'sell'
        else:
            action = 'buy' if row['RSI'] < 30 else 'sell' if row['RSI'] > 70 else 'hold'

        # Simulate a profit/loss for each trade
        if action == 'buy':
            profit = random.uniform(1, 10)  # Random profit for buying
            total_profit += profit
            wins += 1
            trades += 1
        elif action == 'sell':
            loss = random.uniform(1, 10)  # Random loss for selling
            total_profit -= loss
            losses += 1
            trades += 1

    return total_profit, wins, losses, trades

def optimize_q_learning(tickers, learning_rates, discount_factors, exploration_rates):
    best_params = None
    best_profit = float('-inf')

    # Run optimization over each combination of parameters
    for alpha in learning_rates:
        for gamma in discount_factors:
            for epsilon in exploration_rates:
                print(f"\nRunning with Alpha: {alpha}, Gamma: {gamma}, Epsilon: {epsilon}")
                total_profit = 0
                total_wins = 0
                total_losses = 0
                total_trades = 0

                # Run the Q-learning simulation for each ticker
                for ticker in tickers:
                    profit, wins, losses, trades = run_q_learning(ticker, alpha, gamma, epsilon)
                    total_profit += profit
                    total_wins += wins
                    total_losses += losses
                    total_trades += trades

                    print(f"Ticker: {ticker}, Profit: {profit:.2f}, Wins: {wins}, Losses: {losses}, Trades: {trades}")

                # Update the best parameters if current one is better
                if total_profit > best_profit:
                    best_profit = total_profit
                    best_params = {'alpha': alpha, 'gamma': gamma, 'epsilon': epsilon}

                print(f"Total Profit: {total_profit:.2f}, Win Rate: {total_wins / total_trades:.2%}, "
                      f"Loss Rate: {total_losses / total_trades:.2%}")

    print(f"\nBest parameters: {best_params} with total profit: {best_profit:.2f}")

# Example tickers and running optimization
tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']
learning_rates = [0.01, 0.1]
discount_factors = [0.9, 0.95, 0.99]
exploration_rates = [0.1, 0.3, 0.5]

optimize_q_learning(tickers, learning_rates, discount_factors, exploration_rates)

class RiskManagement:
    def __init__(self, initial_capital=200, max_daily_loss=50):
        self.initial_capital = initial_capital
        self.max_daily_loss = max_daily_loss
        self.current_capital = initial_capital
        self.daily_profit = 0
        self.daily_loss = 0
        self.total_profit = 0
        self.daily_limit_reached = False

    def update_capital(self, profit_loss):
        """Update capital based on profits and losses."""
        self.daily_profit += profit_loss if profit_loss > 0 else 0
        self.daily_loss += abs(profit_loss) if profit_loss < 0 else 0
        self.total_profit += profit_loss

        # Stop trading if max daily loss is reached
        if self.daily_loss >= self.max_daily_loss:
            self.daily_limit_reached = True
            print(f"Max daily loss of ${self.max_daily_loss} reached. Stopping trading for today.")
            return False

        # Allow bot to use profits for additional capital
        if self.daily_profit > 0:
            self.current_capital = self.initial_capital + (self.daily_profit * 0.25)  # Use 25% of profits for additional capital
        else:
            self.current_capital = self.initial_capital  # Reset to initial capital if no profit

        return True

    def get_trade_amount(self):
        """Calculate the amount to trade based on available capital."""
        return min(5, self.current_capital * 0.05)  # Trade no more than 5% of available capital

    def reset_daily_stats(self):
        """Reset daily stats at the beginning of a new day."""
        self.daily_profit = 0
        self.daily_loss = 0
        self.daily_limit_reached = False
        self.current_capital = self.initial_capital

class PerformanceMetrics:
    def __init__(self):
        self.total_profit = 0
        self.total_loss = 0
        self.win_trades = 0
        self.loss_trades = 0
        self.total_trades = 0
        self.trade_history = []

    def record_trade(self, profit_loss):
        """Record a trade's profit or loss and update metrics."""
        self.total_trades += 1
        self.trade_history.append(profit_loss)

        if profit_loss > 0:
            self.total_profit += profit_loss
            self.win_trades += 1
        else:
            self.total_loss += abs(profit_loss)
            self.loss_trades += 1

    def get_win_rate(self):
        """Calculate win rate."""
        if self.total_trades == 0:
            return 0
        return (self.win_trades / self.total_trades) * 100

    def get_average_profit_loss(self):
        """Calculate average profit/loss per trade."""
        if self.total_trades == 0:
            return 0
        return (self.total_profit - self.total_loss) / self.total_trades

    def print_summary(self):
        """Print a summary of performance metrics."""
        print("Performance Summary:")
        print(f"Total Trades: {self.total_trades}")
        print(f"Total Profit: ${self.total_profit:.2f}")
        print(f"Total Loss: ${self.total_loss:.2f}")
        print(f"Win Rate: {self.get_win_rate():.2f}%")
        print(f"Average Profit/Loss per Trade: ${self.get_average_profit_loss():.2f}")

# Example Usage:
performance_tracker = PerformanceMetrics()

# After every trade, record the profit/loss
performance_tracker.record_trade(20)   # Profitable trade
performance_tracker.record_trade(-10)  # Losing trade

# Print the performance summary
performance_tracker.print_summary()

# Assume you already have the logic for executing trades

def execute_trade(symbol, action, current_price, previous_buy_price=None):
    """Function to execute a trade (buy or sell) and record performance."""
    global performance_tracker

    if action == 'buy':
        print(f"Buying {symbol} at {current_price}")
        # Record the trade as a buy, but no profit/loss yet
        log_trade(symbol, 'buy', current_price, None)

    elif action == 'sell' and previous_buy_price is not None:
        profit_loss = current_price - previous_buy_price
        print(f"Selling {symbol} at {current_price} - Profit/Loss: {profit_loss}")

        # Record trade and update performance metrics
        log_trade(symbol, 'sell', current_price, profit_loss)
        performance_tracker.record_trade(profit_loss)  # Record the trade

# Periodically print performance summary (e.g., end of trading day)
performance_tracker.print_summary()

# After every 10 trades or at the end of the day
if performance_tracker.total_trades % 10 == 0:
    performance_tracker.print_summary()

import time
import logging

# Set up basic logging
logging.basicConfig(level=logging.INFO)

def fetch_data_with_retry(symbol, retries=3, delay=5):
    """Fetch historical data with retry logic."""
    for attempt in range(1, retries + 1):
        try:
            # Try to fetch data
            data = fetch_historical_data(symbol)
            if data is not None and not data.empty:
                logging.info(f"Fetched data for {symbol}")
                return data
            else:
                raise ValueError(f"No data found for {symbol}")

        except Exception as e:
            logging.warning(f"Attempt {attempt} failed for {symbol}: {e}")
            if attempt < retries:
                time.sleep(delay)
            else:
                logging.error(f"Failed to fetch data for {symbol} after {retries} attempts")
                return None  # or handle the failure appropriately

def execute_trade_with_retry(symbol, action, price, previous_price=None, retries=3, delay=5):
    """Execute trade with retry logic."""
    for attempt in range(1, retries + 1):
        try:
            if action == 'buy':
                logging.info(f"Buying {symbol} at {price}")
                log_trade(symbol, 'buy', price, None)
            elif action == 'sell' and previous_price is not None:
                profit_loss = price - previous_price
                logging.info(f"Selling {symbol} at {price} - Profit/Loss: {profit_loss}")
                log_trade(symbol, 'sell', price, profit_loss)
                performance_tracker.record_trade(profit_loss)
            return  # Trade successful

        except Exception as e:
            logging.warning(f"Attempt {attempt} failed for {symbol}: {e}")
            if attempt < retries:
                time.sleep(delay)
            else:
                logging.error(f"Failed to execute trade for {symbol} after {retries} attempts")
                return None

# Example usage within your trading loop
symbols = ['AAPL', 'GOOGL', 'MSFT']
for symbol in symbols:
    data = fetch_data_with_retry(symbol)
    if data is not None:
        # Continue with trading logic...
        current_price = get_live_data(symbol)  # Example live data fetch
        execute_trade_with_retry(symbol, 'buy', current_price)

def fetch_data_with_retry(symbol, start_date, end_date, retries=3, delay=5):
    """Fetch historical data with retry logic, ensuring start_date and end_date are passed."""
    for attempt in range(1, retries + 1):
        try:
            # Try to fetch data
            data = fetch_historical_data(symbol, start_date, end_date)
            if data is not None and not data.empty:
                logging.info(f"Fetched data for {symbol}")
                return data
            else:
                raise ValueError(f"No data found for {symbol}")

        except Exception as e:
            logging.warning(f"Attempt {attempt} failed for {symbol}: {e}")
            if attempt < retries:
                time.sleep(delay)
            else:
                logging.error(f"Failed to fetch data for {symbol} after {retries} attempts")
                return None  # or handle the failure appropriately

symbols = ['AAPL', 'GOOGL', 'MSFT']
start_date = '2023-01-01'
end_date = '2023-12-31'

for symbol in symbols:
    data = fetch_data_with_retry(symbol, start_date, end_date)
    if data is not None:
        # Continue with trading logic...
        current_price = get_live_data(symbol)
        execute_trade_with_retry(symbol, 'buy', current_price)

import yfinance as yf

def get_live_data(symbol):
    """Fetch the latest price data for a symbol using yfinance."""
    try:
        ticker = yf.Ticker(symbol)
        todays_data = ticker.history(period='1d')
        if not todays_data.empty:
            current_price = todays_data['Close'][0]
            return current_price
        else:
            raise ValueError(f"No data found for {symbol}")
    except Exception as e:
        logging.error(f"Error fetching live data for {symbol}: {e}")
        return None

symbols = ['AAPL', 'GOOGL', 'MSFT']
start_date = '2023-01-01'
end_date = '2023-12-31'

for symbol in symbols:
    data = fetch_data_with_retry(symbol, start_date, end_date)
    if data is not None:
        # Fetch live data and continue with trading logic
        current_price = get_live_data(symbol)
        if current_price:
            execute_trade_with_retry(symbol, 'buy', current_price)

current_price = todays_data['Close'][0]

current_price = todays_data['Close'].iloc[0]

import yfinance as yf
import logging

def get_latest_available_data(symbol):
    """Fetch the most recent available price for a symbol using yfinance, even when the market is closed."""
    try:
        ticker = yf.Ticker(symbol)
        data = ticker.history(period='5d')  # Fetch the last 5 days of data
        if not data.empty:
            latest_price = data['Close'].iloc[-1]  # Get the most recent close price
            print(f"Latest available price for {symbol}: {latest_price}")
            return latest_price
        else:
            raise ValueError(f"No data found for {symbol}")
    except Exception as e:
        logging.error(f"Error fetching data for {symbol}: {e}")
        return None

def execute_trade_with_retry(symbol, action, price):
    """Attempts to execute a trade with retry logic."""
    max_attempts = 3
    for attempt in range(max_attempts):
        try:
            print(f"Executing {action} for {symbol} at {price}")
            log_trade(symbol, action, price)
            break
        except Exception as e:
            logging.warning(f"Attempt {attempt + 1} failed for {symbol}: {e}")
            if attempt == max_attempts - 1:
                logging.error(f"Failed to execute trade for {symbol} after {max_attempts} attempts")

def log_trade(symbol, action, price, profit_loss=None):
    """Logs a trade (buy or sell) with the relevant details."""
    try:
        log_message = f"Trade executed: {symbol}, Action: {action}, Price: {price}"
        if profit_loss is not None:
            log_message += f", Profit/Loss: {profit_loss}"
        logging.info(log_message)
        print(log_message)  # For immediate console feedback

        with open('trade_log.csv', 'a') as f:
            f.write(f"{symbol},{action},{price},{profit_loss}\n")

    except Exception as e:
        logging.error(f"Error logging trade for {symbol}: {e}")

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']
for symbol in symbols:
    current_price = get_latest_available_data(symbol)  # Fetch latest available price
    if current_price:
        execute_trade_with_retry(symbol, 'buy', current_price)

daily_loss_limit = 50  # Set the daily loss limit to $50
total_daily_loss = 0  # Track the total loss for the day

def execute_trade_with_stop_loss(symbol, action, current_price, stop_loss_percentage=0.05):
    global total_daily_loss

    # Calculate stop loss level (for buys)
    if action == 'buy':
        stop_loss = current_price * (1 - stop_loss_percentage)
        log_trade(symbol, action, current_price, None)

    elif action == 'sell':
        previous_buy_price = get_previous_buy_price(symbol)  # Fetch the previous buy price
        if previous_buy_price is not None:
            profit_loss = current_price - previous_buy_price
            total_daily_loss += max(0, -profit_loss)  # Add only the losses to total daily loss

            # Log and print the trade
            log_trade(symbol, action, current_price, profit_loss)
            print(f"Executed {action} for {symbol} at {current_price}. Profit/Loss: {profit_loss}")

            # Check if daily loss limit is exceeded
            if total_daily_loss >= daily_loss_limit:
                print(f"Daily loss limit of ${daily_loss_limit} reached. Stopping further trades for the day.")
                return False
    return True

def monitor_open_positions(symbol, current_price, stop_loss):
    # If the current price falls below the stop-loss level, trigger a sell
    if current_price <= stop_loss:
        print(f"Stop-loss triggered for {symbol} at {current_price}.")
        execute_trade_with_stop_loss(symbol, 'sell', current_price)

import random

daily_loss_limit = 50  # Set the daily loss limit to $50
total_daily_loss = 0  # Track the total loss for the day

# Example function to simulate getting live prices for testing
def simulate_price_movement(base_price):
    return base_price * random.uniform(0.9, 1.1)

def execute_trade_with_stop_loss(symbol, action, current_price, stop_loss_percentage=0.05):
    global total_daily_loss

    # Calculate stop loss level (for buys)
    if action == 'buy':
        stop_loss = current_price * (1 - stop_loss_percentage)
        log_trade(symbol, action, current_price, None)
        return stop_loss  # Return the stop loss level for this trade

    elif action == 'sell':
        previous_buy_price = get_previous_buy_price(symbol)  # Fetch the previous buy price
        if previous_buy_price is not None:
            profit_loss = current_price - previous_buy_price
            total_daily_loss += max(0, -profit_loss)  # Add only the losses to total daily loss

            # Log and print the trade
            log_trade(symbol, action, current_price, profit_loss)
            print(f"Executed {action} for {symbol} at {current_price}. Profit/Loss: {profit_loss}")

            # Check if daily loss limit is exceeded
            if total_daily_loss >= daily_loss_limit:
                print(f"Daily loss limit of ${daily_loss_limit} reached. Stopping further trades for the day.")
                return False
    return True

# Test function for simulating a trading day
def simulate_trading_day():
    tickers = ['AAPL', 'GOOGL', 'MSFT']  # Example tickers
    stop_losses = {}

    for ticker in tickers:
        current_price = simulate_price_movement(100)  # Simulate current price
        print(f"Simulated price for {ticker}: {current_price}")

        # Simulate buy
        stop_loss = execute_trade_with_stop_loss(ticker, 'buy', current_price)
        stop_losses[ticker] = stop_loss  # Store stop-loss for this position

        # Simulate price movement and check stop-loss
        new_price = simulate_price_movement(current_price)
        print(f"New price for {ticker}: {new_price}")

        # Trigger sell if stop-loss is hit
        if new_price <= stop_losses[ticker]:
            execute_trade_with_stop_loss(ticker, 'sell', new_price)

        # If daily loss limit is reached, stop further trades
        if total_daily_loss >= daily_loss_limit:
            print("Stopping trading for the day.")
            break

# Running the simulation
simulate_trading_day()

# Let's set up initial parameters and track daily profits and losses.
initial_capital = 200  # Total daily max
max_loss_per_day = 50  # Stop loss at $50
capital_per_trade = 5  # Initial amount per trade

# Tracking profits and losses
total_daily_profit = 0  # Daily profit tracker
total_daily_trades = 0  # Number of trades made
previous_day_profit = 0  # Profit from the previous day to adjust the next day's capital

# Simulating trades for a given day
def simulate_trades_for_day(symbols, previous_day_profit):
    global initial_capital, total_daily_profit, total_daily_trades

    # Increase the daily capital based on the previous day's profit
    daily_capital = initial_capital + previous_day_profit

    # Loop through the tickers
    for symbol in symbols:
        if daily_capital <= 0 or total_daily_profit <= -max_loss_per_day:
            print(f"Max daily loss reached or no capital left. Stopping trades for today.")
            break

        # Simulate getting the live price
        current_price = get_simulated_price(symbol)  # Assuming this function generates simulated prices

        # If there’s enough capital, execute the trade
        if daily_capital >= capital_per_trade:
            print(f"Simulated price for {symbol}: {current_price}")
            trade_amount = min(capital_per_trade, daily_capital)  # Ensure the trade doesn't exceed available capital
            execute_trade(symbol, 'buy', current_price, trade_amount)  # Execute the trade

            # Calculate new daily capital and track profit/loss
            new_price = get_simulated_price(symbol)  # New simulated price
            profit_loss = (new_price - current_price) * (trade_amount / current_price)

            print(f"New price for {symbol}: {new_price}")
            total_daily_profit += profit_loss
            daily_capital -= trade_amount  # Decrease available capital
            total_daily_trades += 1

            print(f"Trade executed: {symbol}, Profit/Loss: {profit_loss}, Total daily profit: {total_daily_profit}")

        if total_daily_profit <= -max_loss_per_day:
            print(f"Max daily loss limit hit. Stopping trading for {symbol}.")
            break

    return total_daily_profit

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Sample stock symbols
total_profit_today = simulate_trades_for_day(symbols, previous_day_profit)

# Adjust capital for the next day based on today's profit
if total_profit_today > 0:
    previous_day_profit = total_profit_today
else:
    previous_day_profit = 0  # Reset if no profit was made

print(f"Total profit today: {total_profit_today}")
print(f"Capital for tomorrow: {initial_capital + previous_day_profit}")

import random

# Function to simulate price changes for testing
def get_simulated_price(symbol):
    # Generate a random price between $100 and $500 for simplicity
    return random.uniform(100, 500)

# Let's set up initial parameters and track daily profits and losses.
initial_capital = 200  # Total daily max
max_loss_per_day = 50  # Stop loss at $50
capital_per_trade = 5  # Initial amount per trade

# Tracking profits and losses
total_daily_profit = 0  # Daily profit tracker
total_daily_trades = 0  # Number of trades made
previous_day_profit = 0  # Profit from the previous day to adjust the next day's capital

# Simulating trades for a given day
def simulate_trades_for_day(symbols, previous_day_profit):
    global initial_capital, total_daily_profit, total_daily_trades

    # Increase the daily capital based on the previous day's profit
    daily_capital = initial_capital + previous_day_profit

    # Loop through the tickers
    for symbol in symbols:
        if daily_capital <= 0 or total_daily_profit <= -max_loss_per_day:
            print(f"Max daily loss reached or no capital left. Stopping trades for today.")
            break

        # Simulate getting the live price
        current_price = get_simulated_price(symbol)  # Simulated price

        # If there’s enough capital, execute the trade
        if daily_capital >= capital_per_trade:
            print(f"Simulated price for {symbol}: {current_price}")
            trade_amount = min(capital_per_trade, daily_capital)  # Ensure the trade doesn't exceed available capital
            execute_trade(symbol, 'buy', current_price, trade_amount)  # Execute the trade

            # Calculate new daily capital and track profit/loss
            new_price = get_simulated_price(symbol)  # New simulated price
            profit_loss = (new_price - current_price) * (trade_amount / current_price)

            print(f"New price for {symbol}: {new_price}")
            total_daily_profit += profit_loss
            daily_capital -= trade_amount  # Decrease available capital
            total_daily_trades += 1

            print(f"Trade executed: {symbol}, Profit/Loss: {profit_loss}, Total daily profit: {total_daily_profit}")

        if total_daily_profit <= -max_loss_per_day:
            print(f"Max daily loss limit hit. Stopping trading for {symbol}.")
            break

    return total_daily_profit

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Sample stock symbols
total_profit_today = simulate_trades_for_day(symbols, previous_day_profit)

# Adjust capital for the next day based on today's profit
if total_profit_today > 0:
    previous_day_profit = total_profit_today
else:
    previous_day_profit = 0  # Reset if no profit was made

print(f"Total profit today: {total_profit_today}")
print(f"Capital for tomorrow: {initial_capital + previous_day_profit}")

import numpy as np

# Function to log trades and calculate additional metrics
def log_trade_with_metrics(symbol, action, price, profit_loss, trades_log):
    trades_log.append({
        'symbol': symbol,
        'action': action,
        'price': price,
        'profit_loss': profit_loss,
    })
    print(f"Trade executed: {symbol}, Action: {action}, Price: {price}, Profit/Loss: {profit_loss}")

# Calculate Sharpe Ratio and Drawdown
def calculate_performance_metrics(trades_log):
    profits_losses = [trade['profit_loss'] for trade in trades_log if trade['profit_loss'] is not None]

    if not profits_losses:
        return {"Sharpe Ratio": 0, "Max Drawdown": 0, "Max Profit": 0, "Max Loss": 0}

    mean_profit = np.mean(profits_losses)
    std_dev = np.std(profits_losses)
    sharpe_ratio = mean_profit / std_dev if std_dev != 0 else 0

    max_drawdown = np.min(profits_losses)
    max_profit = np.max(profits_losses)
    max_loss = np.min(profits_losses)

    return {
        "Sharpe Ratio": sharpe_ratio,
        "Max Drawdown": max_drawdown,
        "Max Profit": max_profit,
        "Max Loss": max_loss
    }

# Example usage
trades_log = []

# Simulate trades
log_trade_with_metrics('AAPL', 'buy', 150.0, 5.0, trades_log)
log_trade_with_metrics('AAPL', 'sell', 155.0, 5.0, trades_log)
log_trade_with_metrics('GOOGL', 'buy', 120.0, -2.0, trades_log)
log_trade_with_metrics('MSFT', 'sell', 200.0, 10.0, trades_log)

# Calculate and display performance metrics
metrics = calculate_performance_metrics(trades_log)
print(f"Performance Metrics: {metrics}")

# Function to check if daily loss limit is reached
def check_daily_loss_limit(total_daily_loss, max_loss_limit):
    if total_daily_loss <= -max_loss_limit:
        print(f"Daily loss limit of ${max_loss_limit} reached. Stopping trading for today.")
        return True
    return False

# Function to execute trades with risk management
def execute_trade_with_risk_management(symbol, action, price, current_capital, total_daily_profit, total_daily_loss, trades_log, max_loss_limit=50):
    if check_daily_loss_limit(total_daily_loss, max_loss_limit):
        return current_capital, total_daily_profit, total_daily_loss

    # Simulate profit/loss
    profit_loss = np.random.uniform(-5, 5)  # Random profit/loss for demonstration
    total_daily_profit += profit_loss
    total_daily_loss += profit_loss if profit_loss < 0 else 0

    # Log the trade
    log_trade_with_metrics(symbol, action, price, profit_loss, trades_log)

    # Update capital
    current_capital += profit_loss
    return current_capital, total_daily_profit, total_daily_loss

# Example usage
starting_capital = 200
total_daily_profit = 0
total_daily_loss = 0
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Sample symbols
trades_log = []

for symbol in symbols:
    price = np.random.uniform(100, 200)  # Simulated stock price
    starting_capital, total_daily_profit, total_daily_loss = execute_trade_with_risk_management(
        symbol, 'buy', price, starting_capital, total_daily_profit, total_daily_loss, trades_log
    )

print(f"Total daily profit: {total_daily_profit}")
print(f"Capital remaining: {starting_capital}")

# Function to dynamically adjust trade size based on previous day profits
def calculate_trade_size(base_trade_size, previous_day_profit, max_trade_size=50):
    # Increase trade size based on previous day's profit, but limit it to max_trade_size
    new_trade_size = base_trade_size + previous_day_profit * 0.1
    return min(new_trade_size, max_trade_size)

# Function to execute trades with dynamic trade size
def execute_trade_with_dynamic_size(symbol, action, price, current_capital, total_daily_profit, total_daily_loss, trades_log, base_trade_size, previous_day_profit, max_loss_limit=50):
    # Adjust the trade size based on previous day profits
    trade_size = calculate_trade_size(base_trade_size, previous_day_profit)

    if check_daily_loss_limit(total_daily_loss, max_loss_limit):
        return current_capital, total_daily_profit, total_daily_loss

    # Simulate profit/loss based on trade size
    profit_loss = np.random.uniform(-trade_size, trade_size)  # Adjust profit/loss based on trade size
    total_daily_profit += profit_loss
    total_daily_loss += profit_loss if profit_loss < 0 else 0

    # Log the trade
    log_trade_with_metrics(symbol, action, price, profit_loss, trades_log)

    # Update capital
    current_capital += profit_loss
    return current_capital, total_daily_profit, total_daily_loss

# Example usage
starting_capital = 200
total_daily_profit = 0
total_daily_loss = 0
previous_day_profit = 10  # Example previous day profit
base_trade_size = 5  # Starting with $5 per trade
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Sample stock symbols
trades_log = []

for symbol in symbols:
    price = np.random.uniform(100, 200)  # Simulated stock price
    starting_capital, total_daily_profit, total_daily_loss = execute_trade_with_dynamic_size(
        symbol, 'buy', price, starting_capital, total_daily_profit, total_daily_loss, trades_log, base_trade_size, previous_day_profit
    )

print(f"Total daily profit: {total_daily_profit}")
print(f"Capital remaining: {starting_capital}")

# Function to check if total daily loss has exceeded the $50 limit
def check_loss_limit(total_daily_loss, max_loss_limit=50):
    if total_daily_loss <= -max_loss_limit:
        print(f"Daily loss limit of ${max_loss_limit} reached. Stopping trading for the day.")
        return True
    return False

# Execute trade with dynamic size and stop loss limit enforcement
def execute_trade_with_stop_limit(symbol, action, price, current_capital, total_daily_profit, total_daily_loss, trades_log, base_trade_size, previous_day_profit, max_loss_limit=50):
    # Adjust trade size based on previous day profits
    trade_size = calculate_trade_size(base_trade_size, previous_day_profit)

    if check_loss_limit(total_daily_loss, max_loss_limit):
        return current_capital, total_daily_profit, total_daily_loss

    # Simulate profit/loss based on trade size
    profit_loss = np.random.uniform(-trade_size, trade_size)  # Simulate a random profit/loss based on trade size
    total_daily_profit += profit_loss
    total_daily_loss += profit_loss if profit_loss < 0 else 0

    # Log the trade
    log_trade_with_metrics(symbol, action, price, profit_loss, trades_log)

    # Update capital
    current_capital += profit_loss
    return current_capital, total_daily_profit, total_daily_loss

# Example usage
starting_capital = 200
total_daily_profit = 0
total_daily_loss = 0
previous_day_profit = 10  # Example previous day profit
base_trade_size = 5  # Starting trade size is $5
symbols = ['AAPL', 'GOOGL', 'MSFT']
trades_log = []

for symbol in symbols:
    price = np.random.uniform(100, 200)  # Simulate stock price
    starting_capital, total_daily_profit, total_daily_loss = execute_trade_with_stop_limit(
        symbol, 'buy', price, starting_capital, total_daily_profit, total_daily_loss, trades_log, base_trade_size, previous_day_profit
    )
    # If the loss limit is hit, break the loop
    if check_loss_limit(total_daily_loss, max_loss_limit=50):
        break

print(f"Total daily profit: {total_daily_profit}")
print(f"Capital remaining: {starting_capital}")

import random

# Initialize variables
capital = 200  # Starting capital
max_daily_loss = 50  # Maximum allowable daily loss
max_trade_size = 5  # Max $5 per trade (fractional shares allowed)
profit_rollover = capital

# Function to simulate trade results (you can replace this with live data later)
def simulate_trade(symbol, current_price, trade_size):
    # Simulate random price fluctuation for testing
    new_price = current_price * random.uniform(0.9, 1.1)
    profit_loss = (new_price - current_price) * (trade_size / current_price)
    return new_price, profit_loss

# Function to simulate daily trading for multiple symbols
def simulate_trades_for_day(symbols, previous_day_profit):
    global profit_rollover
    total_daily_profit = 0
    total_capital = previous_day_profit + capital

    for symbol in symbols:
        # Get simulated prices for testing
        current_price = random.uniform(100, 200)  # Mocked current price
        trade_size = min(max_trade_size, total_capital / len(symbols))  # Divide capital among trades

        print(f"Simulated price for {symbol}: {current_price}")
        new_price, profit_loss = simulate_trade(symbol, current_price, trade_size)
        total_daily_profit += profit_loss

        # Adjust for total profit/loss
        total_capital += profit_loss

        # Execute trade
        print(f"Trade executed: {symbol}, Action: buy, Price: {current_price}, Profit/Loss: {profit_loss}")

    # Stop trading if daily loss exceeds limit
    if total_daily_profit < -max_daily_loss:
        print(f"Daily loss limit reached. Stopping further trades.")
        return total_daily_profit

    # Adjust capital based on daily profit/loss
    profit_rollover += total_daily_profit
    print(f"Total daily profit: {total_daily_profit}")
    print(f"Capital remaining: {profit_rollover}")

    return total_daily_profit

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Sample stock symbols
total_profit_today = simulate_trades_for_day(symbols, profit_rollover)

# Adjust capital for the next day based on today's profit
capital = profit_rollover

import numpy as np

# Function to simulate multiple days of trading
def simulate_multi_day_trading(symbols, starting_capital, days):
    capital = starting_capital
    for day in range(days):
        print(f"--- Starting simulation for day {day + 1} ---")
        total_daily_profit = 0

        for symbol in symbols:
            # Simulate random buy/sell prices
            buy_price = np.random.uniform(100, 200)
            sell_price = np.random.uniform(100, 200)

            profit_loss = sell_price - buy_price  # Calculate profit or loss

            # Ensure that daily profit/loss respects $50 max loss limit
            if total_daily_profit + profit_loss < -50:
                print(f"Max loss reached. Stopping trades for {symbol} on day {day + 1}")
                break

            total_daily_profit += profit_loss
            print(f"Trade executed: {symbol}, Buy Price: {buy_price}, Sell Price: {sell_price}, Profit/Loss: {profit_loss}")

        # Adjust capital based on daily profit/loss
        capital += total_daily_profit
        print(f"Total daily profit: {total_daily_profit}, Capital for the next day: {capital}\n")

    return capital

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']
starting_capital = 200
days = 5

# Running the multi-day trading simulation
final_capital = simulate_multi_day_trading(symbols, starting_capital, days)

print(f"Final capital after {days} days: {final_capital}")

import pandas as pd
import numpy as np

# Function to calculate Bollinger Bands
def calculate_bollinger_bands(data, window=20, num_std_dev=2):
    rolling_mean = data['Close'].rolling(window=window).mean()
    rolling_std = data['Close'].rolling(window=window).std()
    data['Bollinger_Upper'] = rolling_mean + (rolling_std * num_std_dev)
    data['Bollinger_Lower'] = rolling_mean - (rolling_std * num_std_dev)
    return data

# Function to calculate MACD and Signal line
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    short_ema = data['Close'].ewm(span=short_window, adjust=False).mean()
    long_ema = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = short_ema - long_ema
    data['Signal_Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()
    return data

# Enhanced buy/sell logic
def enhanced_trading_logic(data):
    actions = []

    for i in range(len(data)):
        close_price = data['Close'].iloc[i]
        rsi = data['RSI'].iloc[i]
        bollinger_upper = data['Bollinger_Upper'].iloc[i]
        bollinger_lower = data['Bollinger_Lower'].iloc[i]
        macd = data['MACD'].iloc[i]
        signal_line = data['Signal_Line'].iloc[i]

        # Buying criteria: RSI < 30, price below Bollinger lower, and MACD crossing above signal line
        if rsi < 30 and close_price < bollinger_lower and macd > signal_line:
            actions.append('buy')

        # Selling criteria: RSI > 70, price above Bollinger upper, and MACD crossing below signal line
        elif rsi > 70 and close_price > bollinger_upper and macd < signal_line:
            actions.append('sell')

        else:
            actions.append('hold')

    data['Action'] = actions
    return data

# Simulating trades using enhanced criteria
def simulate_enhanced_trades(data, initial_capital=200):
    capital = initial_capital
    total_profit = 0

    for i in range(len(data)):
        action = data['Action'].iloc[i]
        price = data['Close'].iloc[i]

        if action == 'buy' and capital >= 5:  # Min trade size of $5
            trade_size = min(5, capital)  # You can scale this dynamically based on profits
            capital -= trade_size
            print(f"Buying at {price} with ${trade_size}")

        elif action == 'sell':
            trade_size = min(5, capital)  # You can scale this dynamically
            capital += trade_size
            profit = (price - trade_size)  # Example profit calculation, adjust as needed
            total_profit += profit
            print(f"Selling at {price}, Profit: {profit}")

    return total_profit, capital

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']
for symbol in symbols:
    print(f"Fetching data for {symbol}...")
    historical_data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')  # Assuming this function exists
    historical_data = calculate_bollinger_bands(historical_data)
    historical_data = calculate_macd(historical_data)

    print(f"Running enhanced trading logic for {symbol}...")
    enhanced_data = enhanced_trading_logic(historical_data)

    total_profit, remaining_capital = simulate_enhanced_trades(enhanced_data)
    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = np.where(delta > 0, delta, 0)
    loss = np.where(delta < 0, -delta, 0)

    avg_gain = pd.Series(gain).rolling(window=window).mean()
    avg_loss = pd.Series(loss).rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    data['RSI'] = rsi
    return data

# Enhanced buy/sell logic
def enhanced_trading_logic(data):
    actions = []

    for i in range(len(data)):
        close_price = data['Close'].iloc[i]
        rsi = data['RSI'].iloc[i]
        bollinger_upper = data['Bollinger_Upper'].iloc[i]
        bollinger_lower = data['Bollinger_Lower'].iloc[i]
        macd = data['MACD'].iloc[i]
        signal_line = data['Signal_Line'].iloc[i]

        # Buying criteria: RSI < 30, price below Bollinger lower, and MACD crossing above signal line
        if rsi < 30 and close_price < bollinger_lower and macd > signal_line:
            actions.append('buy')

        # Selling criteria: RSI > 70, price above Bollinger upper, and MACD crossing below signal line
        elif rsi > 70 and close_price > bollinger_upper and macd < signal_line:
            actions.append('sell')

        else:
            actions.append('hold')

    data['Action'] = actions
    return data

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']
for symbol in symbols:
    print(f"Fetching data for {symbol}...")
    historical_data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')  # Assuming this function exists

    # Calculate indicators
    historical_data = calculate_rsi(historical_data)
    historical_data = calculate_bollinger_bands(historical_data)
    historical_data = calculate_macd(historical_data)

    print(f"Running enhanced trading logic for {symbol}...")
    enhanced_data = enhanced_trading_logic(historical_data)

    total_profit, remaining_capital = simulate_enhanced_trades(enhanced_data)
    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

# Enhanced buy/sell logic with logging
def enhanced_trading_logic(data):
    actions = []

    for i in range(len(data)):
        close_price = data['Close'].iloc[i]
        rsi = data['RSI'].iloc[i]
        bollinger_upper = data['Bollinger_Upper'].iloc[i]
        bollinger_lower = data['Bollinger_Lower'].iloc[i]
        macd = data['MACD'].iloc[i]
        signal_line = data['Signal_Line'].iloc[i]

        print(f"Date: {data.index[i]}, Close: {close_price}, RSI: {rsi}, Bollinger Upper: {bollinger_upper}, Bollinger Lower: {bollinger_lower}, MACD: {macd}, Signal Line: {signal_line}")

        # Buying criteria: RSI < 30, price below Bollinger lower, and MACD crossing above signal line
        if rsi < 30 and close_price < bollinger_lower and macd > signal_line:
            actions.append('buy')

        # Selling criteria: RSI > 70, price above Bollinger upper, and MACD crossing below signal line
        elif rsi > 70 and close_price > bollinger_upper and macd < signal_line:
            actions.append('sell')

        else:
            actions.append('hold')

    data['Action'] = actions
    return data

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']
for symbol in symbols:
    print(f"Fetching data for {symbol}...")
    historical_data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')  # Assuming this function exists

    # Calculate indicators
    historical_data = calculate_rsi(historical_data)
    historical_data = calculate_bollinger_bands(historical_data)
    historical_data = calculate_macd(historical_data)

    print(f"Running enhanced trading logic for {symbol}...")
    enhanced_data = enhanced_trading_logic(historical_data)

    total_profit, remaining_capital = simulate_enhanced_trades(enhanced_data)
    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

import pandas as pd

def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    # Add the RSI values to the dataframe
    data['RSI'] = rsi
    return data

# Enhanced trading logic with fixed RSI
def enhanced_trading_logic(data):
    actions = []

    for i in range(len(data)):
        close_price = data['Close'].iloc[i]
        rsi = data['RSI'].iloc[i]
        bollinger_upper = data['Bollinger_Upper'].iloc[i]
        bollinger_lower = data['Bollinger_Lower'].iloc[i]
        macd = data['MACD'].iloc[i]
        signal_line = data['Signal_Line'].iloc[i]

        # Log the values for better debugging
        print(f"Date: {data.index[i]}, Close: {close_price}, RSI: {rsi}, Bollinger Upper: {bollinger_upper}, Bollinger Lower: {bollinger_lower}, MACD: {macd}, Signal Line: {signal_line}")

        # Buying criteria: RSI < 30, price below Bollinger lower, and MACD crossing above signal line
        if rsi < 30 and close_price < bollinger_lower and macd > signal_line:
            actions.append('buy')

        # Selling criteria: RSI > 70, price above Bollinger upper, and MACD crossing below signal line
        elif rsi > 70 and close_price > bollinger_upper and macd < signal_line:
            actions.append('sell')

        else:
            actions.append('hold')

    data['Action'] = actions
    return data

symbols = ['AAPL', 'GOOGL', 'MSFT']  # Example tickers

for symbol in symbols:
    print(f"Fetching data for {symbol}...")
    historical_data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')

    # Calculate the indicators including the fixed RSI
    historical_data = calculate_rsi(historical_data)
    historical_data = calculate_bollinger_bands(historical_data)
    historical_data = calculate_macd(historical_data)

    print(f"Running enhanced trading logic for {symbol}...")
    enhanced_data = enhanced_trading_logic(historical_data)

    total_profit, remaining_capital = simulate_enhanced_trades(enhanced_data)
    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

def enhanced_trading_logic(data):
    actions = []

    for i in range(len(data)):
        close_price = data['Close'].iloc[i]
        rsi = data['RSI'].iloc[i]
        bollinger_upper = data['Bollinger_Upper'].iloc[i]
        bollinger_lower = data['Bollinger_Lower'].iloc[i]
        macd = data['MACD'].iloc[i]
        signal_line = data['Signal_Line'].iloc[i]

        # Adjusted Buy criteria
        if rsi < 35 and close_price < bollinger_lower and macd > signal_line:
            actions.append('buy')
        # Adjusted Sell criteria
        elif rsi > 65 and close_price > bollinger_upper and macd < signal_line:
            actions.append('sell')
        else:
            actions.append('hold')

    data['Action'] = actions
    return data

symbols = ['AAPL', 'GOOGL', 'MSFT']  # Sample tickers

for symbol in symbols:
    print(f"Fetching data for {symbol}...")
    historical_data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')

    # Calculate the indicators
    historical_data = calculate_rsi(historical_data)
    historical_data = calculate_bollinger_bands(historical_data)
    historical_data = calculate_macd(historical_data)

    print(f"Running enhanced trading logic for {symbol}...")
    enhanced_data = enhanced_trading_logic(historical_data)

    total_profit, remaining_capital = simulate_enhanced_trades(enhanced_data)
    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

def enhanced_trading_logic(data):
    actions = []
    for i in range(len(data)):
        close_price = data['Close'].iloc[i]
        rsi = data['RSI'].iloc[i]
        bollinger_upper = data['Bollinger_Upper'].iloc[i]
        bollinger_lower = data['Bollinger_Lower'].iloc[i]
        macd = data['MACD'].iloc[i]
        signal_line = data['Signal_Line'].iloc[i]

        # Adjusted Buy criteria
        if rsi < 40 and close_price < bollinger_lower and macd > signal_line:
            actions.append('buy')
            print(f"Buy signal for {data.index[i]} at {close_price} with RSI: {rsi}, MACD: {macd}, Signal Line: {signal_line}")
        # Adjusted Sell criteria
        elif rsi > 60 and close_price > bollinger_upper and macd < signal_line:
            actions.append('sell')
            print(f"Sell signal for {data.index[i]} at {close_price} with RSI: {rsi}, MACD: {macd}, Signal Line: {signal_line}")
        else:
            actions.append('hold')

    data['Action'] = actions
    return data

def enhanced_trading_logic(data):
    actions = []
    for i in range(len(data)):
        close_price = data['Close'].iloc[i]
        rsi = data['RSI'].iloc[i]
        bollinger_upper = data['Bollinger_Upper'].iloc[i]
        bollinger_lower = data['Bollinger_Lower'].iloc[i]
        macd = data['MACD'].iloc[i]
        signal_line = data['Signal_Line'].iloc[i]

        # Buy criteria
        if rsi < 40 and close_price < bollinger_lower and macd > signal_line:
            actions.append('buy')
            print(f"Buy signal for {data.index[i]} at {close_price} with RSI: {rsi}, MACD: {macd}, Signal Line: {signal_line}")
        # Sell criteria
        elif rsi > 60 and close_price > bollinger_upper and macd < signal_line:
            actions.append('sell')
            print(f"Sell signal for {data.index[i]} at {close_price} with RSI: {rsi}, MACD: {macd}, Signal Line: {signal_line}")
        else:
            actions.append('hold')

    data['Action'] = actions
    return data

# Function to simulate the trades
def simulate_trades_with_logging(symbol, data):
    capital = 200  # Initial capital
    profit = 0
    for i in range(len(data)):
        action = data['Action'].iloc[i]
        price = data['Close'].iloc[i]
        if action == 'buy':
            print(f"Buying {symbol} at {price}")
            profit -= price
        elif action == 'sell':
            print(f"Selling {symbol} at {price}")
            profit += price

    total_profit = capital + profit
    print(f"Total profit for {symbol}: {total_profit}")
    return total_profit

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add more tickers as needed
for symbol in symbols:
    data = fetch_historical_data(symbol)  # Fetch the historical data for each symbol
    data = calculate_indicators(data)  # Calculate indicators (RSI, MACD, Bollinger Bands)
    data = enhanced_trading_logic(data)  # Apply trading logic
    simulate_trades_with_logging(symbol, data)  # Simulate and log trades

# Define the date range for historical data
start_date = '2023-01-01'
end_date = '2023-12-31'

symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add more tickers as needed
for symbol in symbols:
    # Fetch the historical data for each symbol with the correct date range
    data = fetch_historical_data(symbol, start_date, end_date)

    # Calculate indicators (RSI, MACD, Bollinger Bands)
    data = calculate_indicators(data)

    # Apply enhanced trading logic
    data = enhanced_trading_logic(data)

    # Simulate and log trades
    simulate_trades_with_logging(symbol, data)

def calculate_indicators(data):
    # Calculate RSI
    data['RSI'] = calculate_rsi(data['Close'], window=14)

    # Calculate Moving Averages for Bollinger Bands
    data['SMA'] = data['Close'].rolling(window=20).mean()
    data['STD'] = data['Close'].rolling(window=20).std()

    # Calculate Bollinger Bands
    data['Bollinger_Upper'] = data['SMA'] + (data['STD'] * 2)
    data['Bollinger_Lower'] = data['SMA'] - (data['STD'] * 2)

    # Calculate MACD
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])

    return data

def enhanced_trading_logic(data):
    total_profit = 0
    capital = 200
    for i in range(len(data)):
        current_price = data['Close'].iloc[i]
        rsi = data['RSI'].iloc[i]
        macd = data['MACD'].iloc[i]
        signal_line = data['Signal_Line'].iloc[i]
        bollinger_upper = data['Bollinger_Upper'].iloc[i]
        bollinger_lower = data['Bollinger_Lower'].iloc[i]

        # Example logic: Buy when RSI is below 30 and the price is near the Bollinger Lower Band
        if rsi < 30 and current_price <= bollinger_lower and capital >= 5:
            buy_price = current_price
            print(f"Buying at {buy_price}")
            capital -= 5  # Simulating a $5 trade
        # Sell when RSI is above 70 and the price is near the Bollinger Upper Band
        elif rsi > 70 and current_price >= bollinger_upper:
            sell_price = current_price
            profit = sell_price - buy_price
            print(f"Selling at {sell_price}, Profit/Loss: {profit}")
            total_profit += profit
            capital += profit  # Adding the profit to the capital

    return total_profit, capital

# Run the enhanced trading logic for the selected tickers
symbols = ['AAPL', 'GOOGL', 'MSFT']
total_profits = {}

for symbol in symbols:
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')  # Fetch the data
    data = calculate_indicators(data)  # Calculate the necessary indicators
    print(f"Running enhanced trading logic for {symbol}...")
    total_profit, remaining_capital = enhanced_trading_logic(data)  # Apply the trading logic
    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")
    total_profits[symbol] = total_profit

# Output the summary of profits
print("Final summary of profits:")
for symbol, profit in total_profits.items():
    print(f"{symbol}: {profit}")

# Fetch the historical data and print the structure
print(f"Fetching data for {symbol}...")
data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')
print(data.head())  # Print the first few rows to inspect the data

# Updated function to fetch and inspect data for debugging
def fetch_and_inspect_data(symbol):
    print(f"Fetching data for {symbol}...")
    try:
        data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')
        print(data.head())  # Print the first few rows to inspect the data
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return None

# Example symbols to test with
symbols = ['AAPL', 'GOOGL', 'MSFT']

# Fetch and inspect data for each symbol
for symbol in symbols:
    data = fetch_and_inspect_data(symbol)
    if data is not None:
        # Proceed to next steps like calculating indicators
        print(f"Data for {symbol} looks good, proceeding with calculations...")
    else:
        print(f"Skipping {symbol} due to data issues.")

def calculate_indicators(data):
    # Calculate RSI (14-day)
    data['RSI'] = calculate_rsi(data['Close'], window=14)

    # Calculate MACD
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])

    # Calculate Bollinger Bands
    data['Bollinger_Upper'], data['Bollinger_Lower'] = calculate_bollinger_bands(data['Close'])

    return data

def enhanced_trading_logic(data):
    total_profit = 0

    for index, row in data.iterrows():
        close_price = row['Close']
        rsi = row['RSI']
        macd = row['MACD']
        signal_line = row['Signal_Line']
        bollinger_upper = row['Bollinger_Upper']
        bollinger_lower = row['Bollinger_Lower']

        # Example trading logic based on RSI, MACD, and Bollinger Bands
        if rsi < 30 and close_price < bollinger_lower:
            print(f"Buying at {close_price}")
            buy_price = close_price
        elif rsi > 70 and close_price > bollinger_upper and macd > signal_line:
            print(f"Selling at {close_price}")
            sell_price = close_price
            profit = sell_price - buy_price
            total_profit += profit
            print(f"Profit from trade: {profit}")

    return total_profit

# Apply to each symbol
for symbol in symbols:
    data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')
    data = calculate_indicators(data)
    profit = enhanced_trading_logic(data)
    print(f"Total profit for {symbol}: {profit}")

def fetch_and_inspect_data(symbol, start_date, end_date):
    data = fetch_historical_data(symbol, start_date, end_date)

    # Check if 'Close' column exists
    if 'Close' not in data.columns:
        raise KeyError(f"'Close' column not found in data for {symbol}")

    # Check the first few rows to ensure data integrity
    print(f"Fetched data for {symbol}:")
    print(data.head())

    # Check data types
    print(f"Data types for {symbol}:")
    print(data.dtypes)

    return data

# Test fetching data and inspecting it for any errors
for symbol in ['AAPL', 'GOOGL', 'MSFT']:
    try:
        data = fetch_and_inspect_data(symbol, '2023-01-01', '2023-12-31')
    except Exception as e:
        print(f"Error fetching or inspecting data for {symbol}: {e}")

def calculate_indicators(data):
    # Calculate RSI
    data['RSI'] = calculate_rsi(data['Close'], window=14)  # 14-day RSI
    # Calculate Bollinger Bands
    data['SMA_20'] = data['Close'].rolling(window=20).mean()
    data['Bollinger_Upper'] = data['SMA_20'] + 2 * data['Close'].rolling(window=20).std()
    data['Bollinger_Lower'] = data['SMA_20'] - 2 * data['Close'].rolling(window=20).std()
    # Calculate MACD
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])
    return data

def enhanced_trading_logic(data):
    total_profit = 0
    for index, row in data.iterrows():
        close_price = row['Close']
        rsi = row['RSI']
        bollinger_upper = row['Bollinger_Upper']
        bollinger_lower = row['Bollinger_Lower']
        macd = row['MACD']
        signal_line = row['Signal_Line']

        # Example trading logic: buy when RSI < 30, sell when RSI > 70
        if rsi < 30 and close_price < bollinger_lower:
            print(f"Buying at {close_price} (RSI: {rsi}, Bollinger Lower: {bollinger_lower})")
        elif rsi > 70 and close_price > bollinger_upper:
            print(f"Selling at {close_price} (RSI: {rsi}, Bollinger Upper: {bollinger_upper})")

    return total_profit

# Now run this for each symbol
for symbol in ['AAPL', 'GOOGL', 'MSFT']:
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')
    data = calculate_indicators(data)
    total_profit = enhanced_trading_logic(data)
    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: 200")

def fetch_historical_data(symbol, start_date, end_date):
    # Replace this with actual data fetching logic
    # For example, using yfinance or any other API to get historical data
    data = yf.download(symbol, start=start_date, end=end_date)

    # Check if the data was fetched correctly
    if data.empty:
        print(f"Failed to fetch data for {symbol}. Data is empty.")
        return None

    print(f"Fetched data for {symbol}:\n{data.head()}\n")  # Display the first few rows of the DataFrame
    return data

# Now run this for each symbol
for symbol in ['AAPL', 'GOOGL', 'MSFT']:
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')

    if data is not None:  # Ensure data is fetched successfully
        data = calculate_indicators(data)
        total_profit = enhanced_trading_logic(data)
        print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: 200")
    else:
        print(f"Skipping {symbol} due to data fetching issues.")

def enhanced_trading_logic(data):
    # Check if expected columns exist
    required_columns = ['Close', 'RSI', 'Bollinger_Upper', 'Bollinger_Lower', 'MACD', 'Signal_Line']
    for col in required_columns:
        if col not in data.columns:
            print(f"Missing column: {col}")
            return 0  # Skip further calculations if any required column is missing

    total_profit = 0
    for index, row in data.iterrows():
        close_price = row['Close']  # Use .loc or .iloc if needed
        rsi = row['RSI']
        bollinger_upper = row['Bollinger_Upper']
        bollinger_lower = row['Bollinger_Lower']
        macd = row['MACD']
        signal_line = row['Signal_Line']

        # Implement your trading logic here
        if rsi < 30 and close_price < bollinger_lower:
            # Example: Buy logic
            print(f"Buying at {close_price}")
            total_profit += close_price  # Simulate a buy trade
        elif rsi > 70 and close_price > bollinger_upper:
            # Example: Sell logic
            print(f"Selling at {close_price}")
            total_profit -= close_price  # Simulate a sell trade

    return total_profit

# Test the updated logic
symbols = ['AAPL', 'GOOGL', 'MSFT']
for symbol in symbols:
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, '2023-01-01', '2023-12-31')

    if data is not None:
        data = calculate_indicators(data)  # Make sure this function populates RSI and other indicators
        total_profit = enhanced_trading_logic(data)  # Apply trading logic
        print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: 200")
    else:
        print(f"Skipping {symbol} due to data fetching issues.")

def fetch_and_process_data(symbol, start_date, end_date):
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

    if data is not None:
        print(f"Fetched data for {symbol}:")
        print(data.head())  # Display the first few rows of the data
        print("Data types:")
        print(data.dtypes)  # Display data types of columns

        # Check if required columns are present
        required_columns = ['Close', 'RSI', 'Bollinger_Upper', 'Bollinger_Lower', 'MACD', 'Signal_Line']
        for col in required_columns:
            if col not in data.columns:
                print(f"Missing column: {col}")
                return 0  # Exit if required column is missing

        # Proceed with calculating indicators if all required columns are present
        total_profit = enhanced_trading_logic(data)  # Apply trading logic
        print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: 200")
    else:
        print(f"Skipping {symbol} due to data fetching issues.")

# Example usage for multiple tickers
symbols = ['AAPL', 'GOOGL', 'MSFT']
start_date = '2023-01-01'
end_date = '2023-12-31'

for symbol in symbols:
    fetch_and_process_data(symbol, start_date, end_date)

def fetch_and_process_data(symbol, start_date, end_date):
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

    if data is not None:
        print(f"Fetched data for {symbol}:")
        print(data.head())  # Display the first few rows of the data

        # Check if required columns are present
        required_columns = ['Close']
        for col in required_columns:
            if col not in data.columns:
                print(f"Missing column: {col}")
                return 0  # Exit if required column is missing

        # Calculate indicators (RSI, MACD, Bollinger Bands)
        data['RSI'] = calculate_rsi(data['Close'], window=14)  # Assuming 14-day RSI
        data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])
        data['Bollinger_Upper'], data['Bollinger_Lower'] = calculate_bollinger_bands(data['Close'])

        # Check if all indicators are calculated
        for col in ['RSI', 'MACD', 'Signal_Line', 'Bollinger_Upper', 'Bollinger_Lower']:
            if col not in data.columns:
                print(f"Missing indicator column: {col}")
                return 0  # Exit if indicator column is missing

        # Apply enhanced trading logic
        total_profit = enhanced_trading_logic(data)  # Apply trading logic
        print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: 200")
    else:
        print(f"Skipping {symbol} due to data fetching issues.")

# Example usage for multiple tickers
symbols = ['AAPL', 'GOOGL', 'MSFT']
start_date = '2023-01-01'
end_date = '2023-12-31'

for symbol in symbols:
    fetch_and_process_data(symbol, start_date, end_date)

def fetch_and_process_data(symbol, start_date, end_date):
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, start_date, end_date)  # Fetch historical data

    if data is not None:
        print(f"Fetched data for {symbol}:")
        print(data.head())  # Display the first few rows of the data

        # Ensure the DataFrame has a datetime index
        data.index = pd.to_datetime(data.index)

        # Check if required columns are present
        required_columns = ['Close']
        for col in required_columns:
            if col not in data.columns:
                print(f"Missing column: {col}")
                return 0  # Exit if required column is missing

        # Calculate indicators (RSI, MACD, Bollinger Bands)
        data['RSI'] = calculate_rsi(data['Close'], window=14)  # Assuming 14-day RSI
        data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])
        data['Bollinger_Upper'], data['Bollinger_Lower'] = calculate_bollinger_bands(data['Close'])

        # Check if all indicators are calculated
        for col in ['RSI', 'MACD', 'Signal_Line', 'Bollinger_Upper', 'Bollinger_Lower']:
            if col not in data.columns:
                print(f"Missing indicator column: {col}")
                return 0  # Exit if indicator column is missing

        # Apply enhanced trading logic
        total_profit = enhanced_trading_logic(data)  # Apply trading logic
        print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: 200")
    else:
        print(f"Skipping {symbol} due to data fetching issues.")

# Example usage for multiple tickers
symbols = ['AAPL', 'GOOGL', 'MSFT']
start_date = '2023-01-01'
end_date = '2023-12-31'

for symbol in symbols:
    fetch_and_process_data(symbol, start_date, end_date)

import pandas as pd
import yfinance as yf

def fetch_historical_data(symbol, start_date, end_date):
    # Fetch historical data using yfinance
    data = yf.download(symbol, start=start_date, end=end_date, interval='1d')
    return data

def calculate_indicators(data):
    if 'Close' not in data.columns:
        print("Missing 'Close' column in the data.")
        return data

    # Calculate RSI, MACD, and Bollinger Bands
    data['RSI'] = calculate_rsi(data['Close'])
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])
    data['Bollinger_Upper'], data['Bollinger_Lower'] = calculate_bollinger_bands(data['Close'])

    return data

def fetch_and_process_data(symbol, start_date, end_date):
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, start_date, end_date)

    if data.empty:
        print(f"No data fetched for {symbol}.")
        return

    print(f"Fetched data for {symbol}:")
    print(data.head())  # Print first few rows for verification

    # Ensure the data has necessary columns
    required_columns = ['Close']
    for col in required_columns:
        if col not in data.columns:
            print(f"Missing column: {col}")
            return

    # Calculate indicators
    data = calculate_indicators(data)

    # Debug output for indicators
    print(f"Data with indicators for {symbol}:")
    print(data[['Close', 'RSI', 'MACD']].tail())  # Print last few rows to verify calculations

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']
start_date = '2023-01-01'
end_date = '2023-12-31'

for symbol in symbols:
    fetch_and_process_data(symbol, start_date, end_date)

import pandas as pd
import yfinance as yf

def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1d')
    return data

def calculate_indicators(data):
    # Ensure 'Close' column exists before calculations
    if 'Close' not in data.columns:
        print("Missing 'Close' column in the data.")
        return data

    # Calculate RSI, MACD, and Bollinger Bands
    # Assuming calculate_rsi and calculate_macd functions are defined elsewhere
    data['RSI'] = calculate_rsi(data['Close'])  # Add your RSI calculation function here
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])  # Add your MACD calculation function here

    return data

def fetch_and_process_data(symbol, start_date, end_date):
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, start_date, end_date)

    if data.empty:
        print(f"No data fetched for {symbol}.")
        return

    print(f"Fetched data for {symbol}:")
    print(data.head())  # Print first few rows for verification

    # Ensure the data has necessary columns
    if 'Close' not in data.columns:
        print(f"Missing 'Close' column for {symbol}.")
        return

    # Calculate indicators
    data = calculate_indicators(data)

    # Print diagnostic output for indicators
    print(f"Data with indicators for {symbol}:")
    print(data[['Close', 'RSI', 'MACD']].tail())  # Print last few rows to verify calculations

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']
start_date = '2023-01-01'
end_date = '2023-12-31'

for symbol in symbols:
    fetch_and_process_data(symbol, start_date, end_date)

import pandas as pd
import yfinance as yf

def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1d')
    return data

def calculate_indicators(data):
    # Ensure the DataFrame has the correct structure and column names
    print("DataFrame Info:")
    print(data.info())  # Print DataFrame info to check columns and data types

    # Check for the 'Close' column specifically
    if 'Close' not in data.columns:
        print("Missing 'Close' column in the data.")
        return data

    # Calculate RSI, MACD, and Bollinger Bands
    data['RSI'] = calculate_rsi(data['Close'])  # Your RSI calculation function
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])  # Your MACD calculation function

    # Print the last few rows to confirm calculations
    print("Data with indicators:")
    print(data[['Close', 'RSI', 'MACD']].tail())  # Check for calculated indicators

    return data

def fetch_and_process_data(symbol, start_date, end_date):
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, start_date, end_date)

    if data.empty:
        print(f"No data fetched for {symbol}.")
        return

    print(f"Fetched data for {symbol}:")
    print(data.head())  # Display the first few rows of the DataFrame

    # Calculate indicators
    data = calculate_indicators(data)

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']
start_date = '2023-01-01'
end_date = '2023-12-31'

for symbol in symbols:
    fetch_and_process_data(symbol, start_date, end_date)

def calculate_indicators(data):
    # Ensure the DataFrame has the correct structure and column names
    print("DataFrame Info Before Calculating Indicators:")
    print(data.info())  # Print DataFrame info to check columns and data types

    # Check for the 'Close' column specifically
    if 'Close' not in data.columns:
        print("Missing 'Close' column in the data.")
        return data

    # Print the DataFrame before calculations
    print("DataFrame Before Calculating Indicators:")
    print(data.head())  # Check the structure before calculating

    # Calculate indicators
    data['RSI'] = calculate_rsi(data['Close'])  # Assuming calculate_rsi is defined
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])  # Assuming calculate_macd is defined

    # Print the DataFrame after calculations
    print("DataFrame After Calculating Indicators:")
    print(data[['Close', 'RSI', 'MACD']].tail())  # Check for calculated indicators

    return data

import pandas as pd
import yfinance as yf

def fetch_historical_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date, interval='1d')
    return data

def calculate_rsi(close_prices, window=14):
    delta = close_prices.diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_macd(close_prices):
    short_ema = close_prices.ewm(span=12, adjust=False).mean()
    long_ema = close_prices.ewm(span=26, adjust=False).mean()
    macd = short_ema - long_ema
    signal_line = macd.ewm(span=9, adjust=False).mean()
    return macd, signal_line

def calculate_indicators(data):
    print("DataFrame Info Before Calculating Indicators:")
    print(data.info())
    if 'Close' not in data.columns:
        print("Missing 'Close' column in the data.")
        return data

    print("DataFrame Before Calculating Indicators:")
    print(data.head())

    data['RSI'] = calculate_rsi(data['Close'])
    data['MACD'], data['Signal_Line'] = calculate_macd(data['Close'])

    print("DataFrame After Calculating Indicators:")
    print(data[['Close', 'RSI', 'MACD']].tail())

    return data

def fetch_and_process_data(symbol, start_date, end_date):
    print(f"Fetching data for {symbol}...")
    data = fetch_historical_data(symbol, start_date, end_date)

    if data.empty:
        print(f"No data fetched for {symbol}.")
        return

    print(f"Fetched data for {symbol}:")
    print(data.head())
    data = calculate_indicators(data)

# Example usage
symbols = ['AAPL', 'GOOGL', 'MSFT']
start_date = '2023-01-01'
end_date = '2023-12-31'

for symbol in symbols:
    fetch_and_process_data(symbol, start_date, end_date)

def enhanced_trading_logic(data):
    initial_capital = 200.0  # Starting capital
    capital = initial_capital
    total_profit = 0.0

    for index, row in data.iterrows():
        if pd.isna(row['RSI']) or pd.isna(row['MACD']):
            continue  # Skip rows where indicators are not available

        # Trading conditions based on RSI and MACD
        if row['RSI'] < 30 and row['MACD'] > 0:  # Buy condition
            trade_amount = min(5, capital)  # Maximum of $5 per trade
            buy_price = row['Close']
            capital -= trade_amount
            total_profit -= trade_amount  # Assume we bought and reduced capital
            print(f"Buying {trade_amount} of {row.name} at {buy_price}")

        elif row['RSI'] > 70 and row['MACD'] < 0:  # Sell condition
            sell_price = row['Close']
            capital += trade_amount  # Assume selling the amount we bought
            total_profit += trade_amount  # Add back to total profit
            print(f"Selling {trade_amount} of {row.name} at {sell_price}")

    print(f"Total profit for the period: {total_profit}, Remaining Capital: {capital}")
    return total_profit, capital

# Example usage
for symbol in symbols:
    data = fetch_historical_data(symbol, start_date, end_date)
    data = calculate_indicators(data)
    total_profit, remaining_capital = enhanced_trading_logic(data)
    print(f"Final profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

def enhanced_trading_logic(data):
    initial_capital = 200.0  # Starting capital
    capital = initial_capital
    total_profit = 0.0
    position = 0  # Track the number of shares owned

    for index, row in data.iterrows():
        if pd.isna(row['RSI']) or pd.isna(row['MACD']):
            continue  # Skip rows where indicators are not available

        # Trading conditions based on RSI and MACD
        if row['RSI'] < 30 and row['MACD'] > 0:  # Buy condition
            trade_amount = min(5, capital)  # Maximum of $5 per trade
            buy_price = row['Close']
            capital -= trade_amount
            position += trade_amount  # Increase position
            total_profit -= trade_amount  # Assume we bought and reduced capital
            print(f"Buying {trade_amount} of {row.name} at {buy_price}")

        elif row['RSI'] > 70 and row['MACD'] < 0 and position > 0:  # Sell condition
            sell_price = row['Close']
            capital += position  # Sell all shares
            total_profit += position  # Add back to total profit
            print(f"Selling {position} of {row.name} at {sell_price}")
            position = 0  # Reset position after selling

    print(f"Total profit for the period: {total_profit}, Remaining Capital: {capital}")
    return total_profit, capital

# Example usage
for symbol in symbols:
    data = fetch_historical_data(symbol, start_date, end_date)
    data = calculate_indicators(data)
    total_profit, remaining_capital = enhanced_trading_logic(data)
    print(f"Final profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

def enhanced_trading_logic(data):
    buy_signals = []
    sell_signals = []
    capital = 200.0  # Starting capital
    shares = 0  # Number of shares held

    for index, row in data.iterrows():
        # Check buy conditions
        if row['RSI'] < 30 and row['MACD'] > row['Signal Line']:
            buy_price = row['Close']
            shares_to_buy = capital // buy_price  # Calculate how many shares can be bought
            if shares_to_buy > 0:
                capital -= shares_to_buy * buy_price
                shares += shares_to_buy
                buy_signals.append((index, buy_price))

        # Check sell conditions
        if row['RSI'] > 70 or (shares > 0 and row['MACD'] < row['Signal Line']):
            if shares > 0:
                sell_price = row['Close']
                capital += shares * sell_price
                sell_signals.append((index, sell_price))
                shares = 0  # Reset shares after selling

    total_profit = capital - 200.0  # Assuming initial capital was 200.0
    return total_profit, capital

def enhanced_trading_logic(data):
    buy_signals = []
    sell_signals = []
    capital = 200.0  # Starting capital
    shares = 0  # Number of shares held

    for index, row in data.iterrows():
        # Check buy conditions
        if row['RSI'] < 30 and row['MACD'] > row['Signal Line']:
            buy_price = row['Close']
            shares_to_buy = capital // buy_price  # Calculate how many shares can be bought
            if shares_to_buy > 0:
                capital -= shares_to_buy * buy_price
                shares += shares_to_buy
                buy_signals.append((index, buy_price))
                print(f"Buying {shares_to_buy} of {index} at {buy_price}")

        # Check sell conditions
        if row['RSI'] > 70 or (shares > 0 and row['MACD'] < row['Signal Line']):
            if shares > 0:
                sell_price = row['Close']
                capital += shares * sell_price
                sell_signals.append((index, sell_price))
                print(f"Selling {shares} of {index} at {sell_price}")
                shares = 0  # Reset shares after selling

    total_profit = capital - 200.0  # Assuming initial capital was 200.0
    return total_profit, capital

symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add more tickers as needed
for symbol in symbols:
    data = fetch_historical_data(symbol)  # Fetch the historical data for each symbol
    data = calculate_indicators(data)  # Calculate indicators (RSI, MACD, Bollinger Bands)
    total_profit, remaining_capital = enhanced_trading_logic(data)  # Apply trading logic
    print(f"Final profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

from datetime import datetime, timedelta

# Define the start and end dates for historical data
end_date = datetime.now()
start_date = end_date - timedelta(days=365)  # 1 year of data

symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add more tickers as needed
for symbol in symbols:
    data = fetch_historical_data(symbol, start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d'))  # Fetch the historical data for each symbol
    data = calculate_indicators(data)  # Calculate indicators (RSI, MACD, Bollinger Bands)
    total_profit, remaining_capital = enhanced_trading_logic(data)  # Apply trading logic
    print(f"Final profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    # Calculate the MACD
    data['EMA_Short'] = data['Close'].ewm(span=short_window, adjust=False).mean()
    data['EMA_Long'] = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = data['EMA_Short'] - data['EMA_Long']
    data['Signal Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()
    return data

def calculate_indicators(data):
    data = calculate_rsi(data)  # Ensure you have an RSI calculation function
    data = calculate_macd(data)  # Calculate MACD and its signal line
    # Include other indicators if necessary
    return data

data = calculate_indicators(data)  # Calculate indicators
print(data.head())  # Print first few rows to check

print(data.head(30))  # Print the first 30 rows to verify data

# After fetching historical data
if data.shape[0] < 26:  # Check if there are enough rows for MACD calculation
    print("Not enough data to calculate indicators.")
else:
    data = calculate_indicators(data)  # Proceed with calculations if enough data is present

def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    data['RSI'] = 100 - (100 / (1 + rs))
    return data

def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    data['EMA_Short'] = data['Close'].ewm(span=short_window, adjust=False).mean()
    data['EMA_Long'] = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = data['EMA_Short'] - data['EMA_Long']
    data['Signal Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()
    return data

import pandas as pd
import numpy as np

def fetch_historical_data(symbol, start_date, end_date):
    # Your fetching logic here...
    # Make sure to fetch enough historical data for indicator calculations
    pass

def calculate_indicators(data):
    if data.shape[0] < 26:  # Not enough data for MACD
        print(f"Not enough data for {data.index[0]} to calculate indicators.")
        return data

    # Calculate RSI
    data = calculate_rsi(data)

    # Calculate MACD
    data = calculate_macd(data)

    return data

# Example for trading logic
def enhanced_trading_logic(data, capital=200):
    total_profit = 0

    for index, row in data.iterrows():
        if pd.notna(row['RSI']) and pd.notna(row['MACD']):
            # Example logic for buying/selling
            if row['RSI'] < 30:  # Buy condition
                print(f"Buying at {row['Close']}")
                # Execute buy logic...

            elif row['RSI'] > 70:  # Sell condition
                print(f"Selling at {row['Close']}")
                # Execute sell logic...

    return total_profit, capital

# Main execution
symbols = ['AAPL', 'GOOGL', 'MSFT']
for symbol in symbols:
    start_date = "2023-01-01"
    end_date = "2024-01-01"  # Adjust this as necessary
    data = fetch_historical_data(symbol, start_date, end_date)
    data = calculate_indicators(data)
    total_profit, remaining_capital = enhanced_trading_logic(data)

print(f"Total profit: {total_profit}, Remaining capital: {remaining_capital}")

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-83-a2a42ba3a714> in <cell line: 41>()
     43     end_date = "2024-01-01"  # Adjust this as necessary
     44     data = fetch_historical_data(symbol, start_date, end_date)
---> 45     data = calculate_indicators(data)
     46     total_profit, remaining_capital = enhanced_trading_logic(data)
     47

<ipython-input-83-a2a42ba3a714> in calculate_indicators(data)
      8
      9 def calculate_indicators(data):
---> 10     if data.shape[0] < 26:  # Not enough data for MACD
     11         print(f"Not enough data for {data.index[0]} to calculate indicators.")
     12         return data

AttributeError: 'NoneType' object has no attribute 'shape'

import pandas as pd
import yfinance as yf  # Make sure you have yfinance installed

def fetch_historical_data(symbol, start_date, end_date):
    try:
        data = yf.download(symbol, start=start_date, end=end_date)
        if data.empty:
            print(f"No data fetched for {symbol} between {start_date} and {end_date}.")
            return None
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return None

symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add more tickers as needed
total_profit = 0
remaining_capital = 200

for symbol in symbols:
    start_date = "2023-01-01"
    end_date = "2024-01-01"
    data = fetch_historical_data(symbol, start_date, end_date)

    if data is not None:  # Proceed only if data is valid
        data = calculate_indicators(data)
        total_profit, remaining_capital = enhanced_trading_logic(data)
    else:
        print(f"Skipping {symbol} due to data fetching issue.")

print(f"Total profit: {total_profit}, Remaining capital: {remaining_capital}")

def enhanced_trading_logic(data):
    initial_capital = 200  # Starting capital
    current_capital = initial_capital
    positions = {}  # Track the shares bought for each symbol

    for index, row in data.iterrows():
        close_price = row['Close']
        rsi = row['RSI']
        macd = row['MACD']
        signal_line = row['Signal_Line']

        # Buy condition
        if rsi < 30:  # RSI condition to buy
            shares_to_buy = 5  # Adjust as needed
            cost = close_price * shares_to_buy
            if current_capital >= cost:
                current_capital -= cost
                positions[data.index.name] = positions.get(data.index.name, 0) + shares_to_buy
                print(f"Buying {shares_to_buy} of {data.index.name} at {close_price}")

        # Sell condition
        elif rsi > 70:  # RSI condition to sell
            if data.index.name in positions and positions[data.index.name] > 0:
                shares_to_sell = positions[data.index.name]
                revenue = close_price * shares_to_sell
                current_capital += revenue
                positions[data.index.name] = 0  # Reset shares after selling
                print(f"Selling {shares_to_sell} of {data.index.name} at {close_price}")

    # Calculate total profit
    total_profit = current_capital - initial_capital
    print(f"Total profit: {total_profit}, Remaining capital: {current_capital}")
    return total_profit, current_capital

transaction_fee = 1.00  # Example fee for each transaction

# Deduct fee when buying
current_capital -= transaction_fee

# Add fee when selling
current_capital -= transaction_fee

def enhanced_trading_logic(data):
    initial_capital = 200  # Starting capital
    current_capital = initial_capital
    transaction_fee = 1.00  # Example fee for each transaction
    positions = {}  # Track the shares bought for each symbol

    for index, row in data.iterrows():
        close_price = row['Close']
        rsi = row['RSI']
        macd = row['MACD']
        signal_line = row['Signal_Line']

        # Buy condition
        if rsi < 30:  # RSI condition to buy
            shares_to_buy = 5  # Adjust as needed
            cost = close_price * shares_to_buy + transaction_fee  # Include transaction fee
            if current_capital >= cost:
                current_capital -= cost
                positions[data.index.name] = positions.get(data.index.name, 0) + shares_to_buy
                print(f"Buying {shares_to_buy} of {data.index.name} at {close_price}")

        # Sell condition
        elif rsi > 70:  # RSI condition to sell
            if data.index.name in positions and positions[data.index.name] > 0:
                shares_to_sell = positions[data.index.name]
                revenue = close_price * shares_to_sell - transaction_fee  # Deduct transaction fee
                current_capital += revenue
                positions[data.index.name] = 0  # Reset shares after selling
                print(f"Selling {shares_to_sell} of {data.index.name} at {close_price}")

    # Calculate total profit
    total_profit = current_capital - initial_capital
    print(f"Total profit: {total_profit}, Remaining capital: {current_capital}")
    return total_profit, current_capital

def enhanced_trading_logic(data, initial_capital=200, stop_loss_pct=0.05, take_profit_pct=0.1):
    capital = initial_capital
    shares = 0
    buy_price = 0
    transactions = []

    for index, row in data.iterrows():
        close_price = row['Close']

        # Check for buy signal
        if close_price < row['Bollinger_Lower']:  # Example condition for buying
            if capital >= close_price:  # Check if we have enough capital to buy one share
                shares += 1
                buy_price = close_price
                capital -= close_price
                transactions.append(f"Buying 1 share at {close_price:.2f}")

        # Check for stop-loss or take-profit conditions
        if shares > 0:
            # Calculate stop-loss and take-profit prices
            stop_loss_price = buy_price * (1 - stop_loss_pct)
            take_profit_price = buy_price * (1 + take_profit_pct)

            # Check if the stop-loss or take-profit is triggered
            if close_price <= stop_loss_price:
                transactions.append(f"Selling at {close_price:.2f} (Stop-Loss)")
                capital += close_price
                shares -= 1  # Sell one share
                buy_price = 0  # Reset buy price

            elif close_price >= take_profit_price:
                transactions.append(f"Selling at {close_price:.2f} (Take-Profit)")
                capital += close_price
                shares -= 1  # Sell one share
                buy_price = 0  # Reset buy price

    total_profit = capital + (shares * close_price) - initial_capital
    return total_profit, capital, transactions

# Define your symbols
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add more tickers as needed

# Loop through each symbol
for symbol in symbols:
    start_date = "2023-01-01"  # Adjust this as necessary
    end_date = "2024-01-01"  # Adjust this as necessary
    data = fetch_historical_data(symbol, start_date, end_date)
    data = calculate_indicators(data)

    # Run the enhanced trading logic
    total_profit, remaining_capital, transactions = enhanced_trading_logic(data)

    print(f"Final profit for {symbol}: {total_profit:.2f}, Remaining Capital: {remaining_capital:.2f}")
    print("Transactions:")
    for transaction in transactions:
        print(transaction)

def calculate_bollinger_bands(data, window=20, num_std_dev=2):
    # Calculate the moving average
    data['SMA'] = data['Close'].rolling(window=window).mean()

    # Calculate the rolling standard deviation
    data['STD'] = data['Close'].rolling(window=window).std()

    # Calculate Bollinger Bands
    data['Bollinger_Upper'] = data['SMA'] + (data['STD'] * num_std_dev)
    data['Bollinger_Lower'] = data['SMA'] - (data['STD'] * num_std_dev)

    return data

def calculate_indicators(data):
    data = calculate_bollinger_bands(data)
    # Add other indicator calculations (e.g., RSI, MACD) here
    return data

# After calculating indicators
data = calculate_indicators(data)
print(data.head())  # Inspect the DataFrame

# Inside your enhanced_trading_logic function
for index, row in data.iterrows():
    if row['Close'] > row['Bollinger_Upper']:
        # Implement your selling logic
    elif row['Close'] < row['Bollinger_Lower']:
        # Implement your buying logic

# Inside your enhanced_trading_logic function
for index, row in data.iterrows():
    if row['Close'] > row['Bollinger_Upper']:
        # Implement your selling logic here
        print(f"Selling signal for {row.name}: Close = {row['Close']}, Upper Band = {row['Bollinger_Upper']}")
    elif row['Close'] < row['Bollinger_Lower']:
        # Implement your buying logic here
        print(f"Buying signal for {row.name}: Close = {row['Close']}, Lower Band = {row['Bollinger_Lower']}")

def enhanced_trading_logic(data):
    transaction_fee = 0.01  # Transaction fee per trade (1% for example)
    initial_capital = 200.0
    remaining_capital = initial_capital
    total_profit = 0.0
    trades = []

    for index, row in data.iterrows():
        if row['Buy_Signal']:
            # Buying Logic
            quantity = remaining_capital // row['Close']  # Maximum quantity we can buy
            if quantity > 0:
                cost = quantity * row['Close'] * (1 + transaction_fee)  # Include transaction fee
                remaining_capital -= cost
                trades.append(f"Buying {quantity} of {row.name} at {row['Close']:.2f}")

        if row['Sell_Signal']:
            # Selling Logic
            if trades:
                quantity = sum(int(trade.split()[1]) for trade in trades if 'Buying' in trade)  # Total quantity bought
                revenue = quantity * row['Close'] * (1 - transaction_fee)  # Include transaction fee
                remaining_capital += revenue
                total_profit += revenue - initial_capital  # Profit calculation
                trades.append(f"Selling {quantity} of {row.name} at {row['Close']:.2f}")
                # Reset trades after selling
                trades = []

    print(f"Total profit: {total_profit:.2f}, Remaining capital: {remaining_capital:.2f}")
    for trade in trades:
        print(trade)

    return total_profit, remaining_capital

# Example usage:
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add more tickers as needed
for symbol in symbols:
    data = fetch_historical_data(symbol, start_date, end_date)  # Replace with actual dates
    data = calculate_indicators(data)
    total_profit, remaining_capital = enhanced_trading_logic(data)

def calculate_indicators(data):
    # Calculate Bollinger Bands
    data['SMA'] = data['Close'].rolling(window=20).mean()
    data['Bollinger_Upper'] = data['SMA'] + (data['Close'].rolling(window=20).std() * 2)
    data['Bollinger_Lower'] = data['SMA'] - (data['Close'].rolling(window=20).std() * 2)

    # Calculate RSI
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    data['RSI'] = 100 - (100 / (1 + rs))

    # Calculate MACD
    data['EMA_Short'] = data['Close'].ewm(span=12, adjust=False).mean()
    data['EMA_Long'] = data['Close'].ewm(span=26, adjust=False).mean()
    data['MACD'] = data['EMA_Short'] - data['EMA_Long']
    data['Signal_Line'] = data['MACD'].ewm(span=9, adjust=False).mean()

    # Create Buy and Sell signals
    data['Buy_Signal'] = (data['Close'] < data['Bollinger_Lower'])
    data['Sell_Signal'] = (data['Close'] > data['Bollinger_Upper'])

    return data

# Now, after calculating indicators, the data will have Buy and Sell signals

symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add more tickers as needed
for symbol in symbols:
    data = fetch_historical_data(symbol, start_date, end_date)
    data = calculate_indicators(data)  # Ensure this step adds the Buy/Sell signals
    total_profit, remaining_capital = enhanced_trading_logic(data)  # Now it should work without KeyError

# Selling Logic
if trades:
    # Change from int() to float() to handle fractional quantities
    quantity = sum(float(trade.split()[1]) for trade in trades if 'Buying' in trade)  # Total quantity bought
    revenue = quantity * row['Close'] * (1 - transaction_fee)  # Include transaction fee
    remaining_capital += revenue

def enhanced_trading_logic(data):
    total_profit = 0
    remaining_capital = 200  # Initial capital
    transaction_fee = 0.001  # Transaction fee (adjust as necessary)

    # Initialize a list to keep track of trades
    trades = []

    for index, row in data.iterrows():
        # Buying Logic
        if row['Buy_Signal']:
            # Assuming we buy a fixed quantity
            quantity = 5  # Change as needed
            trades.append(f"Buying {quantity} of {row['Close']}")  # Record trade
            remaining_capital -= (quantity * row['Close'] * (1 + transaction_fee))  # Deduct fee when buying

        # Selling Logic
        if trades:  # Check if there are any trades
            # Calculate the total quantity bought
            quantity = sum(float(trade.split()[1]) for trade in trades if 'Buying' in trade)  # Total quantity bought
            revenue = quantity * row['Close'] * (1 - transaction_fee)  # Include transaction fee
            remaining_capital += revenue  # Add revenue from selling
            trades.clear()  # Clear trades after selling

    total_profit = remaining_capital - 200  # Calculate total profit

    return total_profit, remaining_capital

def enhanced_trading_logic(data):
    total_profit = 0
    remaining_capital = 200  # Starting capital
    transaction_fee = 0.001  # Example transaction fee
    trades = []  # Initialize trades list

    for index, row in data.iterrows():
        # Selling Logic
        if trades:
            quantity = sum(float(trade.split()[1]) for trade in trades if 'Buying' in trade)  # Total quantity bought
            revenue = quantity * row['Close'] * (1 - transaction_fee)  # Include transaction fee
            remaining_capital += revenue
            trades = []  # Clear trades after selling

        # Buying Logic
        if row['Buy_Signal'] == 1:  # Assuming 'Buy_Signal' is 1 for buy signal
            trades.append(f"Buying {5} of {row['Close']}")  # Replace '5' with your buy quantity

        # Selling logic
        if row['Sell_Signal'] == 1:  # Assuming 'Sell_Signal' is 1 for sell signal
            trades.append(f"Selling {5} of {row['Close']}")  # Replace '5' with your sell quantity

    return total_profit, remaining_capital

def calculate_indicators(data):
    # Your existing logic for calculating indicators

    # After calculating the signals, print the DataFrame to verify
    print(data[['Close', 'RSI', 'MACD', 'Signal_Line', 'Buy_Signal', 'Sell_Signal']].tail(10))  # Display last 10 rows
    return data

# Assuming the signals are correctly calculated
symbols = ['AAPL', 'GOOGL', 'MSFT']  # List of tickers
start_date = "2023-01-01"  # Adjust these dates as needed
end_date = "2024-01-01"

for symbol in symbols:
    data = fetch_historical_data(symbol, start_date, end_date)
    data = calculate_indicators(data)  # Calculate indicators and signals
    total_profit, remaining_capital = enhanced_trading_logic(data)  # Run the trading logic

    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

def calculate_indicators(data):
    # Calculate RSI
    data['RSI'] = ...  # Your logic for RSI calculation here

    # Calculate MACD
    data['MACD'] = ...  # Your logic for MACD calculation here

    # Calculate Signal Line for MACD
    data['Signal_Line'] = data['MACD'].ewm(span=9, adjust=False).mean()

    # Calculate Bollinger Bands
    data['Bollinger_Upper'] = data['Close'].rolling(window=20).mean() + (data['Close'].rolling(window=20).std() * 2)
    data['Bollinger_Lower'] = data['Close'].rolling(window=20).mean() - (data['Close'].rolling(window=20).std() * 2)

    # Create Buy/Sell Signals
    data['Buy_Signal'] = (data['Close'] < data['Bollinger_Lower']).astype(int)  # Buy when price is below lower band
    data['Sell_Signal'] = (data['Close'] > data['Bollinger_Upper']).astype(int)  # Sell when price is above upper band

    # Print the last few rows to verify
    print(data[['Close', 'RSI', 'MACD', 'Signal_Line', 'Buy_Signal', 'Sell_Signal']].tail(10))  # Display last 10 rows

    return data

symbols = ['AAPL', 'GOOGL', 'MSFT']  # List of tickers
start_date = "2023-01-01"  # Adjust these dates as needed
end_date = "2024-01-01"

for symbol in symbols:
    data = fetch_historical_data(symbol, start_date, end_date)
    data = calculate_indicators(data)  # Calculate indicators and signals
    total_profit, remaining_capital = enhanced_trading_logic(data)  # Run the trading logic

    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    data['EMA_Short'] = data['Close'].ewm(span=short_window, adjust=False).mean()
    data['EMA_Long'] = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = data['EMA_Short'] - data['EMA_Long']
    data['Signal_Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()

def calculate_indicators(data):
    # Calculate RSI
    data['RSI'] = calculate_rsi(data)

    # Calculate MACD and Signal Line
    calculate_macd(data)

    # Calculate Bollinger Bands
    data['Bollinger_Upper'] = data['Close'].rolling(window=20).mean() + (data['Close'].rolling(window=20).std() * 2)
    data['Bollinger_Lower'] = data['Close'].rolling(window=20).mean() - (data['Close'].rolling(window=20).std() * 2)

    # Create Buy/Sell Signals
    data['Buy_Signal'] = (data['Close'] < data['Bollinger_Lower']).astype(int)  # Buy when price is below lower band
    data['Sell_Signal'] = (data['Close'] > data['Bollinger_Upper']).astype(int)  # Sell when price is above upper band

    # Print the last few rows to verify
    print(data[['Close', 'RSI', 'MACD', 'Signal_Line', 'Buy_Signal', 'Sell_Signal']].tail(10))  # Display last 10 rows

    return data

symbols = ['AAPL', 'GOOGL', 'MSFT']  # List of tickers
start_date = "2023-01-01"  # Adjust these dates as needed
end_date = "2024-01-01"

for symbol in symbols:
    data = fetch_historical_data(symbol, start_date, end_date)
    data = calculate_indicators(data)  # Calculate indicators and signals
    total_profit, remaining_capital = enhanced_trading_logic(data)  # Run the trading logic

    print(f"Total profit for {symbol}: {total_profit}, Remaining Capital: {remaining_capital}")

import pandas as pd
import yfinance as yf

# Helper functions
def fetch_historical_data(symbol, start_date, end_date):
    try:
        data = yf.download(symbol, start=start_date, end=end_date)
        if data.empty:
            print(f"No data fetched for {symbol} between {start_date} and {end_date}.")
            return None
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return None

def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    data['EMA_Short'] = data['Close'].ewm(span=short_window, adjust=False).mean()
    data['EMA_Long'] = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = data['EMA_Short'] - data['EMA_Long']
    data['Signal_Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()

def calculate_indicators(data):
    if data is None or data.shape[0] < 26:  # Not enough data for MACD or indicators
        return None

    # Calculate RSI
    data['RSI'] = calculate_rsi(data)

    # Calculate MACD and Signal Line
    calculate_macd(data)

    # Calculate Bollinger Bands
    data['Bollinger_Upper'] = data['Close'].rolling(window=20).mean() + (data['Close'].rolling(window=20).std() * 2)
    data['Bollinger_Lower'] = data['Close'].rolling(window=20).mean() - (data['Close'].rolling(window=20).std() * 2)

    # Create Buy/Sell Signals
    data['Buy_Signal'] = (data['Close'] < data['Bollinger_Lower']).astype(int)  # Buy when price is below lower band
    data['Sell_Signal'] = (data['Close'] > data['Bollinger_Upper']).astype(int)  # Sell when price is above upper band

    return data

def enhanced_trading_logic(data, remaining_capital, trade_amount=5, max_trades=40):
    total_profit = 0
    daily_trade_count = 0

    for index, row in data.iterrows():
        if row['Buy_Signal'] == 1 and remaining_capital >= trade_amount and daily_trade_count < max_trades:
            # Simulate a buy action
            buy_price = row['Close']
            remaining_capital -= trade_amount
            daily_trade_count += 1

        elif row['Sell_Signal'] == 1 and daily_trade_count > 0:
            # Simulate a sell action
            sell_price = row['Close']
            total_profit += (sell_price - buy_price) * (trade_amount / buy_price)
            remaining_capital += trade_amount
            daily_trade_count -= 1

    return total_profit, remaining_capital

# Set parameters for the multi-day simulation
symbols = ['AAPL', 'GOOGL', 'MSFT']  # Add more tickers as needed
start_date = "2023-09-01"
end_date = "2023-10-01"
remaining_capital = 200
max_trades_per_day = 40  # Assuming max of $200 per day and $5 per trade
trade_amount = 5  # Fixed trade amount

# Simulate over multiple tickers and track profits
total_profit = 0

for symbol in symbols:
    data = fetch_historical_data(symbol, start_date, end_date)

    if data is not None:
        data = calculate_indicators(data)
        if data is not None:
            profit, remaining_capital = enhanced_trading_logic(data, remaining_capital, trade_amount, max_trades_per_day)
            total_profit += profit
            print(f"Total profit for {symbol}: {profit}, Remaining Capital: {remaining_capital}")

# Display final results after simulation
print(f"Total Profit across all symbols: {total_profit}, Remaining Capital: {remaining_capital}")

git clone https://github.com/your-username/repository-name.git

git clone https://github.com/your-username/repository-name.git

git clone https://github.com/your-username/repository-name.git

git checkout -b new-branch-name

echo "# Day-Trader-AI" >> README.md

import pandas as pd
import numpy as np

# Example function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Example function to calculate MACD
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    data['EMA_Short'] = data['Close'].ewm(span=short_window, adjust=False).mean()
    data['EMA_Long'] = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = data['EMA_Short'] - data['EMA_Long']
    data['Signal_Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()
    return data

# Function to combine signals for trading logic
def combine_signals(data):
    # Buy Signal: Moving Average Crossover + RSI < 30 (oversold) + MACD positive crossover
    data['Buy_Signal'] = np.where((data['EMA_Short'] > data['EMA_Long']) & (data['RSI'] < 30) & (data['MACD'] > data['Signal_Line']), 1, 0)

    # Sell Signal: Moving Average Crossover + RSI > 70 (overbought) + MACD negative crossover
    data['Sell_Signal'] = np.where((data['EMA_Short'] < data['EMA_Long']) & (data['RSI'] > 70) & (data['MACD'] < data['Signal_Line']), 1, 0)

    return data

# Sample stock data (you can replace this with real data)
data = pd.DataFrame({
    'Close': [220, 221, 223, 225, 224, 226, 228, 227, 229, 230],
    'Volume': [5000, 5100, 5200, 5300, 5400, 5500, 5600, 5700, 5800, 5900]
})

# Apply technical indicators
data = calculate_rsi(data)
data = calculate_macd(data)

# Combine signals for buy/sell decision-making
data = combine_signals(data)

# Show the data with indicators and signals
print(data[['Close', 'RSI', 'MACD', 'Signal_Line', 'Buy_Signal', 'Sell_Signal']])

# Calculate RSI with a smaller window (e.g., 5) for the sample data
data = calculate_rsi(data, window=5)

!pip install yfinance

import yfinance as yf

# Function to fetch historical stock data using yfinance
def fetch_historical_data(ticker, start_date, end_date, interval='1d'):
    stock_data = yf.download(ticker, start=start_date, end=end_date, interval=interval)
    stock_data['Date'] = stock_data.index
    return stock_data

# Configuration for backtesting
ticker = 'AAPL'  # Example: Apple stock
start_date = '2023-01-01'
end_date = '2023-12-31'

# Fetch historical data
historical_data = fetch_historical_data(ticker, start_date, end_date)

# Show the first few rows of the historical data
print(historical_data.head())

# Apply technical indicators (RSI, MACD, Moving Averages) to the historical data
historical_data = calculate_rsi(historical_data, window=14)  # Applying RSI
historical_data = calculate_macd(historical_data)  # Applying MACD

# Combine signals for buy/sell decision-making
historical_data = combine_signals(historical_data)

# Function to simulate trades based on signals
def backtest_strategy(data, initial_capital=10000):
    capital = initial_capital
    position = 0  # 0 means no position, 1 means in a buy position
    trade_log = []

    for index, row in data.iterrows():
        if row['Buy_Signal'] == 1 and position == 0:  # Buy signal and no current position
            buy_price = row['Close']
            position = 1
            trade_log.append(f"Buy at {buy_price} on {row['Date']}")
        elif row['Sell_Signal'] == 1 and position == 1:  # Sell signal and currently holding
            sell_price = row['Close']
            profit = sell_price - buy_price
            capital += profit
            position = 0
            trade_log.append(f"Sell at {sell_price} on {row['Date']} with profit of {profit}")

    return capital, trade_log

# Simulate trades and track final capital
final_capital, trade_log = backtest_strategy(historical_data)

# Display the final results
print(f"Initial Capital: $10,000")
print(f"Final Capital: ${final_capital}")
print(f"Total Profit/Loss: ${final_capital - 10000}")
print("\nTrade Log:")
for trade in trade_log:
    print(trade)

# Modify the combine_signals function to use more flexible conditions
def combine_signals(data):
    # Buy Signal: Buy if either RSI < 30 or MACD positive crossover
    data['Buy_Signal'] = np.where((data['RSI'] < 30) | (data['MACD'] > data['Signal_Line']), 1, 0)

    # Sell Signal: Sell if either RSI > 70 or MACD negative crossover
    data['Sell_Signal'] = np.where((data['RSI'] > 70) | (data['MACD'] < data['Signal_Line']), 1, 0)

    return data

# Updated backtesting logic with stop-loss and take-profit functionality
def backtest_with_risk_management(data, initial_capital=10000, stop_loss_pct=0.05, take_profit_pct=0.1):
    capital = initial_capital
    position = 0  # 0 means no position, 1 means in a buy position
    trade_log = []
    buy_price = 0

    for index, row in data.iterrows():
        # Check for buy signal
        if row['Buy_Signal'] == 1 and position == 0:  # Buy signal and no current position
            buy_price = row['Close']
            position = 1
            trade_log.append(f"Buy at {buy_price} on {row['Date']}")

        # Check for sell signal or risk management conditions
        elif position == 1:
            # Check stop-loss condition
            if row['Close'] <= buy_price * (1 - stop_loss_pct):
                sell_price = row['Close']
                loss = sell_price - buy_price
                capital += loss
                position = 0
                trade_log.append(f"Stop-loss: Sell at {sell_price} on {row['Date']} with loss of {loss}")

            # Check take-profit condition
            elif row['Close'] >= buy_price * (1 + take_profit_pct):
                sell_price = row['Close']
                profit = sell_price - buy_price
                capital += profit
                position = 0
                trade_log.append(f"Take-profit: Sell at {sell_price} on {row['Date']} with profit of {profit}")

            # Check for normal sell signal
            elif row['Sell_Signal'] == 1:
                sell_price = row['Close']
                profit_loss = sell_price - buy_price
                capital += profit_loss
                position = 0
                trade_log.append(f"Sell at {sell_price} on {row['Date']} with profit/loss of {profit_loss}")

    return capital, trade_log

# Apply the updated backtesting strategy with risk management to the historical data
final_capital, trade_log = backtest_with_risk_management(historical_data, stop_loss_pct=0.05, take_profit_pct=0.1)

# Display the final results
print(f"Initial Capital: $10,000")
print(f"Final Capital: ${final_capital}")
print(f"Total Profit/Loss: ${final_capital - 10000}")
print("\nTrade Log:")
for trade in trade_log:
    print(trade)

final_capital, trade_log = backtest_with_risk_management(historical_data, stop_loss_pct=0.02, take_profit_pct=0.05)

# Function to calculate performance metrics and generate a summary report
def calculate_performance_metrics(trade_log, initial_capital=10000):
    total_trades = len(trade_log)
    winning_trades = sum(1 for trade in trade_log if "profit" in trade)
    losing_trades = total_trades - winning_trades
    total_profit_loss = sum(float(trade.split('with ')[1].split()[1]) for trade in trade_log if "profit" in trade or "loss" in trade)

    # Calculate win/loss ratio
    if total_trades > 0:
        win_loss_ratio = winning_trades / total_trades
    else:
        win_loss_ratio = 0

    # Average profit/loss per trade
    if total_trades > 0:
        avg_profit_loss = total_profit_loss / total_trades
    else:
        avg_profit_loss = 0

    # Calculate maximum drawdown (percentage loss from the highest point of capital)
    max_drawdown = 0
    capital_history = [initial_capital]
    current_capital = initial_capital

    for trade in trade_log:
        profit_loss = float(trade.split('with ')[1].split()[1])
        current_capital += profit_loss
        capital_history.append(current_capital)

    peak_capital = max(capital_history)
    for cap in capital_history:
        drawdown = (peak_capital - cap) / peak_capital
        if drawdown > max_drawdown:
            max_drawdown = drawdown

    # Generate summary report
    report = {
        "Total Trades": total_trades,
        "Winning Trades": winning_trades,
        "Losing Trades": losing_trades,
        "Win/Loss Ratio": win_loss_ratio,
        "Average Profit/Loss per Trade": avg_profit_loss,
        "Total Profit/Loss": total_profit_loss,
        "Max Drawdown (%)": max_drawdown * 100
    }

    return report

# Apply the updated backtesting strategy with risk management to the historical data
final_capital, trade_log = backtest_with_risk_management(historical_data, stop_loss_pct=0.02, take_profit_pct=0.05)

# Calculate performance metrics based on the trade log
performance_report = calculate_performance_metrics(trade_log)

# Display the performance metrics
print("Performance Metrics Summary:")
for key, value in performance_report.items():
    print(f"{key}: {value}")

print(f"\nFinal Capital: ${final_capital}")
print(f"Total Profit/Loss: ${final_capital - 10000}")

# Print trade log for review
print("\nTrade Log:")
for trade in trade_log:
    print(trade)

def combine_signals(data):
    # Buy Signal: Buy if RSI < 40 or MACD positive crossover
    data['Buy_Signal'] = np.where((data['RSI'] < 40) | (data['MACD'] > data['Signal_Line']), 1, 0)

    # Sell Signal: Sell if RSI > 60 or MACD negative crossover
    data['Sell_Signal'] = np.where((data['RSI'] > 60) | (data['MACD'] < data['Signal_Line']), 1, 0)

    return data

# Apply the updated backtesting strategy with lower stop-loss and take-profit thresholds
final_capital, trade_log = backtest_with_risk_management(historical_data, stop_loss_pct=0.01, take_profit_pct=0.03)

import numpy as np

# Define the environment for reinforcement learning
class TradingEnvironment:
    def __init__(self, data, initial_balance=10000):
        self.data = data  # Historical stock data
        self.initial_balance = initial_balance
        self.balance = initial_balance
        self.position = 0  # 1 means in a buy position, 0 means no position
        self.buy_price = 0
        self.current_step = 0
        self.done = False

    def reset(self):
        """ Reset the environment """
        self.balance = self.initial_balance
        self.position = 0
        self.buy_price = 0
        self.current_step = 0
        self.done = False
        return self._get_observation()

    def _get_observation(self):
        """ Get the current state (observation) """
        current_data = self.data.iloc[self.current_step]
        return np.array([
            current_data['Close'],
            current_data['RSI'],
            current_data['MACD'],
            current_data['Signal_Line'],
            self.balance,
            self.position
        ])

    def step(self, action):
        """ Take a step in the environment """
        reward = 0
        current_data = self.data.iloc[self.current_step]

        # Action: 0 = Hold, 1 = Buy, 2 = Sell
        if action == 1 and self.position == 0:  # Buy
            self.buy_price = current_data['Close']
            self.position = 1

        elif action == 2 and self.position == 1:  # Sell
            reward = current_data['Close'] - self.buy_price  # Profit or loss
            self.balance += reward
            self.position = 0

        # Update step
        self.current_step += 1
        if self.current_step >= len(self.data):
            self.done = True

        return self._get_observation(), reward, self.done

# Example usage with historical data
env = TradingEnvironment(historical_data)

# Reset the environment
initial_state = env.reset()

# Take a random action (0 = Hold, 1 = Buy, 2 = Sell) and step through the environment
action = np.random.choice([0, 1, 2])
new_state, reward, done = env.step(action)

# Display the result of the step
print(new_state, reward, done)

import random
import numpy as np

# Q-learning parameters
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 1.0  # Exploration rate
epsilon_decay = 0.995  # Decay for exploration rate
min_epsilon = 0.01  # Minimum exploration rate

# Initialize Q-Table (states x actions)
q_table = {}

# Number of actions: 0 = Hold, 1 = Buy, 2 = Sell
n_actions = 3

# Function to get the best action from the Q-Table or choose randomly
def choose_action(state, epsilon):
    state_key = tuple(state)  # Convert state to a tuple for hashing

    # Exploration vs Exploitation
    if random.uniform(0, 1) < epsilon:
        return random.choice([0, 1, 2])  # Explore: random action
    else:
        # Exploit: choose the action with the highest Q-value
        if state_key not in q_table:
            q_table[state_key] = np.zeros(n_actions)
        return np.argmax(q_table[state_key])

# Function to update the Q-Table
def update_q_table(state, action, reward, next_state, done):
    state_key = tuple(state)
    next_state_key = tuple(next_state)

    # Initialize the state in the Q-table if it's not there yet
    if state_key not in q_table:
        q_table[state_key] = np.zeros(n_actions)
    if next_state_key not in q_table:
        q_table[next_state_key] = np.zeros(n_actions)

    # Q-learning formula
    q_predict = q_table[state_key][action]
    q_target = reward
    if not done:
        q_target += gamma * np.max(q_table[next_state_key])
    q_table[state_key][action] += alpha * (q_target - q_predict)

# Training the Q-learning algorithm
def train_q_learning(env, episodes=1000):
    global epsilon
    for episode in range(episodes):
        state = env.reset()
        done = False
        total_reward = 0

        while not done:
            # Choose an action
            action = choose_action(state, epsilon)

            # Take the action and observe the result
            next_state, reward, done = env.step(action)
            total_reward += reward

            # Update the Q-table
            update_q_table(state, action, reward, next_state, done)

            # Move to the next state
            state = next_state

        # Decay the exploration rate (epsilon)
        epsilon = max(min_epsilon, epsilon * epsilon_decay)

        # Print the episode and total reward for tracking
        if (episode + 1) % 100 == 0:
            print(f"Episode {episode + 1}/{episodes}, Total Reward: {total_reward}")

# Example usage: Train the Q-learning agent on the environment
train_q_learning(env, episodes=1000)

import numpy as np

# Define the environment for reinforcement learning
class TradingEnvironment:
    def __init__(self, data, initial_balance=10000):
        self.data = data  # Historical stock data
        self.initial_balance = initial_balance
        self.balance = initial_balance
        self.position = 0  # 1 means in a buy position, 0 means no position
        self.buy_price = 0
        self.current_step = 0
        self.done = False

    def reset(self):
        """ Reset the environment """
        self.balance = self.initial_balance
        self.position = 0
        self.buy_price = 0
        self.current_step = 0
        self.done = False
        return self._get_observation()

    def _get_observation(self):
        """ Get the current state (observation) """
        current_data = self.data.iloc[self.current_step]
        return np.array([
            current_data['Close'],
            current_data['RSI'],
            current_data['MACD'],
            current_data['Signal_Line'],
            self.balance,
            self.position
        ])

    def step(self, action):
        """ Take a step in the environment """
        reward = 0
        current_data = self.data.iloc[self.current_step]

        # Action: 0 = Hold, 1 = Buy, 2 = Sell
        if action == 1 and self.position == 0:  # Buy
            self.buy_price = current_data['Close']
            self.position = 1

        elif action == 2 and self.position == 1:  # Sell
            reward = current_data['Close'] - self.buy_price  # Profit or loss
            self.balance += reward
            self.position = 0

        # Update step
        self.current_step += 1
        if self.current_step >= len(self.data):
            self.done = True

        return self._get_observation(), reward, self.done

# Example historical data (replace with your actual stock data)
# historical_data should have columns: 'Close', 'RSI', 'MACD', 'Signal_Line'
# Make sure to replace this placeholder with your actual data loading process
# historical_data = pd.read_csv("your_stock_data.csv")

# Example usage
env = TradingEnvironment(historical_data)

import yfinance as yf

# Fetch historical stock data using yfinance
def fetch_historical_data(ticker, start_date, end_date, interval='1d'):
    stock_data = yf.download(ticker, start=start_date, end=end_date, interval=interval)
    stock_data['Date'] = stock_data.index
    return stock_data

# Example configuration for fetching data
ticker = 'AAPL'  # Apple stock
start_date = '2023-01-01'
end_date = '2023-12-31'

# Fetch historical data
historical_data = fetch_historical_data(ticker, start_date, end_date)

# Ensure you have columns for 'Close', 'RSI', 'MACD', 'Signal_Line' in the data

# Example function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Example function to calculate MACD
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    data['EMA_Short'] = data['Close'].ewm(span=short_window, adjust=False).mean()
    data['EMA_Long'] = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = data['EMA_Short'] - data['EMA_Long']
    data['Signal_Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()
    return data

# Apply RSI and MACD to the historical data
historical_data = calculate_rsi(historical_data)
historical_data = calculate_macd(historical_data)

# Define the trading environment
env = TradingEnvironment(historical_data)

# Train the Q-learning agent on the environment
train_q_learning(env, episodes=1000)

def step(self, action):
    """ Take a step in the environment """
    reward = 0

    # Prevent index out-of-bounds by checking if the current_step is within bounds
    if self.current_step >= len(self.data) - 1:
        self.done = True
        return self._get_observation(), reward, self.done

    current_data = self.data.iloc[self.current_step]

    # Action: 0 = Hold, 1 = Buy, 2 = Sell
    if action == 1 and self.position == 0:  # Buy
        self.buy_price = current_data['Close']
        self.position = 1

    elif action == 2 and self.position == 1:  # Sell
        reward = current_data['Close'] - self.buy_price  # Profit or loss
        self.balance += reward
        self.position = 0

    # Update step
    self.current_step += 1
    if self.current_step >= len(self.data):
        self.done = True

    return self._get_observation(), reward, self.done

if self.current_step >= len(self.data) - 1:
    self.done = True
    return self._get_observation(), reward, self.done

def step(self, action):
    """ Take a step in the environment """
    reward = 0

    # Prevent index out-of-bounds by checking if the current_step is within bounds
    if self.current_step >= len(self.data) - 1:
        self.done = True
        return self._get_observation(), reward, self.done

    current_data = self.data.iloc[self.current_step]

    # Action: 0 = Hold, 1 = Buy, 2 = Sell
    if action == 1 and self.position == 0:  # Buy
        self.buy_price = current_data['Close']
        self.position = 1

    elif action == 2 and self.position == 1:  # Sell
        reward = current_data['Close'] - self.buy_price  # Profit or loss
        self.balance += reward
        self.position = 0

    # Update step
    self.current_step += 1
    if self.current_step >= len(self.data):
        self.done = True

    return self._get_observation(), reward, self.done

import itertools

# Parameter ranges for optimization
rsi_windows = [7, 14, 21]  # Different window lengths for RSI
macd_short_windows = [12, 15, 18]  # Short window for MACD
macd_long_windows = [26, 30, 35]  # Long window for MACD
stop_loss_pct = [0.02, 0.03, 0.05]  # Stop-loss percentages
take_profit_pct = [0.05, 0.07, 0.1]  # Take-profit percentages

# Function to optimize strategy parameters
def grid_search_optimization(data, episodes=500):
    best_reward = float('-inf')
    best_params = None

    # Generate all parameter combinations
    parameter_combinations = list(itertools.product(rsi_windows, macd_short_windows, macd_long_windows, stop_loss_pct, take_profit_pct))

    for params in parameter_combinations:
        rsi_window, macd_short, macd_long, stop_loss, take_profit = params

        # Apply RSI and MACD with current parameters
        data = calculate_rsi(data, window=rsi_window)
        data = calculate_macd(data, short_window=macd_short, long_window=macd_long)

        # Define environment with current stop-loss and take-profit
        env = TradingEnvironment(data)

        # Train the agent with Q-learning
        train_q_learning(env, episodes=episodes)

        # Get total reward for this parameter set
        total_reward = sum(env.balance for _ in range(episodes))

        # Track the best reward and parameters
        if total_reward > best_reward:
            best_reward = total_reward
            best_params = params

    return best_params, best_reward

# Run grid search optimization
best_params, best_reward = grid_search_optimization(historical_data)

# Display the best parameters and reward
print("Best Parameters:", best_params)
print("Best Total Reward:", best_reward)

def step(self, action):
    """ Take a step in the environment """
    reward = 0

    # Check if we are at the last step
    if self.current_step >= len(self.data) - 1:
        self.done = True
        return self._get_observation(), reward, self.done

    current_data = self.data.iloc[self.current_step]

    # Action: 0 = Hold, 1 = Buy, 2 = Sell
    if action == 1 and self.position == 0:  # Buy
        self.buy_price = current_data['Close']
        self.position = 1

    elif action == 2 and self.position == 1:  # Sell
        reward = current_data['Close'] - self.buy_price  # Profit or loss
        self.balance += reward
        self.position = 0

    # Move to the next step
    self.current_step += 1

    # Check if we are done after updating the step
    if self.current_step >= len(self.data):
        self.done = True

    return self._get_observation(), reward, self.done

def simulate_trading_bot(data, days_to_simulate=30, initial_balance=10000, stop_loss_pct=0.02, take_profit_pct=0.05):
    total_balance = initial_balance
    daily_profits = []
    daily_trades = []

    # Run the simulation day-by-day
    for day in range(days_to_simulate):
        print(f"Simulating Day {day + 1}/{days_to_simulate}...")

        # Reset environment for each day
        env = TradingEnvironment(data)
        balance = total_balance

        done = False
        while not done:
            # Choose action (0 = Hold, 1 = Buy, 2 = Sell) using Q-learning
            action = choose_action(env._get_observation(), epsilon=0.1)  # Lower epsilon for more exploitation

            # Take the action and get the results
            next_state, reward, done = env.step(action)

            # Track performance (profits and trades)
            total_balance += reward

        daily_profit = total_balance - balance
        daily_profits.append(daily_profit)
        daily_trades.append(day)

        # Print summary for each day
        print(f"Day {day + 1}: Profit/Loss: {daily_profit}, Total Balance: {total_balance}")

    # Return overall performance metrics
    return daily_profits, total_balance

# Run the simulation
daily_profits, final_balance = simulate_trading_bot(historical_data, days_to_simulate=30)

# Display final results
print(f"\nFinal Balance after {30} days: ${final_balance}")
print("Daily Profits:", daily_profits)

def step(self, action):
    """ Take a step in the environment """
    reward = 0

    # Prevent index out-of-bounds by checking if the current_step is within bounds
    if self.current_step >= len(self.data) - 1:
        self.done = True
        return self._get_observation(), reward, self.done

    current_data = self.data.iloc[self.current_step]

    # Action: 0 = Hold, 1 = Buy, 2 = Sell
    if action == 1 and self.position == 0:  # Buy
        self.buy_price = current_data['Close']
        self.position = 1

    elif action == 2 and self.position == 1:  # Sell
        reward = current_data['Close'] - self.buy_price  # Profit or loss
        self.balance += reward
        self.position = 0

    # Update step
    self.current_step += 1
    if self.current_step >= len(self.data):
        self.done = True

    return self._get_observation(), reward, self.done

# Full system simulation
def simulate_trading_bot(data, days_to_simulate=30, initial_balance=10000, stop_loss_pct=0.02, take_profit_pct=0.05):
    total_balance = initial_balance
    daily_profits = []
    daily_trades = []

    # Run the simulation day-by-day
    for day in range(days_to_simulate):
        print(f"Simulating Day {day + 1}/{days_to_simulate}...")

        # Reset environment for each day
        env = TradingEnvironment(data)
        balance = total_balance

        done = False
        while not done:
            # Prevent index out-of-bounds
            if env.current_step >= len(data) - 1:
                done = True
                break

            # Choose action (0 = Hold, 1 = Buy, 2 = Sell) using Q-learning
            action = choose_action(env._get_observation(), epsilon=0.1)  # Lower epsilon for more exploitation

            # Take the action and get the results
            next_state, reward, done = env.step(action)

            # Track performance (profits and trades)
            total_balance += reward

        daily_profit = total_balance - balance
        daily_profits.append(daily_profit)
        daily_trades.append(day)

        # Print summary for each day
        print(f"Day {day + 1}: Profit/Loss: {daily_profit}, Total Balance: {total_balance}")

    # Return overall performance metrics
    return daily_profits, total_balance

def simulate_trading_bot(data, days_to_simulate=30, initial_balance=10000, stop_loss_pct=0.02, take_profit_pct=0.05):
    total_balance = initial_balance
    daily_profits = []
    daily_trades = []
    actions_taken = {"buy": 0, "sell": 0, "hold": 0}

    # Run the simulation day-by-day
    for day in range(days_to_simulate):
        print(f"Simulating Day {day + 1}/{days_to_simulate}...")

        # Reset environment for each day
        env = TradingEnvironment(data)
        balance = total_balance

        done = False
        while not done:
            # Prevent index out-of-bounds
            if env.current_step >= len(data) - 1:
                done = True
                break

            # Choose action (0 = Hold, 1 = Buy, 2 = Sell) using Q-learning
            action = choose_action(env._get_observation(), epsilon=0.1)  # Lower epsilon for more exploitation
            if action == 0:
                actions_taken["hold"] += 1
            elif action == 1:
                actions_taken["buy"] += 1
            elif action == 2:
                actions_taken["sell"] += 1

            # Take the action and get the results
            next_state, reward, done = env.step(action)

            # Track performance (profits and trades)
            total_balance += reward

        daily_profit = total_balance - balance
        daily_profits.append(daily_profit)
        daily_trades.append(day)

        # Print summary for each day
        print(f"Day {day + 1}: Profit/Loss: {daily_profit}, Total Balance: {total_balance}")

    # Summary of learning
    total_profit = sum(daily_profits)
    avg_daily_profit = total_profit / days_to_simulate if days_to_simulate > 0 else 0

    print("\nSimulation Complete!")
    print(f"Final Balance after {days_to_simulate} days: ${total_balance}")
    print(f"Total Profit/Loss for the month: ${total_profit}")
    print(f"Average Daily Profit/Loss: ${avg_daily_profit}")
    print(f"Actions Taken: {actions_taken}")

    # Insights on what the AI learned
    print("\nAI Learning Insights:")
    print(f"The AI executed {actions_taken['buy']} buy actions, {actions_taken['sell']} sell actions, and {actions_taken['hold']} hold actions.")

    # Analyze if buy/sell decisions were profitable
    if actions_taken["sell"] > 0:
        sell_profit_ratio = actions_taken["sell"] / (actions_taken["buy"] + actions_taken["sell"])
        print(f"The AI found that {sell_profit_ratio:.2%} of sell actions led to a profit.")
    else:
        print("No sell actions were executed.")

    print(f"Moving forward, the AI will refine its strategy by focusing on better buy/sell opportunities based on profitable trades.")

    return daily_profits, total_balance

# Run the simulation with detailed insights
daily_profits, final_balance = simulate_trading_bot(historical_data, days_to_simulate=30)

def simulate_trading_bot(data, days_to_simulate=30, initial_balance=200, trade_amount=5, max_daily_loss=50, stop_loss_pct=0.02, take_profit_pct=0.05):
    total_balance = initial_balance
    daily_profits = []
    daily_trades = []
    actions_taken = {"buy": 0, "sell": 0, "hold": 0}
    total_loss_for_day = 0

    # Run the simulation day-by-day
    for day in range(days_to_simulate):
        print(f"Simulating Day {day + 1}/{days_to_simulate}...")

        # Reset environment for each day
        env = TradingEnvironment(data)
        balance = total_balance
        total_loss_for_day = 0  # Reset daily loss

        done = False
        while not done:
            # Prevent index out-of-bounds
            if env.current_step >= len(data) - 1:
                done = True
                break

            # Check if daily loss limit is reached
            if total_loss_for_day >= max_daily_loss:
                print(f"Max daily loss of $50 reached on Day {day + 1}. Stopping for the day.")
                break

            # Choose action (0 = Hold, 1 = Buy, 2 = Sell) using Q-learning
            action = choose_action(env._get_observation(), epsilon=0.1)  # Lower epsilon for more exploitation
            if action == 0:
                actions_taken["hold"] += 1
            elif action == 1 and balance >= trade_amount:  # Only buy if enough balance
                actions_taken["buy"] += 1
                balance -= trade_amount  # Deduct $5 per trade
            elif action == 2 and env.position == 1:  # Only sell if in a buy position
                actions_taken["sell"] += 1

            # Take the action and get the results
            next_state, reward, done = env.step(action)

            # Track performance (profits and trades)
            total_balance += reward
            if reward < 0:
                total_loss_for_day += abs(reward)  # Track daily losses

        daily_profit = total_balance - balance
        daily_profits.append(daily_profit)
        daily_trades.append(day)

        # Adjust trade amount based on profits
        if daily_profit > 0:
            trade_amount += daily_profit / 10  # Example: Increase trade size by 10% of the profit

        # Print summary for each day
        print(f"Day {day + 1}: Profit/Loss: {daily_profit}, Total Balance: {total_balance}, Trade Amount: ${trade_amount:.2f}")

    # Summary of learning
    total_profit = sum(daily_profits)
    avg_daily_profit = total_profit / days_to_simulate if days_to_simulate > 0 else 0

    print("\nSimulation Complete!")
    print(f"Final Balance after {days_to_simulate} days: ${total_balance}")
    print(f"Total Profit/Loss for the month: ${total_profit}")
    print(f"Average Daily Profit/Loss: ${avg_daily_profit}")
    print(f"Actions Taken: {actions_taken}")

    return daily_profits, total_balance

# Run the simulation with updated parameters
daily_profits, final_balance = simulate_trading_bot(historical_data, days_to_simulate=30)

# Run the simulation for the last 60 days
daily_profits, final_balance = simulate_trading_bot(historical_data, days_to_simulate=60)

# Display final results
print(f"\nFinal Balance after 60 days: ${final_balance}")
print("Daily Profits:", daily_profits)

# Run the simulation for the last 90 days (approx. 3 months)
daily_profits, final_balance = simulate_trading_bot(historical_data, days_to_simulate=90)

# Display final results
print(f"\nFinal Balance after 90 days: ${final_balance}")
print("Daily Profits:", daily_profits)

# List of multiple stocks to test
stock_tickers = ['AAPL', 'MSFT', 'TSLA', 'JPM', 'XOM']  # Example stocks from different sectors

def simulate_multiple_stocks(stock_tickers, days_to_simulate=60):
    all_results = []

    for ticker in stock_tickers:
        print(f"\nSimulating for {ticker}...")

        # Fetch historical data for each stock
        stock_data = fetch_historical_data(ticker, start_date='2023-01-01', end_date='2023-12-31')  # Adjust the date range as needed

        # Run the simulation for each stock
        daily_profits, final_balance = simulate_trading_bot(stock_data, days_to_simulate=days_to_simulate)

        # Store the results for each stock
        all_results.append({
            'ticker': ticker,
            'final_balance': final_balance,
            'daily_profits': daily_profits
        })

    return all_results

# Run the simulation for multiple stocks
multiple_stock_results = simulate_multiple_stocks(stock_tickers, days_to_simulate=60)

# Display final results for all stocks
for result in multiple_stock_results:
    print(f"Stock: {result['ticker']}, Final Balance: {result['final_balance']}")
    print(f"Daily Profits: {result['daily_profits']}\n")

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Function to calculate MACD
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    data['EMA_Short'] = data['Close'].ewm(span=short_window, adjust=False).mean()
    data['EMA_Long'] = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = data['EMA_Short'] - data['EMA_Long']
    data['Signal_Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()
    return data

# Update the simulation to calculate indicators before running
def simulate_multiple_stocks(stock_tickers, days_to_simulate=60):
    all_results = []

    for ticker in stock_tickers:
        print(f"\nSimulating for {ticker}...")

        # Fetch historical data for each stock
        stock_data = fetch_historical_data(ticker, start_date='2023-01-01', end_date='2023-12-31')  # Adjust the date range as needed

        # Calculate RSI and MACD before running the simulation
        stock_data = calculate_rsi(stock_data)
        stock_data = calculate_macd(stock_data)

        # Run the simulation for each stock
        daily_profits, final_balance = simulate_trading_bot(stock_data, days_to_simulate=days_to_simulate)

        # Store the results for each stock
        all_results.append({
            'ticker': ticker,
            'final_balance': final_balance,
            'daily_profits': daily_profits
        })

    return all_results

# Run the simulation for multiple stocks
multiple_stock_results = simulate_multiple_stocks(stock_tickers, days_to_simulate=60)

# Display final results for all stocks
for result in multiple_stock_results:
    print(f"Stock: {result['ticker']}, Final Balance: {result['final_balance']}")
    print(f"Daily Profits: {result['daily_profits']}\n")

def fetch_top_25_stocks(date):
    # Fetch historical stock data for a particular day (or minute)
    # Here, we assume we're fetching the top 25 based on volume
    top_25_data = fetch_historical_data_for_top_25(date)  # Placeholder function
    return top_25_data

# Simulate for the top 25 stocks each day for 6 months
def simulate_top_25_stocks(days_to_simulate=180):
    all_results = []

    for day in range(days_to_simulate):
        print(f"\nSimulating for Day {day + 1}/{days_to_simulate}...")

        # Fetch top 25 stocks for the current day
        date = get_date_for_simulation(day)  # Placeholder function
        top_25_data = fetch_top_25_stocks(date)

        # Run the simulation for the top 25 stocks
        daily_profits, final_balance = simulate_trading_bot(top_25_data, days_to_simulate=1)

        # Store the results for this day
        all_results.append({
            'day': day + 1,
            'final_balance': final_balance,
            'daily_profits': daily_profits
        })

    return all_results

# Run the simulation for the top 25 stocks each day for 180 days
results = simulate_top_25_stocks(days_to_simulate=180)

# Display results
for result in results:
    print(f"Day {result['day']}: Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

import pandas as pd

# Example list of dates for simulation
# Replace with actual dates from your historical data
dates_for_simulation = pd.date_range(start='2023-01-01', periods=180, freq='D')

# Simulate for the top 25 stocks each day
def simulate_top_25_stocks(dates_for_simulation):
    all_results = []

    for day, date in enumerate(dates_for_simulation):
        print(f"\nSimulating for Day {day + 1}/{len(dates_for_simulation)} ({date})...")

        # Fetch top 25 stocks for the current day based on date
        top_25_data = fetch_top_25_stocks(date)

        # Run the simulation for the top 25 stocks
        daily_profits, final_balance = simulate_trading_bot(top_25_data, days_to_simulate=1)

        # Store the results for this day
        all_results.append({
            'day': day + 1,
            'date': date,
            'final_balance': final_balance,
            'daily_profits': daily_profits
        })

    return all_results

# Run the simulation for the top 25 stocks each day for 180 days
results = simulate_top_25_stocks(dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

import yfinance as yf
import pandas as pd

# Fetch historical data for multiple stocks (e.g., from yfinance)
def fetch_historical_data_for_multiple_stocks(tickers, start_date, end_date):
    stock_data = {}
    for ticker in tickers:
        stock_data[ticker] = yf.download(ticker, start=start_date, end=end_date)
    return stock_data

# Function to fetch the top 25 stocks based on volume or price movement
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        if date in data.index:
            row = data.loc[date]
            row['Ticker'] = ticker
            daily_data = daily_data.append(row)

    # Sort by volume or price change to select top 25
    top_25 = daily_data.sort_values(by='Volume', ascending=False).head(25)  # Sort by volume as an example
    return top_25

# Simulate for the top 25 stocks each day
def simulate_top_25_stocks(stock_data, dates_for_simulation):
    all_results = []

    for day, date in enumerate(dates_for_simulation):
        print(f"\nSimulating for Day {day + 1}/{len(dates_for_simulation)} ({date})...")

        # Fetch top 25 stocks for the current day
        top_25_data = fetch_top_25_stocks(stock_data, date)

        # Run the simulation for the top 25 stocks
        daily_profits, final_balance = simulate_trading_bot(top_25_data, days_to_simulate=1)

        # Store the results for this day
        all_results.append({
            'day': day + 1,
            'date': date,
            'final_balance': final_balance,
            'daily_profits': daily_profits
        })

    return all_results

# Example tickers and date range for simulation
tickers = ['AAPL', 'MSFT', 'TSLA', 'GOOGL', 'AMZN']  # Example tickers
stock_data = fetch_historical_data_for_multiple_stocks(tickers, start_date='2023-01-01', end_date='2023-06-30')
dates_for_simulation = pd.date_range(start='2023-01-01', periods=180, freq='D')

# Run the simulation for the top 25 stocks each day for 180 days
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

# Function to fetch the top 25 stocks based on price change instead of volume
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        if date in data.index:
            row = data.loc[date]
            row['Ticker'] = ticker
            daily_data = daily_data.append(row)

    # Calculate percentage price change if Volume is not available
    daily_data['Price_Change'] = daily_data['Close'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Run the simulation using price change instead of volume
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

# Check the columns in stock data
for ticker, data in stock_data.items():
    print(f"Ticker: {ticker}, Columns: {data.columns}")

# Function to fetch the top 25 stocks based on price change (using 'Adj Close' if 'Close' is missing)
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        if date in data.index:
            row = data.loc[date]
            row['Ticker'] = ticker
            daily_data = daily_data.append(row)

    # Use 'Adj Close' if 'Close' is missing
    if 'Close' not in daily_data.columns:
        daily_data['Close'] = daily_data['Adj Close']

    # Calculate percentage price change
    daily_data['Price_Change'] = daily_data['Close'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Run the simulation
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:

# Function to fetch the top 25 stocks based on price change (using 'Adj Close' if 'Close' is missing)
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        if date in data.index:
            row = data.loc[date]
            row['Ticker'] = ticker
            daily_data = daily_data.append(row)

    # Use 'Adj Close' if 'Close' is missing
    if 'Close' not in daily_data.columns:
        daily_data['Close'] = daily_data['Adj Close']

    # Calculate percentage price change
    daily_data['Price_Change'] = daily_data['Close'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Example to simulate for top 25 stocks
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display the results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

# Function to fetch the top 25 stocks based on price change (using 'Adj Close' or 'Close')
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        if date in data.index:
            row = data.loc[date]
            row['Ticker'] = ticker
            daily_data = daily_data.append(row)

    # Check if either 'Close' or 'Adj Close' is available
    if 'Close' in daily_data.columns:
        daily_data['Price'] = daily_data['Close']
    elif 'Adj Close' in daily_data.columns:
        daily_data['Price'] = daily_data['Adj Close']
    else:
        raise KeyError("Neither 'Close' nor 'Adj Close' columns are available in the data")

    # Calculate percentage price change
    daily_data['Price_Change'] = daily_data['Price'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Run the simulation using the updated fetch_top_25_stocks function
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

# Check the available columns for each stock in the stock_data
for ticker, data in stock_data.items():
    print(f"Ticker: {ticker}, Columns: {data.columns}")

# Function to fetch the top 25 stocks based on price change (using 'Close')
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        if date in data.index:
            row = data.loc[date]
            row['Ticker'] = ticker
            daily_data = daily_data.append(row)

    # Use 'Close' price to calculate price change
    daily_data['Price'] = daily_data['Close']

    # Calculate percentage price change (day-to-day change)
    daily_data['Price_Change'] = daily_data['Price'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Run the simulation using the updated fetch_top_25_stocks function
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

# Function to fetch the top 25 stocks based on price change (using 'Close')
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        # Convert index to datetime if not already in datetime format
        if not pd.api.types.is_datetime64_any_dtype(data.index):
            data.index = pd.to_datetime(data.index)

        # Ensure the date is available in the stock data
        if date in data.index:
            row = data.loc[date].copy()  # Use .copy() to avoid SettingWithCopyWarning
            row['Ticker'] = ticker
            daily_data = daily_data.append(row)

    # Ensure 'Close' column exists before proceeding
    if 'Close' not in daily_data.columns:
        raise KeyError("'Close' column is missing in the stock data for this date.")

    # Use 'Close' price to calculate price change
    daily_data['Price'] = daily_data['Close']

    # Calculate percentage price change (day-to-day change)
    daily_data['Price_Change'] = daily_data['Price'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Run the simulation using the updated fetch_top_25_stocks function
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

# Function to fetch the top 25 stocks based on price change (using 'Close')
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        # Convert index to datetime if not already in datetime format
        if not pd.api.types.is_datetime64_any_dtype(data.index):
            data.index = pd.to_datetime(data.index)

        # Ensure the date is available in the stock data
        if date in data.index:
            row = data.loc[date].copy()  # Use .copy() to avoid SettingWithCopyWarning
            row['Ticker'] = ticker
            daily_data = daily_data.append(row)

    # Check if 'Close' column exists and contains data
    if 'Close' not in daily_data.columns or daily_data['Close'].isnull().all():
        print(f"Missing 'Close' data for {date}. Skipping this date.")
        return None  # Skip if data is missing

    # Use 'Close' price to calculate price change
    daily_data['Price'] = daily_data['Close']

    # Calculate percentage price change (day-to-day change)
    daily_data['Price_Change'] = daily_data['Price'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Updated simulation function to handle missing data
def simulate_top_25_stocks(stock_data, dates_for_simulation):
    all_results = []

    for day, date in enumerate(dates_for_simulation):
        print(f"\nSimulating for Day {day + 1}/{len(dates_for_simulation)} ({date})...")

        # Fetch top 25 stocks for the current day
        top_25_data = fetch_top_25_stocks(stock_data, date)

        if top_25_data is None:
            continue  # Skip this date if data is missing

        # Run the simulation for the top 25 stocks
        daily_profits, final_balance = simulate_trading_bot(top_25_data, days_to_simulate=1)

        # Store the results for this day
        all_results.append({
            'day': day + 1,
            'date': date,
            'final_balance': final_balance,
            'daily_profits': daily_profits
        })

    return all_results

# Run the simulation using the updated fetch_top_25_stocks function
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

# Function to fetch the top 25 stocks based on price change (using 'Close')
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        # Convert index to datetime if not already in datetime format
        if not pd.api.types.is_datetime64_any_dtype(data.index):
            data.index = pd.to_datetime(data.index)

        # Ensure the date is available in the stock data
        if date in data.index:
            row = data.loc[date].copy()  # Use .copy() to avoid SettingWithCopyWarning
            row['Ticker'] = ticker
            # Append data using pd.concat()
            daily_data = pd.concat([daily_data, pd.DataFrame([row])], ignore_index=True)

    # Check if 'Close' column exists and contains data
    if 'Close' not in daily_data.columns or daily_data['Close'].isnull().all():
        print(f"Missing 'Close' data for {date}. Skipping this date.")
        return None  # Skip if data is missing

    # Use 'Close' price to calculate price change
    daily_data['Price'] = daily_data['Close']

    # Calculate percentage price change (day-to-day change)
    daily_data['Price_Change'] = daily_data['Price'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Updated simulation function to handle missing data
def simulate_top_25_stocks(stock_data, dates_for_simulation):
    all_results = []

    for day, date in enumerate(dates_for_simulation):
        print(f"\nSimulating for Day {day + 1}/{len(dates_for_simulation)} ({date})...")

        # Fetch top 25 stocks for the current day
        top_25_data = fetch_top_25_stocks(stock_data, date)

        if top_25_data is None:
            continue  # Skip this date if data is missing

        # Run the simulation for the top 25 stocks
        daily_profits, final_balance = simulate_trading_bot(top_25_data, days_to_simulate=1)

        # Store the results for this day
        all_results.append({
            'day': day + 1,
            'date': date,
            'final_balance': final_balance,
            'daily_profits': daily_profits
        })

    return all_results

# Run the simulation using the updated fetch_top_25_stocks function
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Function to fetch the top 25 stocks based on price change (including RSI calculation)
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        # Convert index to datetime if not already in datetime format
        if not pd.api.types.is_datetime64_any_dtype(data.index):
            data.index = pd.to_datetime(data.index)

        # Ensure the date is available in the stock data
        if date in data.index:
            row = data.loc[date].copy()  # Use .copy() to avoid SettingWithCopyWarning
            row['Ticker'] = ticker
            # Append data using pd.concat()
            daily_data = pd.concat([daily_data, pd.DataFrame([row])], ignore_index=True)

    # Check if 'Close' column exists and contains data
    if 'Close' not in daily_data.columns or daily_data['Close'].isnull().all():
        print(f"Missing 'Close' data for {date}. Skipping this date.")
        return None  # Skip if data is missing

    # Use 'Close' price to calculate price change
    daily_data['Price'] = daily_data['Close']

    # Calculate RSI
    daily_data = calculate_rsi(daily_data)

    # Calculate percentage price change (day-to-day change)
    daily_data['Price_Change'] = daily_data['Price'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Updated simulation function to handle missing data
def simulate_top_25_stocks(stock_data, dates_for_simulation):
    all_results = []

    for day, date in enumerate(dates_for_simulation):
        print(f"\nSimulating for Day {day + 1}/{len(dates_for_simulation)} ({date})...")

        # Fetch top 25 stocks for the current day
        top_25_data = fetch_top_25_stocks(stock_data, date)

        if top_25_data is None:
            continue  # Skip this date if data is missing

        # Run the simulation for the top 25 stocks
        daily_profits, final_balance = simulate_trading_bot(top_25_data, days_to_simulate=1)

        # Store the results for this day
        all_results.append({
            'day': day + 1,
            'date': date,
            'final_balance': final_balance,
            'daily_profits': daily_profits
        })

    return all_results

# Run the simulation using the updated fetch_top_25_stocks function
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

# Function to calculate MACD
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    data['EMA_Short'] = data['Close'].ewm(span=short_window, adjust=False).mean()
    data['EMA_Long'] = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = data['EMA_Short'] - data['EMA_Long']
    data['Signal_Line'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()
    return data

# Function to calculate RSI and MACD
def calculate_indicators(data):
    # Calculate RSI
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    data['RSI'] = 100 - (100 / (1 + rs))

    # Calculate MACD
    data = calculate_macd(data)

    return data

# Function to fetch the top 25 stocks based on price change (including RSI and MACD calculation)
def fetch_top_25_stocks(stock_data, date):
    daily_data = pd.DataFrame()

    # Extract data for the given date across all tickers
    for ticker, data in stock_data.items():
        # Convert index to datetime if not already in datetime format
        if not pd.api.types.is_datetime64_any_dtype(data.index):
            data.index = pd.to_datetime(data.index)

        # Ensure the date is available in the stock data
        if date in data.index:
            row = data.loc[date].copy()  # Use .copy() to avoid SettingWithCopyWarning
            row['Ticker'] = ticker
            # Append data using pd.concat()
            daily_data = pd.concat([daily_data, pd.DataFrame([row])], ignore_index=True)

    # Check if 'Close' column exists and contains data
    if 'Close' not in daily_data.columns or daily_data['Close'].isnull().all():
        print(f"Missing 'Close' data for {date}. Skipping this date.")
        return None  # Skip if data is missing

    # Use 'Close' price to calculate price change
    daily_data['Price'] = daily_data['Close']

    # Calculate RSI and MACD
    daily_data = calculate_indicators(daily_data)

    # Calculate percentage price change (day-to-day change)
    daily_data['Price_Change'] = daily_data['Price'].pct_change() * 100
    top_25 = daily_data.sort_values(by='Price_Change', ascending=False).head(25)  # Sort by price change
    return top_25

# Updated simulation function to handle missing data
def simulate_top_25_stocks(stock_data, dates_for_simulation):
    all_results = []

    for day, date in enumerate(dates_for_simulation):
        print(f"\nSimulating for Day {day + 1}/{len(dates_for_simulation)} ({date})...")

        # Fetch top 25 stocks for the current day
        top_25_data = fetch_top_25_stocks(stock_data, date)

        if top_25_data is None:
            continue  # Skip this date if data is missing

        # Run the simulation for the top 25 stocks
        daily_profits, final_balance = simulate_trading_bot(top_25_data, days_to_simulate=1)

        # Store the results for this day
        all_results.append({
            'day': day + 1,
            'date': date,
            'final_balance': final_balance,
            'daily_profits': daily_profits
        })

    return all_results

# Run the simulation using the updated fetch_top_25_stocks function
results = simulate_top_25_stocks(stock_data, dates_for_simulation)

# Display results
for result in results:
    print(f"Day {result['day']} ({result['date']}): Final Balance: {result['final_balance']}, Daily Profits: {result['daily_profits']}")

def fetch_top_25_stocks(stock_data, date):
    daily_data = stock_data.get(date)

    if daily_data is None:
        print(f"Missing data for {date}. Skipping this date.")
        return None

    # Interpolate missing 'Close' data if needed
    if 'Close' in daily_data.columns:
        daily_data['Close'] = daily_data['Close'].interpolate()
    else:
        print(f"Missing 'Close' column for {date}. Skipping this date.")
        return None

    return daily_data

def trading_logic(stock_data, balance, trade_amount):
    for stock, data in stock_data.items():
        rsi = data['RSI'].iloc[-1]
        macd = data['MACD'].iloc[-1]

        # Adjust thresholds for buy/sell
        if rsi < 40 and macd > 0:
            print(f"Buying {stock}")
            balance -= trade_amount
            # Logic to execute buy
        elif rsi > 60 and macd < 0:
            print(f"Selling {stock}")
            balance += trade_amount
            # Logic to execute sell
        else:
            print(f"Holding {stock}")

    return balance

def stop_loss_take_profit(current_price, buy_price, stop_loss_pct=0.05, take_profit_pct=0.10):
    # Stop-Loss Condition
    if current_price <= buy_price * (1 - stop_loss_pct):
        print(f"Triggering stop-loss. Selling at {current_price}")
        return 'sell'

    # Take-Profit Condition
    elif current_price >= buy_price * (1 + take_profit_pct):
        print(f"Triggering take-profit. Selling at {current_price}")
        return 'sell'

    return 'hold'

import logging

# Configure logging
logging.basicConfig(filename='trading_bot.log', level=logging.INFO)

def log_trade_decision(date, stock, action, price, balance):
    logging.info(f"{date} - {stock}: {action} at {price}, Balance: {balance}")

# Example use
log_trade_decision('2023-03-15', 'AAPL', 'buy', 150.00, 1000.00)

def fetch_top_25_stocks(stock_data, date):
    daily_data = stock_data.get(date)

    if daily_data is None:
        print(f"Missing data for {date}. Skipping this date.")
        return None

    # Fill missing data if 'Close' column exists
    if 'Close' in daily_data.columns:
        daily_data['Close'] = daily_data['Close'].interpolate(method='linear')
    else:
        print(f"Missing 'Close' column for {date}. Skipping this date.")
        return None

    return daily_data

def trading_logic(stock_data, balance, trade_amount):
    for stock, data in stock_data.items():
        # Ensure data has both 'RSI' and 'MACD' columns
        if 'RSI' not in data.columns or 'MACD' not in data.columns:
            print(f"Skipping {stock} due to missing indicators")
            continue

        rsi = data['RSI'].iloc[-1]  # Get the most recent RSI value
        macd = data['MACD'].iloc[-1]  # Get the most recent MACD value

        # Modify buy/sell thresholds
        if rsi < 40 and macd > 0:
            print(f"Buying {stock}")
            balance -= trade_amount
            # Add your buy execution logic here
        elif rsi > 60 and macd < 0:
            print(f"Selling {stock}")
            balance += trade_amount
            # Add your sell execution logic here
        else:
            print(f"Holding {stock}")

    return balance

def simulate_top_25_stocks(stock_data, dates_for_simulation, initial_balance=200):
    balance = initial_balance
    trade_amount = 5.0  # Fixed trade amount

    for date in dates_for_simulation:
        print(f"Simulating for Day {date}...")

        daily_data = fetch_top_25_stocks(stock_data, date)
        if daily_data is None:
            continue

        # Execute trading logic for the top 25 stocks
        balance = trading_logic(daily_data, balance, trade_amount)
        print(f"End of day {date}, Balance: {balance}")

    return balance

# Example usage with test data
dates_for_simulation = ['2023-01-01', '2023-01-02', '2023-01-03']  # Example dates
stock_data = {
    '2023-01-01': pd.DataFrame({'Close': [150, 200], 'RSI': [35, 45], 'MACD': [0.5, -0.5]}),
    '2023-01-02': pd.DataFrame({'Close': [155, 205], 'RSI': [55, 65], 'MACD': [0.3, -0.4]}),
    '2023-01-03': pd.DataFrame({'Close': [160, 210], 'RSI': [45, 35], 'MACD': [-0.3, 0.2]})
}

final_balance = simulate_top_25_stocks(stock_data, dates_for_simulation)
print(f"Final balance after simulation: {final_balance}")

def fetch_top_25_stocks(stock_data, date):
    daily_data = stock_data.get(date)

    if daily_data is None:
        print(f"Missing data for {date}. Skipping this date.")
        return None

    # Ensure that daily_data is a DataFrame and not a Series
    if isinstance(daily_data, pd.Series):
        daily_data = daily_data.to_frame().T  # Convert Series to DataFrame

    # Check for 'Close' column and handle missing data
    if 'Close' in daily_data.columns:
        daily_data['Close'] = daily_data['Close'].interpolate(method='linear')
    else:
        print(f"Missing 'Close' column for {date}. Skipping this date.")
        return None

    return daily_data

# Example usage with test data
dates_for_simulation = ['2023-01-01', '2023-01-02', '2023-01-03']  # Example dates
stock_data = {
    '2023-01-01': pd.DataFrame({'Close': [150, 200], 'RSI': [35, 45], 'MACD': [0.5, -0.5]}),
    '2023-01-02': pd.DataFrame({'Close': [155, 205], 'RSI': [55, 65], 'MACD': [0.3, -0.4]}),
    '2023-01-03': pd.DataFrame({'Close': [160, 210], 'RSI': [45, 35], 'MACD': [-0.3, 0.2]})
}

final_balance = simulate_top_25_stocks(stock_data, dates_for_simulation)
print(f"Final balance after simulation: {final_balance}")

def fetch_top_25_stocks(stock_data, date):
    daily_data = stock_data.get(date)

    if daily_data is None:
        print(f"Missing data for {date}. Skipping this date.")
        return None

    # Ensure daily_data is a DataFrame
    if isinstance(daily_data, pd.Series):
        daily_data = daily_data.to_frame().T  # Convert Series to DataFrame

    # Check if it's still a DataFrame, and if not, handle it appropriately
    if not isinstance(daily_data, pd.DataFrame):
        print(f"Data for {date} is not a valid DataFrame. Skipping this date.")
        return None

    # Check for 'Close' column
    if 'Close' in daily_data.columns:
        daily_data['Close'] = daily_data['Close'].interpolate(method='linear')
    else:
        print(f"Missing 'Close' column for {date}. Skipping this date.")
        return None

    return daily_data

# Example usage with test data
dates_for_simulation = ['2023-01-01', '2023-01-02', '2023-01-03']  # Example dates
stock_data = {
    '2023-01-01': pd.Series({'Close': 150, 'RSI': 35, 'MACD': 0.5}),
    '2023-01-02': pd.DataFrame({'Close': [155, 205], 'RSI': [55, 65], 'MACD': [0.3, -0.4]}),
    '2023-01-03': pd.Series({'Close': 160, 'RSI': 45, 'MACD': -0.3})
}

final_balance = simulate_top_25_stocks(stock_data, dates_for_simulation)
print(f"Final balance after simulation: {final_balance}")

def fetch_top_25_stocks(stock_data, date):
    daily_data = stock_data.get(date)

    if daily_data is None:
        print(f"Missing data for {date}. Skipping this date.")
        return None

    # Ensure daily_data is a DataFrame
    if isinstance(daily_data, pd.Series):
        daily_data = daily_data.to_frame().T  # Convert Series to DataFrame

    # Ensure it's now a DataFrame and contains the 'Close' column
    if isinstance(daily_data, pd.DataFrame):
        if 'Close' in daily_data.columns:
            daily_data['Close'] = daily_data['Close'].interpolate(method='linear')
        else:
            print(f"Missing 'Close' column for {date}. Skipping this date.")
            return None
    else:
        print(f"Data for {date} is not a valid DataFrame. Skipping this date.")
        return None

    return daily_data

# Test data to simulate different cases
dates_for_simulation = ['2023-01-01', '2023-01-02', '2023-01-03']  # Example dates
stock_data = {
    '2023-01-01': pd.Series({'Close': 150, 'RSI': 35, 'MACD': 0.5}),
    '2023-01-02': pd.DataFrame({'Close': [155, 205], 'RSI': [55, 65], 'MACD': [0.3, -0.4]}),
    '2023-01-03': pd.Series({'Close': 160, 'RSI': 45, 'MACD': -0.3})
}

# Re-run the simulation
final_balance = simulate_top_25_stocks(stock_data, dates_for_simulation)
print(f"Final balance after simulation: {final_balance}")

def fetch_top_25_stocks(stock_data, date):
    daily_data = stock_data.get(date)

    if daily_data is None:
        print(f"Missing data for {date}. Skipping this date.")
        return None

    # Convert Series to DataFrame if necessary
    if isinstance(daily_data, pd.Series):
        daily_data = pd.DataFrame(daily_data).T  # Transpose to turn into a DataFrame

    # Ensure it's now a DataFrame and contains the 'Close' column
    if isinstance(daily_data, pd.DataFrame):
        if 'Close' in daily_data.columns:
            daily_data['Close'] = daily_data['Close'].interpolate(method='linear')
        else:
            print(f"Missing 'Close' column for {date}. Skipping this date.")
            return None
    else:
        print(f"Data for {date} is not a valid DataFrame. Skipping this date.")
        return None

    return daily_data

# Test data to simulate different cases
dates_for_simulation = ['2023-01-01', '2023-01-02', '2023-01-03']  # Example dates
stock_data = {
    '2023-01-01': pd.Series({'Close': 150, 'RSI': 35, 'MACD': 0.5}),  # Series case
    '2023-01-02': pd.DataFrame({'Close': [155, 205], 'RSI': [55, 65], 'MACD': [0.3, -0.4]}),  # DataFrame case
    '2023-01-03': pd.Series({'Close': 160, 'RSI': 45, 'MACD': -0.3})  # Series case
}

# Re-run the simulation
final_balance = simulate_top_25_stocks(stock_data, dates_for_simulation)
print(f"Final balance after simulation: {final_balance}")

def fetch_top_25_stocks(stock_data, date):
    daily_data = stock_data.get(date)

    if daily_data is None:
        print(f"Missing data for {date}. Skipping this date.")
        return None

    # Convert Series to DataFrame if necessary
    if isinstance(daily_data, pd.Series):
        daily_data = pd.DataFrame(daily_data).T  # Transpose to make it a DataFrame

    # Ensure it's now a DataFrame and contains the 'Close' column
    if isinstance(daily_data, pd.DataFrame):
        if 'Close' not in daily_data.columns:
            print(f"Missing 'Close' column for {date}. Skipping this date.")
            return None
    else:
        print(f"Data for {date} is not a valid DataFrame. Skipping this date.")
        return None

    return daily_data

# Test data to simulate both Series and DataFrame cases
dates_for_simulation = ['2023-01-01', '2023-01-02', '2023-01-03']  # Example dates
stock_data = {
    '2023-01-01': pd.Series({'Close': 150, 'RSI': 35, 'MACD': 0.5}),  # Series case
    '2023-01-02': pd.DataFrame({'Close': [155, 205], 'RSI': [55, 65], 'MACD': [0.3, -0.4]}),  # DataFrame case
    '2023-01-03': pd.Series({'Close': 160, 'RSI': 45, 'MACD': -0.3})  # Series case
}

# Re-run the simulation
final_balance = simulate_top_25_stocks(stock_data, dates_for_simulation)
print(f"Final balance after simulation: {final_balance}")

def simulate_top_25_stocks(stock_data, dates_for_simulation):
    total_balance = 200  # Starting balance
    trade_amount = 5  # Starting trade amount
    for date in dates_for_simulation:
        print(f"Simulating for Day {date}...")

        # Fetch the top 25 stocks for this date
        daily_data = fetch_top_25_stocks(stock_data, date)

        if daily_data is None:
            continue  # Skip if no data

        # Ensure daily_data is a DataFrame
        if isinstance(daily_data, pd.Series):
            daily_data = pd.DataFrame(daily_data).T  # Convert Series to DataFrame

        # Check for essential columns
        if 'Close' not in daily_data.columns:
            print(f"Missing 'Close' data for {date}. Skipping.")
            continue

        # Process the trading logic
        # Example: Buy logic based on RSI
        rsi_value = daily_data['RSI'].values[0]
        if rsi_value < 30:  # Example buy signal
            total_balance += trade_amount
            print(f"Bought at {daily_data['Close'].values[0]} on {date}. Balance: {total_balance}")
        elif rsi_value > 70:  # Example sell signal
            total_balance -= trade_amount
            print(f"Sold at {daily_data['Close'].values[0]} on {date}. Balance: {total_balance}")
        else:
            print(f"Holding on {date}. Balance: {total_balance}")

    return total_balance

def fetch_top_25_stocks(stock_data, date):
    daily_data = stock_data.get(date)

    if daily_data is None:
        print(f"Missing data for {date}. Skipping this date.")
        return None

    # Convert Series to DataFrame if necessary
    if isinstance(daily_data, pd.Series):
        daily_data = pd.DataFrame(daily_data).T  # Transpose to make it a DataFrame

    # Ensure it's now a DataFrame and contains the 'Close' column
    if 'Close' not in daily_data.columns:
        print(f"Missing 'Close' column for {date}. Skipping this date.")
        return None

    return daily_data

# Test data with both Series and DataFrame cases
dates_for_simulation = ['2023-01-01', '2023-01-02', '2023-01-03']  # Example dates
stock_data = {
    '2023-01-01': pd.Series({'Close': 150, 'RSI': 35, 'MACD': 0.5}),  # Series case
    '2023-01-02': pd.DataFrame({'Close': [155, 205], 'RSI': [55, 65], 'MACD': [0.3, -0.4]}),  # DataFrame case
    '2023-01-03': pd.Series({'Close': 160, 'RSI': 45, 'MACD': -0.3})  # Series case
}

# Re-run the simulation
final_balance = simulate_top_25_stocks(stock_data, dates_for_simulation)
print(f"Final balance after simulation: {final_balance}")

def simulate_top_25_stocks(stock_data, dates_for_simulation):
    total_balance = 200  # Starting balance
    trade_amount = 5  # Starting trade amount
    for date in dates_for_simulation:
        print(f"\nSimulating for Day {date}...")

        # Fetch the top 25 stocks for this date
        daily_data = fetch_top_25_stocks(stock_data, date)

        if daily_data is None:
            continue  # Skip if no data

        # Ensure daily_data is a DataFrame
        if isinstance(daily_data, pd.Series):
            daily_data = pd.DataFrame(daily_data).T  # Convert Series to DataFrame

        # Check for essential columns
        if 'Close' not in daily_data.columns or 'RSI' not in daily_data.columns:
            print(f"Missing 'Close' or 'RSI' data for {date}. Skipping.")
            continue

        # Process the trading logic based on RSI
        rsi_value = daily_data['RSI'].values[0]
        print(f"RSI on {date}: {rsi_value}")

        if rsi_value < 30:  # Example buy signal
            total_balance += trade_amount
            print(f"Bought at {daily_data['Close'].values[0]} on {date}. Balance: {total_balance}")
        elif rsi_value > 70:  # Example sell signal
            total_balance -= trade_amount
            print(f"Sold at {daily_data['Close'].values[0]} on {date}. Balance: {total_balance}")
        else:
            print(f"Holding on {date}. Balance: {total_balance}")

    return total_balance

# Test data with both Series and DataFrame cases
dates_for_simulation = ['2023-01-01', '2023-01-02', '2023-01-03']  # Example dates
stock_data = {
    '2023-01-01': pd.Series({'Close': 150, 'RSI': 35, 'MACD': 0.5}),  # Series case
    '2023-01-02': pd.DataFrame({'Close': [155, 205], 'RSI': [55, 65], 'MACD': [0.3, -0.4]}),  # DataFrame case
    '2023-01-03': pd.Series({'Close': 160, 'RSI': 45, 'MACD': -0.3})  # Series case
}

# Re-run the simulation
final_balance = simulate_top_25_stocks(stock_data, dates_for_simulation)
print(f"Final balance after simulation: {final_balance}")

def simulate_top_25_stocks(stock_data, dates_for_simulation):
    total_balance = 200  # Starting balance
    trade_amount = 5  # Starting trade amount
    for date in dates_for_simulation:
        print(f"\nSimulating for Day {date}...")

        # Fetch the top 25 stocks for this date
        daily_data = fetch_top_25_stocks(stock_data, date)

        if daily_data is None:
            continue  # Skip if no data

        # Ensure daily_data is a DataFrame
        if isinstance(daily_data, pd.Series):
            daily_data = pd.DataFrame(daily_data).T  # Convert Series to DataFrame

        # Check for essential columns
        if 'Close' not in daily_data.columns or 'RSI' not in daily_data.columns:
            print(f"Missing 'Close' or 'RSI' data for {date}. Skipping.")
            continue

        # Process the trading logic based on RSI
        rsi_value = daily_data['RSI'].values[0]
        print(f"RSI on {date}: {rsi_value}")

        if rsi_value < 40:  # Adjusted buy signal (more lenient)
            total_balance += trade_amount
            print(f"Bought at {daily_data['Close'].values[0]} on {date}. Balance: {total_balance}")
        elif rsi_value > 60:  # Adjusted sell signal (more lenient)
            total_balance -= trade_amount
            print(f"Sold at {daily_data['Close'].values[0]} on {date}. Balance: {total_balance}")
        else:
            print(f"Holding on {date}. Balance: {total_balance}")

    return total_balance

import pandas as pd

# Simulate historical stock data for backtesting
def generate_historical_stock_data(start_date, end_date):
    date_range = pd.date_range(start=start_date, end=end_date, freq='B')  # Business days
    data = pd.DataFrame(index=date_range)
    data['Close'] = 100 + (pd.Series(range(len(date_range))) % 10) * 2  # Mock close price pattern
    data['RSI'] = 30 + (pd.Series(range(len(date_range))) % 40)  # Mock RSI values for trading signals
    return data

# Function to simulate a basic RSI trading strategy
def run_backtest_simulation(stock_data, starting_balance=200, trade_amount=5, days_to_simulate=180):
    balance = starting_balance
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []

    for day in range(days_to_simulate):
        rsi = stock_data['RSI'].iloc[day]

        if rsi < 30 and balance >= trade_amount:
            # Buy condition based on RSI
            balance -= trade_amount
            actions_taken['buy'] += 1
        elif rsi > 70:
            # Sell condition based on RSI
            balance += trade_amount
            actions_taken['sell'] += 1
        else:
            # Hold if no buy/sell action is triggered
            actions_taken['hold'] += 1

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Setup the backtest parameters
start_date = '2023-01-01'
end_date = '2023-06-30'
initial_balance = 200
trade_amount = 5

# Generate historical stock data and run the simulation
historical_stock_data = generate_historical_stock_data(start_date, end_date)
final_balance, daily_balances, actions_taken = run_backtest_simulation(historical_stock_data, initial_balance, trade_amount)

# Displaying the first 10 days of results for clarity
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

import pandas as pd

# Simulate historical stock data for backtesting
def generate_historical_stock_data(start_date, end_date):
    date_range = pd.date_range(start=start_date, end=end_date, freq='B')  # Business days
    data = pd.DataFrame(index=date_range)
    data['Close'] = 100 + (pd.Series(range(len(date_range))) % 10) * 2  # Mock close price pattern
    data['RSI'] = 30 + (pd.Series(range(len(date_range))) % 40)  # Mock RSI values for trading signals
    return data

# Function to simulate a basic RSI trading strategy
def run_backtest_simulation(stock_data, starting_balance=200, trade_amount=5):
    balance = starting_balance
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []

    # Ensure we only iterate over available days in stock_data
    for day in range(len(stock_data)):
        rsi = stock_data['RSI'].iloc[day]

        if rsi < 30 and balance >= trade_amount:
            # Buy condition based on RSI
            balance -= trade_amount
            actions_taken['buy'] += 1
        elif rsi > 70:
            # Sell condition based on RSI
            balance += trade_amount
            actions_taken['sell'] += 1
        else:
            # Hold if no buy/sell action is triggered
            actions_taken['hold'] += 1

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Setup the backtest parameters
start_date = '2023-01-01'
end_date = '2023-06-30'
initial_balance = 200
trade_amount = 5

# Generate historical stock data and run the simulation
historical_stock_data = generate_historical_stock_data(start_date, end_date)
final_balance, daily_balances, actions_taken = run_backtest_simulation(historical_stock_data, initial_balance, trade_amount)

# Displaying the first 10 days of results for clarity
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

import numpy as np

# Simulate historical stock data with more dynamic RSI values
def generate_historical_stock_data(start_date, end_date):
    date_range = pd.date_range(start=start_date, end=end_date, freq='B')  # Business days
    data = pd.DataFrame(index=date_range)
    data['Close'] = 100 + (np.random.randn(len(date_range)) * 2).cumsum()  # Random close prices
    data['RSI'] = 30 + (np.random.randn(len(date_range)) * 50)  # More dynamic RSI values for trading signals
    data['RSI'] = np.clip(data['RSI'], 0, 100)  # Ensure RSI stays within 0 to 100
    return data

# Function to simulate a basic RSI trading strategy
def run_backtest_simulation(stock_data, starting_balance=200, trade_amount=5):
    balance = starting_balance
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []

    # Ensure we only iterate over available days in stock_data
    for day in range(len(stock_data)):
        rsi = stock_data['RSI'].iloc[day]

        if rsi < 30 and balance >= trade_amount:
            # Buy condition based on RSI
            balance -= trade_amount
            actions_taken['buy'] += 1
        elif rsi > 70:
            # Sell condition based on RSI
            balance += trade_amount
            actions_taken['sell'] += 1
        else:
            # Hold if no buy/sell action is triggered
            actions_taken['hold'] += 1

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Setup the backtest parameters
start_date = '2023-01-01'
end_date = '2023-06-30'
initial_balance = 200
trade_amount = 5

# Generate historical stock data and run the simulation
historical_stock_data = generate_historical_stock_data(start_date, end_date)
final_balance, daily_balances, actions_taken = run_backtest_simulation(historical_stock_data, initial_balance, trade_amount)

# Displaying the first 10 days of results for clarity
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

import yfinance as yf
import pandas as pd

def get_historical_data(tickers, start_date, end_date):
    data = {}
    for ticker in tickers:
        stock_data = yf.download(ticker, start=start_date, end=end_date)
        data[ticker] = stock_data
    return data

# Example tickers (top 25)
tickers = ['AAPL', 'MSFT', 'TSLA', 'GOOGL', 'AMZN']
start_date = '2023-01-01'
end_date = '2023-06-30'  # adjust the end date based on available data

historical_stock_data = get_historical_data(tickers, start_date, end_date)

def run_backtest_simulation(historical_data, initial_balance, trade_amount, learning=False):
    balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    ai_insights = []

    # Example simulation over the data period
    for date, stock_data in historical_data['AAPL'].iterrows():
        # Simplified trading logic, implement your AI logic here
        rsi = stock_data['RSI'] if 'RSI' in stock_data else 50  # Example RSI

        if rsi < 30 and balance >= trade_amount:  # Buy condition
            balance -= trade_amount
            actions_taken['buy'] += 1
        elif rsi > 70:  # Sell condition
            balance += trade_amount
            actions_taken['sell'] += 1
        else:  # Hold condition
            actions_taken['hold'] += 1

        # Track balance daily
        daily_balances.append(balance)

        # AI learning insights (you can expand this logic)
        if learning:
            ai_insight = f"On {date}, AI learned to {'buy' if rsi < 30 else 'sell' if rsi > 70 else 'hold'} based on RSI {rsi}."
            ai_insights.append(ai_insight)

    return balance, daily_balances, actions_taken, ai_insights

# Running the backtest simulation
final_balance, daily_balances, actions_taken, ai_insights = run_backtest_simulation(
    historical_stock_data, initial_balance=200, trade_amount=5, learning=True
)

# Print results
print("Final Balance:", final_balance)
print("Daily Profits/Losses (First 10 Days):", daily_balances[:10])
print("Actions Taken:", actions_taken)
print("AI Learning Insights:", ai_insights[:5])  # Print the first 5 insights for clarity

def dynamic_rsi_strategy(historical_data, initial_balance, trade_amount):
    balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    ai_insights = []

    for date, stock_data in historical_data['AAPL'].iterrows():
        rsi = stock_data['RSI']

        # Check if RSI thresholds need to be dynamically adjusted based on past behavior
        if rsi < 35:  # Adjusted buy condition
            balance -= trade_amount
            actions_taken['buy'] += 1
            ai_insights.append(f"On {date}, AI bought based on RSI {rsi}.")
        elif rsi > 65:  # Adjusted sell condition
            balance += trade_amount
            actions_taken['sell'] += 1
            ai_insights.append(f"On {date}, AI sold based on RSI {rsi}.")
        else:
            actions_taken['hold'] += 1
            ai_insights.append(f"On {date}, AI held based on RSI {rsi}.")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken, ai_insights

def dynamic_rsi_strategy(historical_data, initial_balance, trade_amount):
    balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    ai_insights = []

    for date, stock_data in historical_data['AAPL'].iterrows():
        rsi = stock_data['RSI']

        # Adjust buy/sell thresholds dynamically over time
        if rsi < 35:  # Adjusted buy threshold
            balance -= trade_amount
            actions_taken['buy'] += 1
            ai_insights.append(f"On {date}, AI bought based on RSI {rsi}.")
        elif rsi > 65:  # Adjusted sell threshold
            balance += trade_amount
            actions_taken['sell'] += 1
            ai_insights.append(f"On {date}, AI sold based on RSI {rsi}.")
        else:
            actions_taken['hold'] += 1
            ai_insights.append(f"On {date}, AI held based on RSI {rsi}.")

        # Append the balance for each day
        daily_balances.append(balance)

    return balance, daily_balances, actions_taken, ai_insights

# Run the simulation for 6 months (or the available period)
final_balance, daily_balances, actions_taken, ai_insights = dynamic_rsi_strategy(historical_stock_data, initial_balance, trade_amount)

# Displaying the first 10 days for clarity
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")
print(f"AI Learning Insights: {ai_insights[:10]}")  # Showing the first 10 insights

import pandas as pd

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Dynamic RSI strategy implementation
def dynamic_rsi_strategy(historical_data, initial_balance, trade_amount):
    balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    ai_insights = []

    # Ensure RSI is calculated for each stock in the historical data
    for ticker, stock_data in historical_data.items():
        historical_data[ticker] = calculate_rsi(stock_data)  # Calculate RSI for each stock

    for date, stock_data in historical_data['AAPL'].iterrows():  # You can change 'AAPL' to loop through multiple stocks
        try:
            rsi = stock_data['RSI']
        except KeyError:
            # Skip the day if RSI can't be calculated
            ai_insights.append(f"RSI missing for {date}, skipping.")
            continue

        # Adjust buy/sell thresholds dynamically
        if rsi < 35:  # Buy when RSI is low
            balance -= trade_amount
            actions_taken['buy'] += 1
            ai_insights.append(f"On {date}, AI bought based on RSI {rsi}.")
        elif rsi > 65:  # Sell when RSI is high
            balance += trade_amount
            actions_taken['sell'] += 1
            ai_insights.append(f"On {date}, AI sold based on RSI {rsi}.")
        else:
            actions_taken['hold'] += 1
            ai_insights.append(f"On {date}, AI held based on RSI {rsi}.")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken, ai_insights

# Run the simulation for 6 months (or the available period)
final_balance, daily_balances, actions_taken, ai_insights = dynamic_rsi_strategy(historical_stock_data, initial_balance, trade_amount)

# Displaying the first 10 days for clarity
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")
print(f"AI Learning Insights: {ai_insights[:10]}")

import pandas as pd

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Dynamic RSI strategy implementation
def dynamic_rsi_strategy(historical_data, initial_balance, trade_amount):
    balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    ai_insights = []

    # Ensure RSI is calculated for each stock in the historical data
    for ticker, stock_data in historical_data.items():
        historical_data[ticker] = calculate_rsi(stock_data)  # Calculate RSI for each stock

    for date, stock_data in historical_data['AAPL'].iterrows():  # Loop through stock data (change ticker if needed)
        try:
            rsi = stock_data['RSI']
            if pd.isna(rsi):
                ai_insights.append(f"RSI not available for {date}, skipping this day.")
                continue
        except KeyError:
            # Skip the day if RSI can't be calculated
            ai_insights.append(f"RSI missing for {date}, skipping.")
            continue

        # Adjust buy/sell thresholds dynamically
        if rsi < 35:  # Buy when RSI is low
            balance -= trade_amount
            actions_taken['buy'] += 1
            ai_insights.append(f"On {date}, AI bought based on RSI {rsi}.")
        elif rsi > 65:  # Sell when RSI is high
            balance += trade_amount
            actions_taken['sell'] += 1
            ai_insights.append(f"On {date}, AI sold based on RSI {rsi}.")
        else:
            actions_taken['hold'] += 1
            ai_insights.append(f"On {date}, AI held based on RSI {rsi}.")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken, ai_insights

# Run the simulation for 6 months (or the available period)
final_balance, daily_balances, actions_taken, ai_insights = dynamic_rsi_strategy(historical_stock_data, initial_balance, trade_amount)

# Displaying the first 10 days for clarity
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")
print(f"AI Learning Insights: {ai_insights[:10]}")

import pandas as pd

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi
    return data

# Dynamic RSI strategy implementation
def dynamic_rsi_strategy(historical_data, initial_balance, trade_amount, rsi_window=14):
    balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    ai_insights = []

    # Ensure RSI is calculated for each stock in the historical data
    for ticker, stock_data in historical_data.items():
        historical_data[ticker] = calculate_rsi(stock_data, window=rsi_window)  # Calculate RSI for each stock

    for date, stock_data in historical_data['AAPL'].iterrows():  # Loop through stock data (change ticker if needed)
        try:
            rsi = stock_data['RSI']
            if pd.isna(rsi):
                ai_insights.append(f"RSI not available for {date}, skipping this day due to insufficient data.")
                continue
        except KeyError:
            # Skip the day if RSI can't be calculated
            ai_insights.append(f"RSI missing for {date}, skipping.")
            continue

        # Adjust buy/sell thresholds dynamically
        if rsi < 35:  # Buy when RSI is low
            balance -= trade_amount
            actions_taken['buy'] += 1
            ai_insights.append(f"On {date}, AI bought based on RSI {rsi}.")
        elif rsi > 65:  # Sell when RSI is high
            balance += trade_amount
            actions_taken['sell'] += 1
            ai_insights.append(f"On {date}, AI sold based on RSI {rsi}.")
        else:
            actions_taken['hold'] += 1
            ai_insights.append(f"On {date}, AI held based on RSI {rsi}.")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken, ai_insights

# Adjust the start date to allow for RSI calculation
start_date = '2022-12-01'  # Start date to ensure enough data for RSI
end_date = '2023-06-01'  # End date
rsi_window = 14  # RSI period

# Run the simulation for 6 months (or the available period)
final_balance, daily_balances, actions_taken, ai_insights = dynamic_rsi_strategy(historical_stock_data, initial_balance, trade_amount, rsi_window)

# Displaying the first 10 days for clarity
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")
print(f"AI Learning Insights: {ai_insights[:10]}")

# Modified Strategy to handle missing RSI gracefully
def dynamic_rsi_strategy(historical_data, initial_balance, trade_amount, rsi_window=14):
    balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    ai_insights = []

    # Ensure RSI is calculated for each stock in the historical data
    for ticker, stock_data in historical_data.items():
        historical_data[ticker] = calculate_rsi(stock_data, window=rsi_window)  # Calculate RSI for each stock

    for date, stock_data in historical_data['AAPL'].iterrows():  # Loop through stock data (change ticker if needed)
        try:
            rsi = stock_data['RSI']
            if pd.isna(rsi):
                ai_insights.append(f"RSI not available for {date}, skipping this day due to insufficient data.")
                continue
        except KeyError:
            # Skip the day if RSI can't be calculated
            ai_insights.append(f"RSI missing for {date}, skipping.")
            continue

        # Adjust buy/sell thresholds dynamically
        if rsi < 35:  # Buy when RSI is low
            balance -= trade_amount
            actions_taken['buy'] += 1
            ai_insights.append(f"On {date}, AI bought based on RSI {rsi}.")
        elif rsi > 65:  # Sell when RSI is high
            balance += trade_amount
            actions_taken['sell'] += 1
            ai_insights.append(f"On {date}, AI sold based on RSI {rsi}.")
        else:
            actions_taken['hold'] += 1
            ai_insights.append(f"On {date}, AI held based on RSI {rsi}.")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken, ai_insights

# Ensure that the start date allows enough data for RSI calculation
start_date = '2022-12-01'  # Ensure enough data for RSI
end_date = '2023-06-01'  # End date
rsi_window = 14  # RSI period

# Run the simulation with fallback for 6 months or available period
final_balance, daily_balances, actions_taken, ai_insights = dynamic_rsi_strategy(historical_stock_data, initial_balance, trade_amount, rsi_window)

# Displaying the first 10 days for clarity
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")
print(f"AI Learning Insights: {ai_insights[:10]}")

# Define function to check for Bollinger Bands signals
def check_bollinger_signals(data, current_day):
    if data['Close'][current_day] < data['Bollinger_Lower'][current_day]:
        return 'buy'
    elif data['Close'][current_day] > data['Bollinger_Upper'][current_day]:
        return 'sell'
    return 'hold'

# Update the main simulation loop
for current_day in range(len(stock_data)):
    # Existing logic...

    # Get the action based on Bollinger Bands
    bollinger_action = check_bollinger_signals(stock_data, current_day)

    if bollinger_action == 'buy':
        # Execute buy logic
    elif bollinger_action == 'sell':
        # Execute sell logic
    else:
        # Hold logic

    # Store AI learning insights

# Define function to check for Bollinger Bands signals
def check_bollinger_signals(data, current_day):
    if data['Close'][current_day] < data['Bollinger_Lower'][current_day]:
        return 'buy'
    elif data['Close'][current_day] > data['Bollinger_Upper'][current_day]:
        return 'sell'
    return 'hold'

# Update the main simulation loop
for current_day in range(len(stock_data)):
    # Existing logic...

    # Get the action based on Bollinger Bands
    bollinger_action = check_bollinger_signals(stock_data, current_day)

    if bollinger_action == 'buy':
        # Execute buy logic
        pass  # Replace with your buy execution code
    elif bollinger_action == 'sell':
        # Execute sell logic
        pass  # Replace with your sell execution code
    else:
        # Hold logic
        pass  # Replace with your hold logic

    # Store AI learning insights

print(stock_data.columns)

print(stock_data.keys())

# Assuming you want to check the DataFrame for a specific stock, e.g., 'AAPL'
stock_symbol = 'AAPL'  # Replace with the desired stock symbol
if stock_symbol in stock_data:
    print(stock_data[stock_symbol].columns)  # Print columns for the specified stock
else:
    print(f"{stock_symbol} not found in stock_data.")

# Define function to check for Bollinger Bands signals
def check_bollinger_signals(data):
    # Assuming 'data' is a DataFrame for a specific stock
    current_day = data.index[-1]  # Get the latest day available in the DataFrame
    if data['Close'][current_day] < data['Bollinger_Lower'][current_day]:
        return 'buy'
    elif data['Close'][current_day] > data['Bollinger_Upper'][current_day]:
        return 'sell'
    return 'hold'

# Update the main simulation loop
for stock_symbol, stock_df in stock_data.items():
    # Get the action based on Bollinger Bands for this specific stock
    bollinger_action = check_bollinger_signals(stock_df)

    if bollinger_action == 'buy':
        # Execute buy logic
        pass  # Replace with your buy execution code
    elif bollinger_action == 'sell':
        # Execute sell logic
        pass  # Replace with your sell execution code
    else:
        # Hold logic
        pass  # Replace with your hold logic

    # Store AI learning insights

# Print the structure of stock_data to understand its contents
print(type(stock_data))
for key in stock_data.keys():
    print(f"Key: {key}, Data: {stock_data[key].head()}")

# Define function to check for Bollinger Bands signals
def check_bollinger_signals(data, current_day):
    # Ensure the current day exists in the data
    if current_day in data.index:
        close_price = data['Close'][current_day]
        lower_band = data['Bollinger_Lower'][current_day]
        upper_band = data['Bollinger_Upper'][current_day]

        if close_price < lower_band:
            return 'buy'
        elif close_price > upper_band:
            return 'sell'
    return 'hold'  # Default action

# Update your main trading simulation logic
def run_simulation(stock_data):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    # Iterate through the days
    for current_day in stock_data.index:
        # Get the action based on Bollinger Bands
        bollinger_action = check_bollinger_signals(stock_data, current_day)

        if bollinger_action == 'buy':
            # Implement buy logic here
            actions_taken['buy'] += 1
        elif bollinger_action == 'sell':
            # Implement sell logic here
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        # Record daily balance (this should include your balance logic)
        daily_balances.append(current_balance)  # Replace current_balance with your actual balance variable

    return daily_balances, actions_taken

# Assuming stock_data is a DataFrame with a DateTime index
daily_balances, actions_taken = run_simulation(stock_data)

# Displaying the results
print(f"Daily Balances: {daily_balances[:10]}")  # First 10 days
print(f"Actions Taken: {actions_taken}")

import pandas as pd

# Assuming stock_data is a dictionary of DataFrames for each stock
# You might want to concatenate them into a single DataFrame if they share the same structure
stock_data_df = pd.concat(stock_data.values(), keys=stock_data.keys())

# Reset the index to make the date a column
stock_data_df.reset_index(inplace=True)
stock_data_df.rename(columns={'level_0': 'Stock', 'level_1': 'Date'}, inplace=True)

# Set the Date as the index if needed
stock_data_df.set_index('Date', inplace=True)

# Now you can access the DataFrame's index
print(stock_data_df.head())  # Check the first few rows

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through the days
    for current_day in stock_data_df.index.unique():
        daily_data = stock_data_df.loc[current_day]

        # Get the action based on Bollinger Bands for each stock
        for stock in daily_data['Stock'].unique():
            stock_subset = daily_data[daily_data['Stock'] == stock]
            bollinger_action = check_bollinger_signals(stock_subset, current_day)

            if bollinger_action == 'buy':
                # Implement buy logic here
                actions_taken['buy'] += 1
            elif bollinger_action == 'sell':
                # Implement sell logic here
                actions_taken['sell'] += 1
            else:
                actions_taken['hold'] += 1

        # Record daily balance (this should include your balance logic)
        daily_balances.append(current_balance)  # Replace current_balance with your actual balance variable

    return daily_balances, actions_taken

# Assuming stock_data_df is now a properly formatted DataFrame
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Daily Balances: {daily_balances[:10]}")  # First 10 days
print(f"Actions Taken: {actions_taken}")

def calculate_bollinger_bands(df, window=20, num_std_dev=2):
    df['Bollinger_Middle'] = df['Close'].rolling(window).mean()
    df['Bollinger_Upper'] = df['Bollinger_Middle'] + (df['Close'].rolling(window).std() * num_std_dev)
    df['Bollinger_Lower'] = df['Bollinger_Middle'] - (df['Close'].rolling(window).std() * num_std_dev)
    return df

# Assuming stock_data_df is a DataFrame that includes 'Close' prices
stock_data_df = calculate_bollinger_bands(stock_data_df)

# Check the first few rows to ensure the bands were calculated
print(stock_data_df[['Close', 'Bollinger_Upper', 'Bollinger_Lower']].head())

def check_bollinger_signals(data, current_day):
    # Check if the current_day has Bollinger Bands data
    if 'Bollinger_Lower' not in data.columns or 'Bollinger_Upper' not in data.columns:
        return 'hold'  # Default to holding if Bollinger Bands data is missing

    if data['Close'].iloc[-1] < data['Bollinger_Lower'].iloc[-1]:
        return 'buy'
    elif data['Close'].iloc[-1] > data['Bollinger_Upper'].iloc[-1]:
        return 'sell'
    else:
        return 'hold'

# Assuming stock_data_df is now a properly formatted DataFrame with Bollinger Bands
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Daily Balances: {daily_balances[:10]}")  # First 10 days
print(f"Actions Taken: {actions_taken}")

# Check the type and structure of stock_data_df
print(type(stock_data_df))  # Should be a DataFrame
print(stock_data_df.head())  # Display first few rows

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    # Iterate through each day in the DataFrame
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # If daily_data is a Series, ensure it's treated as a DataFrame
        if isinstance(daily_data, pd.Series):
            daily_data = daily_data.to_frame().T  # Convert Series to DataFrame

        # Get the action based on Bollinger Bands for each stock
        for stock in daily_data['Stock'].unique():
            stock_subset = daily_data[daily_data['Stock'] == stock]
            bollinger_action = check_bollinger_signals(stock_subset, current_day)

            # Implement your logic for buy/sell/hold here
            if bollinger_action == 'buy':
                # Update balance for buy action
                actions_taken['buy'] += 1
            elif bollinger_action == 'sell':
                # Update balance for sell action
                actions_taken['sell'] += 1
            else:
                actions_taken['hold'] += 1

        # Calculate the daily balance and append it
        # You need to implement your logic to calculate the daily balance here
        daily_balances.append(current_balance)  # Replace `current_balance` with your logic

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Daily Balances: {daily_balances[:10]}")  # First 10 days
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df, initial_balance):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = initial_balance  # Initialize current balance with initial balance

    # Iterate through each day in the DataFrame
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # If daily_data is a Series, ensure it's treated as a DataFrame
        if isinstance(daily_data, pd.Series):
            daily_data = daily_data.to_frame().T  # Convert Series to DataFrame

        # Get the action based on Bollinger Bands for each stock
        for stock in daily_data['Stock'].unique():
            stock_subset = daily_data[daily_data['Stock'] == stock]
            bollinger_action = check_bollinger_signals(stock_subset, current_day)

            # Implement your logic for buy/sell/hold here
            if bollinger_action == 'buy':
                # Assume a fixed trade amount; adjust current_balance accordingly
                trade_amount = 5  # Example trade amount
                current_balance += trade_amount  # Adjust for the buy action
                actions_taken['buy'] += 1
            elif bollinger_action == 'sell':
                # Assume you sell a stock; adjust current_balance accordingly
                trade_amount = 5  # Example trade amount
                current_balance += trade_amount  # Adjust for the sell action
                actions_taken['sell'] += 1
            else:
                actions_taken['hold'] += 1

        # Append the current balance to daily_balances
        daily_balances.append(current_balance)

    return daily_balances, actions_taken

initial_balance = 200  # Set your initial balance
daily_balances, actions_taken = run_simulation(stock_data_df, initial_balance)

# Displaying the results
print(f"Daily Balances: {daily_balances[:10]}")  # First 10 days
print(f"Actions Taken: {actions_taken}")

def check_bollinger_signals(data, current_day):
    if data['Close'][current_day] < data['Bollinger_Lower'][current_day]:
        return 'buy'
    elif data['Close'][current_day] > data['Bollinger_Upper'][current_day]:
        return 'sell'
    else:
        return 'hold'

print(stock_data_df.loc[current_day])  # Check the data for the current day

print(f"Date: {current_day}, Close Price: {daily_data['Close']}, Action: {bollinger_action}")

def run_simulation(stock_data_df):
    current_balance = 200  # Initial balance
    daily_balances = []  # List to store daily balances
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}  # Initialize action counters

    # Iterate through each day in the stock data
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Initialize a flag for actions taken on this day
        action_today = {'buy': 0, 'sell': 0, 'hold': 0}

        # Iterate through unique stocks for that day
        for stock in daily_data['Stock'].unique():
            stock_subset = daily_data[daily_data['Stock'] == stock]
            bollinger_action = check_bollinger_signals(stock_subset, current_day)

            # Debug print to check stock data and action
            print(f"Date: {current_day}, Stock: {stock}, Close Price: {stock_subset['Close'].values[0]}, "
                  f"Bollinger Lower: {stock_subset['Bollinger_Lower'].values[0]}, "
                  f"Bollinger Upper: {stock_subset['Bollinger_Upper'].values[0]}, "
                  f"Action: {bollinger_action}")

            # Execute the action based on Bollinger Bands signal
            if bollinger_action == 'buy':
                current_balance += 5  # Simulate buying
                action_today['buy'] += 1
            elif bollinger_action == 'sell':
                current_balance -= 5  # Simulate selling
                action_today['sell'] += 1
            else:
                action_today['hold'] += 1

        # Update actions taken
        actions_taken['buy'] += action_today['buy']
        actions_taken['sell'] += action_today['sell']
        actions_taken['hold'] += action_today['hold']

        # Append current balance to daily balances
        daily_balances.append(current_balance)

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

print(stock_data_df.head())  # Check the first few rows of the DataFrame

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Initial balance

    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if the daily data contains valid close price and signals
        if pd.isna(daily_data['Close']).any():
            print(f"Skipping {current_day} due to NaN values in Close.")
            continue

        # Iterate through each stock's daily data
        for stock in daily_data.index:
            close_price = daily_data['Close'][stock]
            bollinger_action = check_bollinger_signals(stock_data_df, current_day)

            if bollinger_action == 'buy':
                current_balance += close_price  # Simplified logic for demonstration
                actions_taken['buy'] += 1
            elif bollinger_action == 'sell':
                current_balance -= close_price  # Simplified logic for demonstration
                actions_taken['sell'] += 1
            else:
                actions_taken['hold'] += 1

        # Append the current balance to the daily balances list
        daily_balances.append(current_balance)

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through each day in the DataFrame
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check for NaN values in the Close prices
        if pd.isna(daily_data['Close']).any():
            print(f"Skipping {current_day} due to NaN values in Close.")
            continue

        # Calculate the Bollinger Bands and other indicators if not present
        bollinger_action = check_bollinger_signals(daily_data)

        # Perform action based on Bollinger Bands
        if bollinger_action == 'buy':
            # Execute buy logic
            actions_taken['buy'] += 1
            current_balance += 5  # Adjust balance for buying logic
        elif bollinger_action == 'sell':
            # Execute sell logic
            actions_taken['sell'] += 1
            current_balance -= 5  # Adjust balance for selling logic
        else:
            actions_taken['hold'] += 1  # Increment hold action count

        # Append current balance to daily_balances
        daily_balances.append(current_balance)

        # Log the results
        print(f"Date: {current_day}, Close Price: {daily_data['Close']}, Action: {bollinger_action}")

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through each day in the DataFrame
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if the Close price is NaN
        if pd.isna(daily_data['Close']):
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Calculate the Bollinger Bands and other indicators if not present
        bollinger_action = check_bollinger_signals(daily_data)

        # Perform action based on Bollinger Bands
        if bollinger_action == 'buy':
            # Execute buy logic
            actions_taken['buy'] += 1
            current_balance += 5  # Adjust balance for buying logic
        elif bollinger_action == 'sell':
            # Execute sell logic
            actions_taken['sell'] += 1
            current_balance -= 5  # Adjust balance for selling logic
        else:
            actions_taken['hold'] += 1  # Increment hold action count

        # Append current balance to daily_balances
        daily_balances.append(current_balance)

        # Log the results
        print(f"Date: {current_day}, Close Price: {daily_data['Close']}, Action: {bollinger_action}")

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through each day in the DataFrame
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if the Close price is NaN
        if pd.isna(daily_data['Close']):
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Get the action based on Bollinger Bands
        bollinger_action = check_bollinger_signals(daily_data)

        # Perform action based on Bollinger Bands
        if bollinger_action == 'buy':
            # Execute buy logic
            actions_taken['buy'] += 1
            current_balance += 5  # Adjust balance for buying logic
        elif bollinger_action == 'sell':
            # Execute sell logic
            actions_taken['sell'] += 1
            current_balance -= 5  # Adjust balance for selling logic
        else:
            actions_taken['hold'] += 1  # Increment hold action count

        # Append current balance to daily_balances
        daily_balances.append(current_balance)

        # Log the results
        print(f"Date: {current_day}, Close Price: {daily_data['Close']}, Action: {bollinger_action}")

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through each day in the DataFrame
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if the Close price is NaN
        if pd.isna(daily_data['Close']):
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Get the action based on Bollinger Bands
        bollinger_action = check_bollinger_signals(daily_data)

        # Perform action based on Bollinger Bands
        if bollinger_action == 'buy':
            # Execute buy logic
            actions_taken['buy'] += 1
            current_balance += 5  # Adjust balance for buying logic
        elif bollinger_action == 'sell':
            # Execute sell logic
            actions_taken['sell'] += 1
            current_balance -= 5  # Adjust balance for selling logic
        else:
            actions_taken['hold'] += 1  # Increment hold action count

        # Append current balance to daily_balances
        daily_balances.append(current_balance)

        # Log the results
        print(f"Date: {current_day}, Close Price: {daily_data['Close']}, Action: {bollinger_action}")

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through each day in the DataFrame
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if the Close price is NaN
        if pd.isna(daily_data['Close']).any():
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Get the action based on Bollinger Bands
        bollinger_action = check_bollinger_signals(daily_data)

        # Perform action based on Bollinger Bands
        if bollinger_action == 'buy':
            actions_taken['buy'] += 1
            current_balance += 5  # Example logic for a buy
        elif bollinger_action == 'sell':
            actions_taken['sell'] += 1
            current_balance -= 5  # Example logic for a sell
        else:
            actions_taken['hold'] += 1  # Increment hold action count

        # Append current balance to daily_balances
        daily_balances.append(current_balance)

        # Log the results
        print(f"Date: {current_day}, Close Price: {daily_data['Close']}, Action: {bollinger_action}")

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through each day in the DataFrame
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if the Close price is NaN
        if pd.isna(daily_data['Close']):
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Get the action based on Bollinger Bands
        bollinger_action = check_bollinger_signals(daily_data)

        # Perform action based on Bollinger Bands
        if bollinger_action == 'buy':
            actions_taken['buy'] += 1
            current_balance += 5  # Example logic for a buy
        elif bollinger_action == 'sell':
            actions_taken['sell'] += 1
            current_balance -= 5  # Example logic for a sell
        else:
            actions_taken['hold'] += 1  # Increment hold action count

        # Append current balance to daily_balances
        daily_balances.append(current_balance)

        # Log the results
        print(f"Date: {current_day}, Close Price: {daily_data['Close']}, Action: {bollinger_action}")

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through each day in the DataFrame
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if the Close price is NaN
        if pd.isna(daily_data['Close']):
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Get the action based on Bollinger Bands for a single stock
        bollinger_action = check_bollinger_signals(daily_data)

        # Perform action based on Bollinger Bands
        if bollinger_action == 'buy':
            actions_taken['buy'] += 1
            current_balance += 5  # Example logic for a buy
        elif bollinger_action == 'sell':
            actions_taken['sell'] += 1
            current_balance -= 5  # Example logic for a sell
        else:
            actions_taken['hold'] += 1  # Increment hold action count

        # Append current balance to daily_balances
        daily_balances.append(current_balance)

        # Log the results
        print(f"Date: {current_day}, Close Price: {daily_data['Close']}, Action: {bollinger_action}")

    return daily_balances, actions_taken

def check_bollinger_signals(daily_data):
    if daily_data['Close'] < daily_data['Bollinger_Lower']:
        return 'buy'
    elif daily_data['Close'] > daily_data['Bollinger_Upper']:
        return 'sell'
    else:
        return 'hold'

# Run the simulation
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = initial_balance  # Set your initial balance here

    # Iterate through each day in your stock data
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if Close price is NaN
        if pd.isna(daily_data['Close']).any():
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Additional checks for other indicators
        if pd.isna(daily_data['Bollinger_Lower']).any() or pd.isna(daily_data['Bollinger_Upper']).any():
            print(f"Skipping {current_day} due to NaN values in Bollinger Bands.")
            continue

        # Your existing logic for trading actions based on Bollinger Bands, RSI, etc.
        # Example:
        bollinger_action = check_bollinger_signals(daily_data)

        if bollinger_action == 'buy':
            current_balance += trade_amount  # Implement your buying logic
            actions_taken['buy'] += 1
        elif bollinger_action == 'sell':
            current_balance -= trade_amount  # Implement your selling logic
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        # Append current balance to daily_balances
        daily_balances.append(current_balance)

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through each day in the stock data
    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check for NaN values in the Close price
        if pd.isna(daily_data['Close']).any():
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Assume you have a function that checks signals
        bollinger_action = check_bollinger_signals(daily_data, current_day)

        if bollinger_action == 'buy':
            # Implement buy logic
            actions_taken['buy'] += 1
        elif bollinger_action == 'sell':
            # Implement sell logic
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        # Log the balance for the day
        daily_balances.append(current_balance)

    return daily_balances, actions_taken

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = initial_balance  # Replace with your initial balance

    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if Close price is NaN
        if pd.isna(daily_data['Close']).any():
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Get Bollinger Bands signals
        bollinger_action = check_bollinger_signals(daily_data)

        # Record action taken
        if bollinger_action == 'buy':
            current_balance += trade_amount  # Implement your buy logic here
            actions_taken['buy'] += 1
        elif bollinger_action == 'sell':
            current_balance -= trade_amount  # Implement your sell logic here
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        daily_balances.append(current_balance)

    return daily_balances, actions_taken

# Run the simulation
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = initial_balance  # Replace with your initial balance

    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if Close price is NaN
        if pd.isna(daily_data['Close']):
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Get Bollinger Bands signals
        bollinger_action = check_bollinger_signals(daily_data)

        # Record action taken
        if bollinger_action == 'buy':
            current_balance += trade_amount  # Implement your buy logic here
            actions_taken['buy'] += 1
        elif bollinger_action == 'sell':
            current_balance -= trade_amount  # Implement your sell logic here
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        daily_balances.append(current_balance)

    return daily_balances, actions_taken

# Run the simulation
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = initial_balance  # Replace with your initial balance

    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if Close price is NaN
        if pd.isna(daily_data['Close']):
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Get Bollinger Bands signals
        bollinger_action = check_bollinger_signals(daily_data)

        # Record action taken
        if bollinger_action == 'buy':
            current_balance += trade_amount  # Implement your buy logic here
            actions_taken['buy'] += 1
        elif bollinger_action == 'sell':
            current_balance -= trade_amount  # Implement your sell logic here
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        daily_balances.append(current_balance)

    return daily_balances, actions_taken

# Run the simulation
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = initial_balance  # Replace with your initial balance

    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if Close price is NaN
        if pd.isna(daily_data['Close']):
            print(f"Skipping {current_day} due to NaN value in Close.")
            continue

        # Get Bollinger Bands signals
        bollinger_action = check_bollinger_signals(daily_data)

        # Record action taken
        if bollinger_action == 'buy':
            current_balance += trade_amount  # Implement your buy logic here
            actions_taken['buy'] += 1
        elif bollinger_action == 'sell':
            current_balance -= trade_amount  # Implement your sell logic here
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        daily_balances.append(current_balance)

    return daily_balances, actions_taken

# Run the simulation
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data_df):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = initial_balance  # Replace with your initial balance

    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Check if the daily_data is a Series
        if isinstance(daily_data, pd.Series):
            # Check if Close price is NaN
            if pd.isna(daily_data['Close']):
                print(f"Skipping {current_day} due to NaN value in Close.")
                continue

            # Get Bollinger Bands signals
            bollinger_action = check_bollinger_signals(daily_data)

            # Record action taken
            if bollinger_action == 'buy':
                current_balance += trade_amount  # Implement your buy logic here
                actions_taken['buy'] += 1
            elif bollinger_action == 'sell':
                current_balance -= trade_amount  # Implement your sell logic here
                actions_taken['sell'] += 1
            else:
                actions_taken['hold'] += 1

            daily_balances.append(current_balance)
        else:
            print(f"Unexpected data format for {current_day}.")

    return daily_balances, actions_taken

# Run the simulation
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1]}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Check the structure of stock_data_df before running the simulation
print(stock_data_df.head())  # Display the first few rows of the DataFrame
print(stock_data_df.columns)  # Print the columns to see if 'Close', 'RSI', and 'MACD' are present

# Run the simulation
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10] if daily_balances else []}")
print(f"Actions Taken: {actions_taken}")

# Resetting the index to handle the misalignment
stock_data_df.reset_index(drop=True, inplace=True)

# Renaming columns for clarity
stock_data_df.columns = ['Date', 'Stock', 'Close', 'RSI', 'MACD', 'Bollinger_Middle', 'Bollinger_Upper', 'Bollinger_Lower']

# Converting the 'Date' column to datetime
stock_data_df['Date'] = pd.to_datetime(stock_data_df['Date'])

# Set 'Date' as the index
stock_data_df.set_index('Date', inplace=True)

# Check the cleaned DataFrame
print(stock_data_df.head())  # Display the first few rows after cleaning
print(stock_data_df.columns)  # Verify the column names

# Now, run the simulation again
daily_balances, actions_taken = run_simulation(stock_data_df)

# Displaying the results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10] if daily_balances else []}")
print(f"Actions Taken: {actions_taken}")

import pandas as pd

# Sample data creation for demonstration
data = {
    'Date': ['2023-01-01', '2023-01-01', '2023-01-01', '2023-01-02', '2023-01-02'],
    'Stock': ['AAPL', 'AAPL', 'AAPL', 'AAPL', 'AAPL'],
    'Close': [150.0, None, 0.5, None, 205.0],
    'RSI': [None, 35.0, None, 155.0, 65.0],
    'MACD': [None, None, None, 0.3, -0.4],
    'Bollinger_Middle': [None, None, None, None, None],
    'Bollinger_Upper': [None, None, None, None, None],
    'Bollinger_Lower': [None, None, None, None, None]
}

# Create a DataFrame
stock_data_df = pd.DataFrame(data)

# Ensure 'Date' column is in datetime format
stock_data_df['Date'] = pd.to_datetime(stock_data_df['Date'])

# Group by 'Date' and aggregate data into a single row per date
# Replace NaNs in 'Close', 'RSI', 'MACD', etc. with actual data as needed
stock_data_cleaned = stock_data_df.groupby('Date').agg({
    'Stock': 'first',  # Just taking the first occurrence
    'Close': 'last',   # Taking the last value (could also be mean or other)
    'RSI': 'last',
    'MACD': 'last',
    'Bollinger_Middle': 'last',
    'Bollinger_Upper': 'last',
    'Bollinger_Lower': 'last'
}).reset_index()

# Drop any rows that are completely NaN in critical columns
stock_data_cleaned.dropna(subset=['Close', 'RSI', 'MACD'], inplace=True)

# Set the date as the index for easier access
stock_data_cleaned.set_index('Date', inplace=True)

# Display the cleaned DataFrame
print(stock_data_cleaned)

# Now run the simulation again
daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Displaying the results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10] if daily_balances else []}")
print(f"Actions Taken: {actions_taken}")

def check_bollinger_signals(daily_data):
    # Ensure we have necessary data to make a decision
    if pd.isna(daily_data['Close']).any() or pd.isna(daily_data['Bollinger_Lower']).any() or pd.isna(daily_data['Bollinger_Upper']).any():
        return 'hold'  # If any required values are NaN, hold

    # Now we can safely compare
    if daily_data['Close'].iloc[-1] < daily_data['Bollinger_Lower'].iloc[-1]:  # Using iloc to get the last value
        return 'buy'
    elif daily_data['Close'].iloc[-1] > daily_data['Bollinger_Upper'].iloc[-1]:
        return 'sell'
    else:
        return 'hold'

# Now run the simulation again with the cleaned data
daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Displaying the results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10] if daily_balances else []}")
print(f"Actions Taken: {actions_taken}")

print(stock_data_cleaned.head())

def check_bollinger_signals(daily_data):
    # Check for NaN values and return 'hold' if any are found
    if daily_data[['Close', 'Bollinger_Lower', 'Bollinger_Upper']].isna().any().any():
        print("NaN values found in data, holding position.")
        return 'hold'  # If any required values are NaN, hold

    # Use the last available values for decision-making
    close_price = daily_data['Close'].iloc[-1]
    bollinger_lower = daily_data['Bollinger_Lower'].iloc[-1]
    bollinger_upper = daily_data['Bollinger_Upper'].iloc[-1]

    if close_price < bollinger_lower:
        return 'buy'
    elif close_price > bollinger_upper:
        return 'sell'
    else:
        return 'hold'

# Run the simulation
daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Displaying the results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10] if daily_balances else []}")
print(f"Actions Taken: {actions_taken}")

print(stock_data_cleaned.isna().sum())
print(stock_data_cleaned.head(10))  # Display the first 10 rows for context

# Inspect for NaN values in the cleaned stock data
print(stock_data_cleaned.isna().sum())  # Count of NaN values for each column
print(stock_data_cleaned.head(10))       # Display the first 10 rows of the DataFrame

# Check for NaN values in the cleaned stock data
print("Checking for NaN values in stock data:")
print(stock_data_cleaned.isna().sum())

# Display the first few rows of the cleaned data for inspection
print("\nInspecting the first few rows of the cleaned stock data:")
print(stock_data_cleaned.head())

def check_bollinger_signals(daily_data):
    # Ensure we have necessary data to make a decision
    if pd.isna(daily_data['Close']).any() or \
       pd.isna(daily_data['Bollinger_Lower']).any() or \
       pd.isna(daily_data['Bollinger_Upper']).any():
        return 'hold'  # If any required values are NaN, hold

    # Decision-making logic for Bollinger Bands
    if daily_data['Close'].iloc[-1] < daily_data['Bollinger_Lower'].iloc[-1]:
        return 'buy'
    elif daily_data['Close'].iloc[-1] > daily_data['Bollinger_Upper'].iloc[-1]:
        return 'sell'
    else:
        return 'hold'

# Run the simulation again with the cleaned data
daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Displaying the results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def check_bollinger_signals(daily_data):
    # Ensure we have necessary data to make a decision
    if pd.isna(daily_data['Close']) or \
       pd.isna(daily_data['Bollinger_Lower']) or \
       pd.isna(daily_data['Bollinger_Upper']):
        return 'hold'  # If any required values are NaN, hold

    if daily_data['Close'] < daily_data['Bollinger_Lower']:
        return 'buy'
    elif daily_data['Close'] > daily_data['Bollinger_Upper']:
        return 'sell'
    else:
        return 'hold'

# Run the simulation again with the cleaned data
daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Displaying the results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

print(stock_data_cleaned.isna().sum())
print(stock_data_cleaned.head())  # Display the first few rows of the cleaned data

print(f"Date: {current_day}, Close Price: {daily_data['Close']}, "
      f"Bollinger Lower: {daily_data['Bollinger_Lower']}, "
      f"Bollinger Upper: {daily_data['Bollinger_Upper']}, Action: {bollinger_action}")

def run_simulation(stock_data):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    current_balance = 200  # Initial balance

    # Iterate through the days in the stock data
    for current_day in stock_data.index:
        daily_data = stock_data.loc[current_day]

        # Print debugging information for each day
        print(f"Date: {current_day}, Close Price: {daily_data['Close']}, "
              f"Bollinger Lower: {daily_data['Bollinger_Lower']}, "
              f"Bollinger Upper: {daily_data['Bollinger_Upper']}")

        # Ensure we have valid data before making decisions
        if pd.isna(daily_data['Close']) or pd.isna(daily_data['Bollinger_Lower']) or pd.isna(daily_data['Bollinger_Upper']):
            print(f"Skipping {current_day} due to NaN values in required fields.")
            actions_taken['hold'] += 1
            daily_balances.append(current_balance)
            continue

        # Existing trading logic goes here...

    return daily_balances, actions_taken

print(stock_data_cleaned.isna().sum())
print(stock_data_cleaned.head())

daily_balances, actions_taken = run_simulation(stock_data_cleaned)

def run_simulation(stock_data):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    current_balance = 200  # Initial balance

    # Iterate through the days in the stock data
    for current_day in stock_data.index:
        daily_data = stock_data.loc[current_day]

        # Debugging output for daily data
        print(f"Date: {current_day}, Close Price: {daily_data['Close']}, "
              f"Bollinger Lower: {daily_data['Bollinger_Lower']}, "
              f"Bollinger Upper: {daily_data['Bollinger_Upper']}")

        # Check for NaN values
        if pd.isna(daily_data['Close']) or pd.isna(daily_data['Bollinger_Lower']) or pd.isna(daily_data['Bollinger_Upper']):
            print(f"Skipping {current_day} due to NaN values in required fields.")
            actions_taken['hold'] += 1
            daily_balances.append(current_balance)
            continue

        # Bollinger Band trading logic
        if daily_data['Close'] < daily_data['Bollinger_Lower']:
            # Buy signal
            print(f"Buying on {current_day}")
            current_balance += daily_data['Close']  # Example of updating balance
            actions_taken['buy'] += 1
        elif daily_data['Close'] > daily_data['Bollinger_Upper']:
            # Sell signal
            print(f"Selling on {current_day}")
            current_balance -= daily_data['Close']  # Example of updating balance
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        # Record the balance at the end of the day
        daily_balances.append(current_balance)

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_cleaned)

def calculate_bollinger_bands(data, window=20, num_std=2):
    """ Calculate Bollinger Bands. """
    # Ensure the data is sorted by date
    data = data.sort_index()

    # Calculate the moving average and standard deviation
    rolling_mean = data['Close'].rolling(window=window).mean()
    rolling_std = data['Close'].rolling(window=window).std()

    # Calculate Bollinger Bands
    data['Bollinger_Middle'] = rolling_mean
    data['Bollinger_Upper'] = rolling_mean + (rolling_std * num_std)
    data['Bollinger_Lower'] = rolling_mean - (rolling_std * num_std)

    return data

if pd.isna(daily_data['Bollinger_Lower']) or pd.isna(daily_data['Bollinger_Upper']):
    print(f"Bollinger Bands not available for {current_day}, holding position.")
    actions_taken['hold'] += 1
    daily_balances.append(current_balance)
    continue

def run_simulation(stock_data):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through the days of stock data
    for current_day in stock_data.index:
        daily_data = stock_data.loc[current_day]

        # Check for NaN values in Bollinger Bands
        if pd.isna(daily_data['Bollinger_Lower']) or pd.isna(daily_data['Bollinger_Upper']):
            print(f"Bollinger Bands not available for {current_day}, holding position.")
            actions_taken['hold'] += 1
            daily_balances.append(current_balance)
            continue  # Move to the next iteration of the loop

        # Assuming you have logic to determine actions based on the Bollinger Bands
        if daily_data['Close'] < daily_data['Bollinger_Lower']:
            # Buy logic
            actions_taken['buy'] += 1
            current_balance += 5  # Example buy logic
        elif daily_data['Close'] > daily_data['Bollinger_Upper']:
            # Sell logic
            actions_taken['sell'] += 1
            current_balance -= 5  # Example sell logic

        # Append the updated balance to daily_balances
        daily_balances.append(current_balance)

    return daily_balances, actions_taken

daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Sample Bollinger Bands calculation
def calculate_bollinger_bands(data, window=20, num_std_dev=2):
    rolling_mean = data['Close'].rolling(window=window).mean()
    rolling_std = data['Close'].rolling(window=window).std()

    data['Bollinger_Middle'] = rolling_mean
    data['Bollinger_Upper'] = rolling_mean + (rolling_std * num_std_dev)
    data['Bollinger_Lower'] = rolling_mean - (rolling_std * num_std_dev)
    return data

# Drop rows with NaN values in critical columns
stock_data_cleaned = stock_data.dropna(subset=['Close', 'Bollinger_Middle', 'Bollinger_Upper', 'Bollinger_Lower'])

import pandas as pd

# Assuming stock_data is a dictionary where keys are stock symbols and values are DataFrames
stock_data_list = []

for stock, data in stock_data.items():
    # Add a column to identify the stock
    data['Stock'] = stock
    stock_data_list.append(data)

# Concatenate all DataFrames into a single DataFrame
stock_data_df = pd.concat(stock_data_list, ignore_index=True)

# Drop rows with NaN values in critical columns
stock_data_cleaned = stock_data_df.dropna(subset=['Close', 'Bollinger_Middle', 'Bollinger_Upper', 'Bollinger_Lower'])

print(stock_data_df.columns)

print(stock_data_df.head())

stock_data_df.rename(columns={'Bollinger Middle': 'Bollinger_Middle',
                              'Bollinger Upper': 'Bollinger_Upper',
                              'Bollinger Lower': 'Bollinger_Lower'},
                     inplace=True)

stock_data_cleaned = stock_data_df.dropna(subset=['Close', 'Bollinger_Middle', 'Bollinger_Upper', 'Bollinger_Lower'])

print(stock_data_df.columns)

print(stock_data_df.head())

stock_data_df['Bollinger_Middle'] = stock_data_df['Close'].rolling(window=20).mean()
stock_data_df['Bollinger_Upper'] = stock_data_df['Bollinger_Middle'] + (stock_data_df['Close'].rolling(window=20).std() * 2)
stock_data_df['Bollinger_Lower'] = stock_data_df['Bollinger_Middle'] - (stock_data_df['Close'].rolling(window=20).std() * 2)

print(stock_data_df.columns)

stock_data_df['Bollinger_Middle'] = stock_data_df['Close'].rolling(window=20).mean()
stock_data_df['Bollinger_Upper'] = stock_data_df['Bollinger_Middle'] + (stock_data_df['Close'].rolling(window=20).std() * 2)
stock_data_df['Bollinger_Lower'] = stock_data_df['Bollinger_Middle'] - (stock_data_df['Close'].rolling(window=20).std() * 2)

stock_data_cleaned = stock_data_df.dropna(subset=['Close', 'Bollinger_Middle', 'Bollinger_Upper', 'Bollinger_Lower'])

daily_balances, actions_taken = run_simulation(stock_data_cleaned)

print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

print(stock_data_cleaned.head())  # Check the first few rows of cleaned data
print(stock_data_cleaned.info())   # Get a summary of the DataFrame, including non-null counts

print(stock_data_cleaned.columns)  # Display column names

print(stock_data_cleaned.isna().sum())  # Count of NaN values in each column

sample_data = stock_data_cleaned.head(5)
for index, row in sample_data.iterrows():
    print(check_bollinger_signals(row))  # Check the action for each row

# Step 1: Check cleaned data
print(stock_data_cleaned.head())
print(stock_data_cleaned.info())
print(stock_data_cleaned.isna().sum())

# Step 2: Run a simple test on a few rows
sample_data = stock_data_cleaned.head(5)
for index, row in sample_data.iterrows():
    print(f"Date: {index}, Close: {row['Close']}, Action: {check_bollinger_signals(row)}")

print(stock_data_df.head())

print(stock_data_df.isna().sum())

# Check original stock data
print(stock_data_df.head())
print(stock_data_df.info())
print(stock_data_df.isna().sum())

# Fill NaN values with an appropriate default (e.g., 0 or method)
stock_data_filled = stock_data_df.fillna(0)

# Or you can drop only the rows with critical columns NaN
stock_data_cleaned = stock_data_df.dropna(subset=['Close'])

# Continue with the simulation using the cleaned data
daily_balances, actions_taken = run_simulation(stock_data_cleaned)

def check_bollinger_signals(daily_data):
    # Check if enough data is available to calculate Bollinger Bands
    if len(daily_data) < 20:  # Change 20 to whatever period you're using for Bollinger Bands
        print(f"Not enough data to calculate Bollinger Bands for {daily_data.index[-1]}, holding position.")
        return 'hold'

    # Proceed to check Bollinger Bands signals
    if daily_data['Close'].iloc[-1] < daily_data['Bollinger_Lower'].iloc[-1]:
        return 'buy'
    elif daily_data['Close'].iloc[-1] > daily_data['Bollinger_Upper'].iloc[-1]:
        return 'sell'
    else:
        return 'hold'

# In your simulation loop
for current_day in stock_data.index:
    daily_data = stock_data.loc[:current_day]  # Adjust to get the relevant data
    bollinger_action = check_bollinger_signals(daily_data)
    # Handle the action as needed...

import pandas as pd

# Example of converting a dictionary to a DataFrame
stock_data = {
    'Date': ['2023-01-01', '2023-01-02'],
    'Close': [150.0, 155.0],
    'RSI': [35.0, 55.0],
    'MACD': [0.5, 0.3],
    'Bollinger_Middle': [None, None],
    'Bollinger_Upper': [None, None],
    'Bollinger_Lower': [None, None]
}

# Convert to DataFrame
stock_data_df = pd.DataFrame(stock_data)
stock_data_df['Date'] = pd.to_datetime(stock_data_df['Date'])  # Ensure 'Date' is a datetime type
stock_data_df.set_index('Date', inplace=True)  # Set the 'Date' column as the index

# Check the structure
print(stock_data_df)

# Make sure to replace `stock_data` with `stock_data_df`
for current_day in stock_data_df.index:
    daily_data = stock_data_df.loc[:current_day]  # Get data up to the current day
    bollinger_action = check_bollinger_signals(daily_data)  # Use the updated function to check signals

    # Now handle the action based on bollinger_action
    if bollinger_action == 'buy':
        # Add logic for buying
        pass
    elif bollinger_action == 'sell':
        # Add logic for selling
        pass
    else:
        print(f"Date: {current_day}, holding position.")

def check_bollinger_signals(daily_data):
    # Ensure we have enough data points to calculate Bollinger Bands
    if len(daily_data) < 20:  # Assuming a 20-period Bollinger Bands calculation
        print(f"Not enough data to calculate Bollinger Bands for {daily_data.index[-1]}, holding position.")
        return 'hold'

    # Calculate Bollinger Bands here (e.g., use last 20 days for the calculation)
    # Ensure this is the correct calculation for your context

    # Example placeholder calculation:
    # bollinger_upper = ...
    # bollinger_middle = ...
    # bollinger_lower = ...

    # Replace this with your logic to determine buy/sell signals
    if daily_data['Close'].iloc[-1] < bollinger_lower:
        return 'buy'
    elif daily_data['Close'].iloc[-1] > bollinger_upper:
        return 'sell'
    else:
        return 'hold'

# In your simulation loop
for current_day in stock_data_df.index:
    daily_data = stock_data_df.loc[:current_day]  # Get data up to the current day
    bollinger_action = check_bollinger_signals(daily_data)

    if bollinger_action == 'buy':
        # Add logic for buying
        print(f"Date: {current_day}, action: buy.")
    elif bollinger_action == 'sell':
        # Add logic for selling
        print(f"Date: {current_day}, action: sell.")
    else:
        print(f"Date: {current_day}, action: hold.")

def check_bollinger_signals(daily_data):
    # Set a smaller threshold for testing (e.g., 2 days)
    min_data_points = 2  # Change this to a larger number for actual trading
    if len(daily_data) < min_data_points:
        print(f"Not enough data to calculate Bollinger Bands for {daily_data.index[-1]}, holding position.")
        return 'hold'

    # Perform your Bollinger Bands calculations here
    # This is a placeholder example; replace with actual calculations
    # e.g. calculate moving average and standard deviation for the last N days

    bollinger_upper = daily_data['Close'].mean() + (daily_data['Close'].std() * 2)  # Example calculation
    bollinger_middle = daily_data['Close'].mean()
    bollinger_lower = daily_data['Close'].mean() - (daily_data['Close'].std() * 2)

    if daily_data['Close'].iloc[-1] < bollinger_lower:
        return 'buy'
    elif daily_data['Close'].iloc[-1] > bollinger_upper:
        return 'sell'
    else:
        return 'hold'

# Simulation loop
for current_day in stock_data_df.index:
    daily_data = stock_data_df.loc[:current_day]  # Get data up to the current day
    bollinger_action = check_bollinger_signals(daily_data)

    if bollinger_action == 'buy':
        # Logic for buying
        print(f"Date: {current_day}, action: buy.")
    elif bollinger_action == 'sell':
        # Logic for selling
        print(f"Date: {current_day}, action: sell.")
    else:
        print(f"Date: {current_day}, action: hold.")

def check_bollinger_signals(daily_data):
    # Set a minimum threshold for testing
    min_data_points = 1  # Set to 1 for testing purposes

    # Check if there's enough data to perform Bollinger Bands calculation
    if len(daily_data) < min_data_points:
        print(f"Not enough data to calculate Bollinger Bands for {daily_data.index[-1]}, holding position.")
        return 'hold'

    # Placeholder values for Bollinger Bands (for testing)
    bollinger_upper = daily_data['Close'].mean() + (1 * daily_data['Close'].std())  # Example placeholder
    bollinger_middle = daily_data['Close'].mean()
    bollinger_lower = daily_data['Close'].mean() - (1 * daily_data['Close'].std())  # Example placeholder

    if daily_data['Close'].iloc[-1] < bollinger_lower:
        return 'buy'
    elif daily_data['Close'].iloc[-1] > bollinger_upper:
        return 'sell'
    else:
        return 'hold'

# Run the simulation
for current_day in stock_data_df.index:
    daily_data = stock_data_df.loc[:current_day]  # Get data up to the current day
    bollinger_action = check_bollinger_signals(daily_data)

    if bollinger_action == 'buy':
        print(f"Date: {current_day}, action: buy.")
    elif bollinger_action == 'sell':
        print(f"Date: {current_day}, action: sell.")
    else:
        print(f"Date: {current_day}, action: hold.")

def run_simulation_without_bollinger(stock_data):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    for current_day in stock_data.index:
        daily_data = stock_data.loc[:current_day]

        # Basic logic without Bollinger Bands
        if len(daily_data) < 2:
            print(f"Not enough data for {current_day}, holding position.")
            actions_taken['hold'] += 1
            daily_balances.append(current_balance)
            continue

        # Placeholder decision-making logic
        # This logic can be adjusted as needed
        close_price = daily_data['Close'].iloc[-1]
        if close_price < 200:  # Example buy condition
            current_balance += 10  # Simulated gain
            actions_taken['buy'] += 1
        elif close_price > 250:  # Example sell condition
            current_balance -= 5  # Simulated loss
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        daily_balances.append(current_balance)
        print(f"Date: {current_day}, action: {actions_taken['buy']}, current balance: {current_balance}")

    return daily_balances, actions_taken

# Now run the simulation without Bollinger Bands
daily_balances, actions_taken = run_simulation_without_bollinger(stock_data_df)

# Displaying results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Actions Taken: {actions_taken}")

# Fetch historical data for at least 60 days
historical_data = fetch_historical_data(ticker, start_date='2023-01-01', end_date='2023-03-01')

def fetch_historical_data(ticker, start_date, end_date):
    # Fetch historical stock data for the specified date range
    data = get_stock_data(ticker, start_date, end_date)
    return data

def calculate_bollinger_bands(data, window=20):
    # Calculate the Bollinger Bands
    rolling_mean = data['Close'].rolling(window).mean()
    rolling_std = data['Close'].rolling(window).std()

    data['Bollinger_Middle'] = rolling_mean
    data['Bollinger_Upper'] = rolling_mean + (rolling_std * 2)
    data['Bollinger_Lower'] = rolling_mean - (rolling_std * 2)

    return data

# After cleaning and calculating indicators
daily_balances, actions_taken = run_simulation(stock_data_cleaned)

def log_action(date, action, price):
    print(f"Date: {date}, Action: {action}, Price: {price}")

# Ensure historical data is fetched and indicators are calculated
historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-03-01')
historical_data = calculate_bollinger_bands(historical_data)

# Drop NaN values
historical_data_cleaned = historical_data.dropna(subset=['Close', 'Bollinger_Middle', 'Bollinger_Upper', 'Bollinger_Lower'])

# Run the simulation
daily_balances, actions_taken = run_simulation(historical_data_cleaned)

# Print results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Actions Taken: {actions_taken}")

import yfinance as yf

def get_stock_data(ticker, start_date, end_date):
    # Fetch historical stock data using yfinance
    data = yf.download(ticker, start=start_date, end=end_date)
    data.reset_index(inplace=True)  # Resetting index to access the date as a column
    return data

# Ensure you have yfinance installed in your environment
# !pip install yfinance

import yfinance as yf

def get_stock_data(ticker, start_date, end_date):
    # Fetch historical stock data using yfinance
    data = yf.download(ticker, start=start_date, end=end_date)
    data.reset_index(inplace=True)  # Resetting index to access the date as a column
    return data

def calculate_bollinger_bands(data, window=20):
    # Calculate the Bollinger Bands
    rolling_mean = data['Close'].rolling(window).mean()
    rolling_std = data['Close'].rolling(window).std()

    data['Bollinger_Middle'] = rolling_mean
    data['Bollinger_Upper'] = rolling_mean + (rolling_std * 2)
    data['Bollinger_Lower'] = rolling_mean - (rolling_std * 2)

    return data

# Fetch historical data and calculate indicators
historical_data = get_stock_data('AAPL', '2023-01-01', '2023-03-01')
historical_data = calculate_bollinger_bands(historical_data)

# Drop NaN values
historical_data_cleaned = historical_data.dropna(subset=['Close', 'Bollinger_Middle', 'Bollinger_Upper', 'Bollinger_Lower'])

# Run the simulation
daily_balances, actions_taken = run_simulation(historical_data_cleaned)

# Print results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Actions Taken: {actions_taken}")

import yfinance as yf
import pandas as pd

# Function to fetch historical stock data
def fetch_historical_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date)
    data.reset_index(inplace=True)  # Reset index to use 'Date' as a column
    return data

# Function to calculate Bollinger Bands
def calculate_bollinger_bands(data, window=20):
    data['Bollinger_Middle'] = data['Close'].rolling(window=window).mean()
    data['Bollinger_Upper'] = data['Bollinger_Middle'] + (data['Close'].rolling(window=window).std() * 2)
    data['Bollinger_Lower'] = data['Bollinger_Middle'] - (data['Close'].rolling(window=window).std() * 2)
    return data

# Ensure historical data is fetched and indicators are calculated
historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-03-01')
historical_data = calculate_bollinger_bands(historical_data)

# Drop NaN values
historical_data_cleaned = historical_data.dropna(subset=['Close', 'Bollinger_Middle', 'Bollinger_Upper', 'Bollinger_Lower'])

# Now run the simulation again
daily_balances, actions_taken = run_simulation(historical_data_cleaned)

# Displaying results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Actions Taken: {actions_taken}")

import yfinance as yf
import pandas as pd

# Function to fetch historical stock data
def fetch_historical_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date)
    data.reset_index(inplace=True)  # Reset index to use 'Date' as a column
    return data

# Function to calculate Bollinger Bands
def calculate_bollinger_bands(data, window=20):
    data['Bollinger_Middle'] = data['Close'].rolling(window=window).mean()
    data['Bollinger_Upper'] = data['Bollinger_Middle'] + (data['Close'].rolling(window=window).std() * 2)
    data['Bollinger_Lower'] = data['Bollinger_Middle'] - (data['Close'].rolling(window=window).std() * 2)
    return data

# Run the simulation
def run_simulation(data):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Starting balance

    # Iterate through the DataFrame
    for index, row in data.iterrows():
        close_price = row['Close']
        if pd.isna(close_price):
            continue  # Skip if close price is NaN

        # Determine actions based on Bollinger Bands
        if close_price < row['Bollinger_Lower']:
            actions_taken['buy'] += 1
            current_balance += 5  # Assume we invest $5
            daily_balances.append(current_balance)
        elif close_price > row['Bollinger_Upper']:
            actions_taken['sell'] += 1
            current_balance -= 5  # Assume we lose $5
            daily_balances.append(current_balance)
        else:
            actions_taken['hold'] += 1
            daily_balances.append(current_balance)

    return daily_balances, actions_taken

# Fetch and process the historical data
historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-03-01')
historical_data = calculate_bollinger_bands(historical_data)

# Drop NaN values
historical_data_cleaned = historical_data.dropna(subset=['Close', 'Bollinger_Middle', 'Bollinger_Upper', 'Bollinger_Lower'])

# Run the simulation
daily_balances, actions_taken = run_simulation(historical_data_cleaned)

# Display results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Actions Taken: {actions_taken}")

def check_combined_signals(daily_data):
    """Check signals from RSI, MACD, and Bollinger Bands."""

    # Initialize action as 'hold'
    action = 'hold'

    # Bollinger Bands logic
    if daily_data['Close'] < daily_data['Bollinger_Lower']:
        action = 'buy'
    elif daily_data['Close'] > daily_data['Bollinger_Upper']:
        action = 'sell'

    # RSI logic
    if daily_data['RSI'] < 30:
        action = 'buy'  # Strong buy signal
    elif daily_data['RSI'] > 70:
        action = 'sell'  # Strong sell signal

    # MACD logic
    if daily_data['MACD'] > 0:  # This condition might vary based on your MACD implementation
        if daily_data['MACD_Signal'] < daily_data['MACD']:  # Buy condition
            action = 'buy'
    elif daily_data['MACD'] < 0:
        if daily_data['MACD_Signal'] > daily_data['MACD']:  # Sell condition
            action = 'sell'

    return action

def run_simulation(stock_data):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Initial balance

    # Iterate through the days in the stock data
    for current_day in stock_data.index:
        daily_data = stock_data.loc[current_day]

        # Check combined signals
        action = check_combined_signals(daily_data)

        if action == 'buy':
            current_balance += 5  # Update balance logic based on buying
            actions_taken['buy'] += 1
        elif action == 'sell':
            current_balance -= 5  # Update balance logic based on selling
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        daily_balances.append(current_balance)

    return daily_balances, actions_taken

def fetch_historical_data(ticker, start_date, end_date):
    # Replace with your data fetching logic
    data = get_stock_data(ticker, start_date, end_date)
    return data

def calculate_rsi(data, window=14):
    # RSI calculation logic
    # ...
    return data

def calculate_macd(data):
    # MACD calculation logic
    # ...
    return data

def calculate_bollinger_bands(data, window=20):
    # Bollinger Bands calculation logic
    # ...
    return data

def run_simulation(stock_data):
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_balance = 200  # Initial balance

    # Iterate through the days in the stock data
    for current_day in stock_data.index:
        daily_data = stock_data.loc[current_day]

        # Check combined signals
        action = check_combined_signals(daily_data)

        # Update balance based on the action taken
        if action == 'buy':
            current_balance += 5  # Example trade logic
            actions_taken['buy'] += 1
        elif action == 'sell':
            current_balance -= 5  # Example trade logic
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        daily_balances.append(current_balance)

    return daily_balances, actions_taken

# Ensure historical data is fetched and indicators are calculated
historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-03-01')
historical_data = calculate_rsi(historical_data)
historical_data = calculate_macd(historical_data)
historical_data = calculate_bollinger_bands(historical_data)

# Run the simulation with the complete data
daily_balances, actions_taken = run_simulation(historical_data)

# Display the results
print(f"Final Balance: {daily_balances[-1] if daily_balances else 'N/A'}")
print(f"Actions Taken: {actions_taken}")

def calculate_bollinger_bands(data, window=20, num_std_dev=2):
    data['Bollinger_Middle'] = data['Close'].rolling(window=window).mean()
    data['Bollinger_Upper'] = data['Bollinger_Middle'] + (data['Close'].rolling(window=window).std() * num_std_dev)
    data['Bollinger_Lower'] = data['Bollinger_Middle'] - (data['Close'].rolling(window=window).std() * num_std_dev)
    return data

def check_bollinger_signals(daily_data):
    if pd.isna(daily_data['Close']).any() or \
       pd.isna(daily_data['Bollinger_Middle']).any() or \
       pd.isna(daily_data['Bollinger_Upper']).any() or \
       pd.isna(daily_data['Bollinger_Lower']).any():
        return 'hold'
    # Your trading logic here

historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-03-01')
historical_data = calculate_bollinger_bands(historical_data)

for current_day in stock_data.index:
    daily_data = stock_data.loc[:current_day]

    # Check signals from all indicators
    bollinger_action = check_bollinger_signals(daily_data)
    rsi_action = check_rsi_signals(daily_data)
    macd_action = check_macd_signals(daily_data)

    # Combine actions (you can customize the logic here)
    if bollinger_action == 'buy' and rsi_action == 'buy' and macd_action == 'buy':
        # Execute buy logic
    elif bollinger_action == 'sell' and rsi_action == 'sell' and macd_action == 'sell':
        # Execute sell logic
    else:
        # Hold

for current_day in stock_data.index:
    daily_data = stock_data.loc[:current_day]

    # Check signals from all indicators
    bollinger_action = check_bollinger_signals(daily_data)
    rsi_action = check_rsi_signals(daily_data)
    macd_action = check_macd_signals(daily_data)

    # Combine actions (ensure you have indented blocks)
    if bollinger_action == 'buy' and rsi_action == 'buy' and macd_action == 'buy':
        # Execute buy logic
        print(f"Buying on {current_day}")  # Placeholder for buy logic
    elif bollinger_action == 'sell' and rsi_action == 'sell' and macd_action == 'sell':
        # Execute sell logic
        print(f"Selling on {current_day}")  # Placeholder for sell logic
    else:
        # Hold
        print(f"Holding on {current_day}")  # Placeholder for hold logic

print(type(stock_data))

import pandas as pd

# Assuming stock_data is your dictionary
stock_data_df = pd.DataFrame(stock_data)

# Now you can access the index
for current_day in stock_data_df.index:
    daily_data = stock_data_df.loc[:current_day]
    # Your existing code...

stock_data_df = pd.read_csv('path_to_your_file.csv')

from google.colab import files
uploaded = files.upload()

import pandas as pd

# Assuming stock_data is a dictionary
stock_data_df = pd.DataFrame(stock_data)  # Convert the dictionary to a DataFrame

# Now you can proceed with your existing code
for current_day in stock_data_df.index:
    daily_data = stock_data_df.loc[:current_day]
    # Your existing logic...

# Check for NaN values in critical columns
print(stock_data_df.isna().sum())

# If there are NaN values, you can drop them or fill them as necessary
stock_data_cleaned = stock_data_df.dropna(subset=['Close', 'RSI', 'MACD', 'Bollinger_Lower', 'Bollinger_Upper'])

def make_trading_decision(daily_data):
    # Check signals from each indicator
    bollinger_action = check_bollinger_signals(daily_data)
    rsi_action = check_rsi_signals(daily_data)
    macd_action = check_macd_signals(daily_data)

    # Combine logic: if all indicators agree, make a decision
    if bollinger_action == 'buy' and rsi_action == 'buy' and macd_action == 'buy':
        return 'buy'
    elif bollinger_action == 'sell' and rsi_action == 'sell' and macd_action == 'sell':
        return 'sell'
    else:
        return 'hold'

# Implement the signal check for each indicator
def check_bollinger_signals(daily_data):
    if daily_data['Close'] < daily_data['Bollinger_Lower']:
        return 'buy'
    elif daily_data['Close'] > daily_data['Bollinger_Upper']:
        return 'sell'
    return 'hold'

def check_rsi_signals(daily_data):
    if daily_data['RSI'] < 30:
        return 'buy'
    elif daily_data['RSI'] > 70:
        return 'sell'
    return 'hold'

def check_macd_signals(daily_data):
    if daily_data['MACD'] > 0:
        return 'buy'
    elif daily_data['MACD'] < 0:
        return 'sell'
    return 'hold'

initial_balance = 200
current_balance = initial_balance
actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
daily_balances = []

for current_day in stock_data_cleaned.index:
    daily_data = stock_data_cleaned.loc[current_day]
    action = make_trading_decision(daily_data)

    if action == 'buy':
        current_balance -= 10  # Example: buy $10 worth of stock
        actions_taken['buy'] += 1
    elif action == 'sell':
        current_balance += 10  # Example: sell $10 worth of stock
        actions_taken['sell'] += 1
    else:
        actions_taken['hold'] += 1

    daily_balances.append(current_balance)

# Display results
print(f"Final Balance: {current_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Inspect the first few rows of the cleaned stock data to ensure it contains values
print(stock_data_cleaned.head())

for current_day in stock_data_cleaned.index:
    daily_data = stock_data_cleaned.loc[current_day]
    action = make_trading_decision(daily_data)

    # Print the action for each day to understand what’s happening
    print(f"Date: {current_day}, Action: {action}, Close: {daily_data['Close']}, RSI: {daily_data['RSI']}, MACD: {daily_data['MACD']}")

    if action == 'buy':
        current_balance -= 10  # Example: buy $10 worth of stock
        actions_taken['buy'] += 1
    elif action == 'sell':
        current_balance += 10  # Example: sell $10 worth of stock
        actions_taken['sell'] += 1
    else:
        actions_taken['hold'] += 1

    daily_balances.append(current_balance)

# Display results
print(f"Final Balance: {current_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Check the first few rows of your stock data
print(stock_data_cleaned.head())

for current_day in stock_data_cleaned.index:
    daily_data = stock_data_cleaned.loc[current_day]
    print(f"Date: {current_day}, Close: {daily_data['Close']}, RSI: {daily_data['RSI']}, MACD: {daily_data['MACD']}, Bollinger Lower: {daily_data['Bollinger_Lower']}, Bollinger Upper: {daily_data['Bollinger_Upper']}")

def make_trading_decision(daily_data):
    # Example logic
    if daily_data['RSI'] < 30 and daily_data['MACD'] > 0 and daily_data['Close'] < daily_data['Bollinger_Lower']:
        return 'buy'
    elif daily_data['RSI'] > 70 and daily_data['MACD'] < 0 and daily_data['Close'] > daily_data['Bollinger_Upper']:
        return 'sell'
    else:
        return 'hold'

print(f"Number of data points: {len(stock_data_cleaned)}")

print(stock_data_cleaned)  # Display the contents of the dataset to see what has been loaded

print(stock_data_cleaned.isnull().sum())  # Check how many missing values there are in each column

# Verify that stock data is being fetched
historical_data = fetch_historical_data('AAPL', '2023-01-01', '2023-06-01')  # Replace with the correct function
print(historical_data.head())

# Ensure all indicators are calculated
historical_data = calculate_bollinger_bands(historical_data)
historical_data = calculate_rsi(historical_data)
historical_data = calculate_macd(historical_data)
print(historical_data.head())

start_date = '2023-01-01'
end_date = '2023-06-01'

# Run the simulation and capture the results
final_balance, daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Display the final results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data):
    # Initialize variables for tracking balances and actions
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    final_balance = 200  # Starting balance

    # Iterate over the stock data and apply the strategy
    for current_day in stock_data.index:
        # Get the action based on indicators (Bollinger, RSI, MACD)
        action = apply_trading_strategy(stock_data.loc[current_day])

        # Simulate the result of that action
        if action == 'buy':
            final_balance -= 5  # Example trade amount
            actions_taken['buy'] += 1
        elif action == 'sell':
            final_balance += 5  # Example trade amount
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        # Append the balance for the day
        daily_balances.append(final_balance)

    return final_balance, daily_balances, actions_taken

# Run the simulation
final_balance, daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Display the results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation(stock_data):
    # Initialize variables for tracking balances and actions
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    final_balance = 200  # Starting balance

    # Iterate over the stock data and apply the strategy
    for current_day in stock_data.index:
        print(f"Processing data for: {current_day}")  # Add this to check if data is being processed

        # Get the action based on indicators (Bollinger, RSI, MACD)
        action = apply_trading_strategy(stock_data.loc[current_day])
        print(f"Action on {current_day}: {action}")  # Debug action

        # Simulate the result of that action
        if action == 'buy':
            final_balance -= 5  # Example trade amount
            actions_taken['buy'] += 1
        elif action == 'sell':
            final_balance += 5  # Example trade amount
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        # Append the balance for the day
        daily_balances.append(final_balance)

    return final_balance, daily_balances, actions_taken

def apply_trading_strategy(daily_data):
    # Assuming we're combining RSI, MACD, and Bollinger Bands for a decision
    rsi_action = check_rsi_signal(daily_data)
    macd_action = check_macd_signal(daily_data)
    bollinger_action = check_bollinger_signals(daily_data)

    print(f"RSI Action: {rsi_action}, MACD Action: {macd_action}, Bollinger Action: {bollinger_action}")  # Debug

    # Simple logic for combined strategy (you can refine this based on your needs)
    if rsi_action == 'buy' and macd_action == 'buy' and bollinger_action == 'buy':
        return 'buy'
    elif rsi_action == 'sell' and macd_action == 'sell' and bollinger_action == 'sell':
        return 'sell'
    else:
        return 'hold'

# Function to run the simulation with debug statements
def run_simulation(stock_data_cleaned):
    initial_balance = 200
    current_balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    # Iterate through each day in the stock data
    for current_day in stock_data_cleaned.index:
        print(f"Processing data for: {current_day}")
        daily_data = stock_data_cleaned.loc[current_day]

        # Check signals from all indicators (RSI, MACD, Bollinger Bands)
        bollinger_action = check_bollinger_signals(daily_data)
        rsi_action = check_rsi_signals(daily_data)
        macd_action = check_macd_signals(daily_data)

        # Combine logic for all indicators to decide on action
        if bollinger_action == 'buy' and rsi_action == 'buy' and macd_action == 'buy':
            print(f"Action: buy on {current_day}")
            actions_taken['buy'] += 1
            current_balance -= 5  # Example logic for spending $5 per trade

        elif bollinger_action == 'sell' and rsi_action == 'sell' and macd_action == 'sell':
            print(f"Action: sell on {current_day}")
            actions_taken['sell'] += 1
            current_balance += 5  # Example logic for gaining $5 per trade

        else:
            print(f"Action: hold on {current_day}")
            actions_taken['hold'] += 1

        daily_balances.append(current_balance)

    return current_balance, daily_balances, actions_taken

# Run the simulation and capture the results
final_balance, daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Display the final results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Check the contents of stock_data_cleaned
print(stock_data_cleaned.head())  # Show the first few rows
print(stock_data_cleaned.info())  # Show the structure of the DataFrame

# Check for any missing values in critical columns
print(stock_data_cleaned[['Close', 'RSI', 'MACD', 'Bollinger_Lower', 'Bollinger_Upper']].isna().sum())

# Add this inside the simulation loop after calculating indicators
print(f"Date: {current_day}, Close: {daily_data['Close']}, RSI: {daily_data['RSI']}, MACD: {daily_data['MACD']}, Bollinger Lower: {daily_data['Bollinger_Lower']}, Bollinger Upper: {daily_data['Bollinger_Upper']}")

def run_simulation(stock_data_cleaned):
    final_balance = 200  # Starting balance
    daily_balances = []  # Track the balance each day
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}  # Track actions

    # Iterate over each day in the stock data
    for current_day in stock_data_cleaned.index:
        daily_data = stock_data_cleaned.loc[current_day]

        # Check if all necessary data is available
        if pd.isna(daily_data[['Close', 'RSI', 'MACD', 'Bollinger_Lower', 'Bollinger_Upper']]).any():
            print(f"Skipping {current_day} due to missing data.")
            actions_taken['hold'] += 1
            daily_balances.append(final_balance)
            continue

        # Debug print statement to see the data used for the current day
        print(f"Date: {current_day}, Close: {daily_data['Close']}, RSI: {daily_data['RSI']}, "
              f"MACD: {daily_data['MACD']}, Bollinger Lower: {daily_data['Bollinger_Lower']}, "
              f"Bollinger Upper: {daily_data['Bollinger_Upper']}")

        # Define the conditions for buy, sell, and hold based on all indicators
        rsi_action = 'buy' if daily_data['RSI'] < 30 else 'sell' if daily_data['RSI'] > 70 else 'hold'
        macd_action = 'buy' if daily_data['MACD'] > 0 else 'sell' if daily_data['MACD'] < 0 else 'hold'
        bollinger_action = 'buy' if daily_data['Close'] < daily_data['Bollinger_Lower'] else 'sell' if daily_data['Close'] > daily_data['Bollinger_Upper'] else 'hold'

        # Take action based on the combined indicators
        if rsi_action == 'buy' and macd_action == 'buy' and bollinger_action == 'buy':
            actions_taken['buy'] += 1
            final_balance -= 5  # Simulate buying with $5 per trade
        elif rsi_action == 'sell' and macd_action == 'sell' and bollinger_action == 'sell':
            actions_taken['sell'] += 1
            final_balance += 5  # Simulate selling with $5 per trade
        else:
            actions_taken['hold'] += 1

        # Append the balance after each action
        daily_balances.append(final_balance)

    return final_balance, daily_balances, actions_taken


# Run the simulation with cleaned data
final_balance, daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Display the final results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Debugging step: Check the structure and content of the cleaned data
print("Inspecting the first few rows of the cleaned data:")
print(stock_data_cleaned.head())  # Ensure that the data has the right columns and no NaNs

# Ensure that the critical columns are in the cleaned data
if 'Close' not in stock_data_cleaned.columns or \
   'RSI' not in stock_data_cleaned.columns or \
   'MACD' not in stock_data_cleaned.columns or \
   'Bollinger_Lower' not in stock_data_cleaned.columns or \
   'Bollinger_Upper' not in stock_data_cleaned.columns:
    print("Missing critical columns for indicators!")

def run_simulation(stock_data_cleaned):
    final_balance = 200  # Starting balance
    daily_balances = []  # Track the balance each day
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}  # Track actions

    for current_day in stock_data_cleaned.index:
        daily_data = stock_data_cleaned.loc[current_day]

        # Debugging: Print the data for each day
        print(f"Date: {current_day}, Data: {daily_data}")

        # Check if all necessary data is available
        if pd.isna(daily_data[['Close', 'RSI', 'MACD', 'Bollinger_Lower', 'Bollinger_Upper']]).any():
            print(f"Skipping {current_day} due to missing data.")
            actions_taken['hold'] += 1
            daily_balances.append(final_balance)
            continue

        # Print indicator values to debug
        print(f"RSI: {daily_data['RSI']}, MACD: {daily_data['MACD']}, Close: {daily_data['Close']}, "
              f"Bollinger Lower: {daily_data['Bollinger_Lower']}, Bollinger Upper: {daily_data['Bollinger_Upper']}")

        # Define the conditions for buy, sell, and hold based on all indicators
        rsi_action = 'buy' if daily_data['RSI'] < 30 else 'sell' if daily_data['RSI'] > 70 else 'hold'
        macd_action = 'buy' if daily_data['MACD'] > 0 else 'sell' if daily_data['MACD'] < 0 else 'hold'
        bollinger_action = 'buy' if daily_data['Close'] < daily_data['Bollinger_Lower'] else \
                           'sell' if daily_data['Close'] > daily_data['Bollinger_Upper'] else 'hold'

        print(f"Actions -> RSI: {rsi_action}, MACD: {macd_action}, Bollinger: {bollinger_action}")

        # Take action based on combined indicators
        if rsi_action == 'buy' and macd_action == 'buy' and bollinger_action == 'buy':
            actions_taken['buy'] += 1
            final_balance -= 5  # Simulate buying with $5 per trade
        elif rsi_action == 'sell' and macd_action == 'sell' and bollinger_action == 'sell':
            actions_taken['sell'] += 1
            final_balance += 5  # Simulate selling with $5 per trade
        else:
            actions_taken['hold'] += 1

        daily_balances.append(final_balance)

    return final_balance, daily_balances, actions_taken

# Debugging step: Check the structure and content of the cleaned data
print("Inspecting the first few rows of the cleaned data:")
print(stock_data_cleaned.head())  # Ensure that the data has the right columns and no NaNs

# Ensure that the critical columns are in the cleaned data
if 'Close' not in stock_data_cleaned.columns or \
   'RSI' not in stock_data_cleaned.columns or \
   'MACD' not in stock_data_cleaned.columns or \
   'Bollinger_Lower' not in stock_data_cleaned.columns or \
   'Bollinger_Upper' not in stock_data_cleaned.columns:
    print("Missing critical columns for indicators!")

# Define the function to run the simulation with debug info
def run_simulation(stock_data_cleaned):
    final_balance = 200  # Starting balance
    daily_balances = []  # Track the balance each day
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}  # Track actions

    for current_day in stock_data_cleaned.index:
        daily_data = stock_data_cleaned.loc[current_day]

        # Debugging: Print the data for each day
        print(f"Date: {current_day}, Data: {daily_data}")

        # Check if all necessary data is available
        if pd.isna(daily_data[['Close', 'RSI', 'MACD', 'Bollinger_Lower', 'Bollinger_Upper']]).any():
            print(f"Skipping {current_day} due to missing data.")
            actions_taken['hold'] += 1
            daily_balances.append(final_balance)
            continue

        # Print indicator values to debug
        print(f"RSI: {daily_data['RSI']}, MACD: {daily_data['MACD']}, Close: {daily_data['Close']}, "
              f"Bollinger Lower: {daily_data['Bollinger_Lower']}, Bollinger Upper: {daily_data['Bollinger_Upper']}")

        # Define the conditions for buy, sell, and hold based on all indicators
        rsi_action = 'buy' if daily_data['RSI'] < 30 else 'sell' if daily_data['RSI'] > 70 else 'hold'
        macd_action = 'buy' if daily_data['MACD'] > 0 else 'sell' if daily_data['MACD'] < 0 else 'hold'
        bollinger_action = 'buy' if daily_data['Close'] < daily_data['Bollinger_Lower'] else \
                           'sell' if daily_data['Close'] > daily_data['Bollinger_Upper'] else 'hold'

        print(f"Actions -> RSI: {rsi_action}, MACD: {macd_action}, Bollinger: {bollinger_action}")

        # Take action based on combined indicators
        if rsi_action == 'buy' and macd_action == 'buy' and bollinger_action == 'buy':
            actions_taken['buy'] += 1
            final_balance -= 5  # Simulate buying with $5 per trade
        elif rsi_action == 'sell' and macd_action == 'sell' and bollinger_action == 'sell':
            actions_taken['sell'] += 1
            final_balance += 5  # Simulate selling with $5 per trade
        else:
            actions_taken['hold'] += 1

        daily_balances.append(final_balance)

    return final_balance, daily_balances, actions_taken

# Run the simulation and capture the results
final_balance, daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Display the final results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Fetch historical stock data
import yfinance as yf

# Fetch AAPL data as a test
stock_data_raw = yf.download('AAPL', start='2023-01-01', end='2023-03-01')

# Inspect the first few rows to ensure the data is loaded
print("Raw stock data:")
print(stock_data_raw.head())

# Make sure to calculate Bollinger Bands, RSI, and MACD after loading the data
# Calculate Bollinger Bands
stock_data_raw['Bollinger_Middle'] = stock_data_raw['Close'].rolling(window=20).mean()
stock_data_raw['Bollinger_Upper'] = stock_data_raw['Bollinger_Middle'] + (stock_data_raw['Close'].rolling(window=20).std() * 2)
stock_data_raw['Bollinger_Lower'] = stock_data_raw['Bollinger_Middle'] - (stock_data_raw['Close'].rolling(window=20).std() * 2)

# Calculate RSI
delta = stock_data_raw['Close'].diff(1)
gain = delta.where(delta > 0, 0)
loss = -delta.where(delta < 0, 0)
avg_gain = gain.rolling(window=14).mean()
avg_loss = loss.rolling(window=14).mean()
rs = avg_gain / avg_loss
stock_data_raw['RSI'] = 100 - (100 / (1 + rs))

# Calculate MACD
ema_12 = stock_data_raw['Close'].ewm(span=12, adjust=False).mean()
ema_26 = stock_data_raw['Close'].ewm(span=26, adjust=False).mean()
stock_data_raw['MACD'] = ema_12 - ema_26

# Drop any rows with NaN values in critical columns
stock_data_cleaned = stock_data_raw.dropna(subset=['Close', 'Bollinger_Lower', 'Bollinger_Upper', 'RSI', 'MACD'])

# Display the first few rows after calculating the indicators
print("Stock data with calculated indicators:")
print(stock_data_cleaned.head())

# Run the simulation and capture the results
final_balance, daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Display the final results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_simulation_with_adjustments(stock_data_df):
    initial_balance = 200  # Starting balance
    current_balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Extract relevant data
        rsi = daily_data['RSI']
        macd = daily_data['MACD']
        close_price = daily_data['Close']
        bollinger_lower = daily_data['Bollinger_Lower']
        bollinger_upper = daily_data['Bollinger_Upper']

        # Determine actions for each indicator
        rsi_action = 'buy' if rsi < 35 else 'sell' if rsi > 65 else 'hold'
        macd_action = 'buy' if macd > 0 else 'sell'
        bollinger_action = 'buy' if close_price < bollinger_lower else 'sell' if close_price > bollinger_upper else 'hold'

        # Adjust the decision-making process
        if rsi_action == 'buy' and macd_action == 'buy':
            if bollinger_action == 'buy' or bollinger_action == 'hold':  # Allow neutral Bollinger
                current_balance += 10  # Example increase for buy action
                actions_taken['buy'] += 1
            else:
                actions_taken['hold'] += 1
        elif rsi_action == 'sell' and macd_action == 'sell':
            if bollinger_action == 'sell' or bollinger_action == 'hold':  # Allow neutral Bollinger
                current_balance -= 10  # Example decrease for sell action
                actions_taken['sell'] += 1
            else:
                actions_taken['hold'] += 1
        else:
            actions_taken['hold'] += 1

        # Record the daily balance
        daily_balances.append(current_balance)

        # Print out the current day's decisions
        print(f"Date: {current_day}, Actions -> RSI: {rsi_action}, MACD: {macd_action}, Bollinger: {bollinger_action}, Balance: {current_balance}")

    return current_balance, daily_balances, actions_taken

import pandas as pd
import numpy as np
import yfinance as yf

# Function to fetch historical stock data
def fetch_historical_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date)
    return data

# Function to calculate Bollinger Bands
def calculate_bollinger_bands(data):
    data['Bollinger_Middle'] = data['Close'].rolling(window=20).mean()
    data['Bollinger_Upper'] = data['Bollinger_Middle'] + (data['Close'].rolling(window=20).std() * 2)
    data['Bollinger_Lower'] = data['Bollinger_Middle'] - (data['Close'].rolling(window=20).std() * 2)
    return data

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    data['RSI'] = 100 - (100 / (1 + rs))
    return data

# Function to calculate MACD
def calculate_macd(data):
    data['MACD'] = data['Close'].ewm(span=12, adjust=False).mean() - data['Close'].ewm(span=26, adjust=False).mean()
    return data

# Combine all the indicators
def calculate_indicators(data):
    data = calculate_bollinger_bands(data)
    data = calculate_rsi(data)
    data = calculate_macd(data)
    return data

# Function to check for Bollinger Bands signals
def check_bollinger_signals(data):
    if pd.isna(data['Bollinger_Lower']) or pd.isna(data['Bollinger_Upper']):
        return 'hold'
    if data['Close'] < data['Bollinger_Lower']:
        return 'buy'
    elif data['Close'] > data['Bollinger_Upper']:
        return 'sell'
    else:
        return 'hold'

# Function to check RSI signals
def check_rsi_signals(data):
    if pd.isna(data['RSI']):
        return 'hold'
    if data['RSI'] < 30:
        return 'buy'
    elif data['RSI'] > 70:
        return 'sell'
    else:
        return 'hold'

# Function to check MACD signals
def check_macd_signals(data):
    if pd.isna(data['MACD']):
        return 'hold'
    if data['MACD'] > 0:
        return 'buy'
    else:
        return 'sell'

# Simulation function
def run_simulation(data):
    initial_balance = 200
    current_balance = initial_balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    for current_day in data.index:
        daily_data = data.loc[current_day]

        # Check signals from all indicators
        bollinger_action = check_bollinger_signals(daily_data)
        rsi_action = check_rsi_signals(daily_data)
        macd_action = check_macd_signals(daily_data)

        # Determine action (simplified logic: take action when all signals agree)
        if bollinger_action == 'buy' and rsi_action == 'buy' and macd_action == 'buy':
            current_balance -= 5  # Example trade value
            actions_taken['buy'] += 1
        elif bollinger_action == 'sell' and rsi_action == 'sell' and macd_action == 'sell':
            current_balance += 5  # Example trade value
            actions_taken['sell'] += 1
        else:
            actions_taken['hold'] += 1

        # Record daily balance
        daily_balances.append(current_balance)

    return current_balance, daily_balances, actions_taken

# Fetch stock data for the simulation
stock_data = fetch_historical_data('AAPL', '2023-01-01', '2023-03-01')

# Calculate all indicators
stock_data_cleaned = calculate_indicators(stock_data)

# Run the simulation and capture the results
final_balance, daily_balances, actions_taken = run_simulation(stock_data_cleaned)

# Display the final results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Adjusted function for trading logic based on at least two indicators
def determine_trade_action(rsi_action, macd_action, bollinger_action):
    actions = [rsi_action, macd_action, bollinger_action]
    buy_signals = actions.count('buy')
    sell_signals = actions.count('sell')

    if buy_signals >= 2:
        return 'buy'
    elif sell_signals >= 2:
        return 'sell'
    else:
        return 'hold'

# Updated trading logic in the main loop
for current_day in stock_data.index:
    daily_data = stock_data.loc[current_day]

    # Check signals from all indicators
    bollinger_action = check_bollinger_signals(daily_data)
    rsi_action = check_rsi_signals(daily_data)
    macd_action = check_macd_signals(daily_data)

    # Determine the final trade action based on majority of signals
    final_action = determine_trade_action(rsi_action, macd_action, bollinger_action)

    print(f"Date: {current_day}, Action: {final_action}, Close: {daily_data['Close']}, RSI: {daily_data['RSI']}, MACD: {daily_data['MACD']}, Bollinger Lower: {daily_data['Bollinger_Lower']}, Bollinger Upper: {daily_data['Bollinger_Upper']}")

    # Execute action
    if final_action == 'buy':
        balance -= trade_amount
        print(f"Bought on {current_day}, balance: {balance}")
    elif final_action == 'sell':
        balance += trade_amount
        print(f"Sold on {current_day}, balance: {balance}")
    else:
        print(f"Held on {current_day}, balance: {balance}")

# Initialize balance and trade amount
balance = 200  # Starting balance
trade_amount = 10  # Amount to use per trade

# Adjusted function for trading logic based on at least two indicators
def determine_trade_action(rsi_action, macd_action, bollinger_action):
    actions = [rsi_action, macd_action, bollinger_action]
    buy_signals = actions.count('buy')
    sell_signals = actions.count('sell')

    if buy_signals >= 2:
        return 'buy'
    elif sell_signals >= 2:
        return 'sell'
    else:
        return 'hold'

# Updated trading logic in the main loop
for current_day in stock_data.index:
    daily_data = stock_data.loc[current_day]

    # Skip if NaN values are present
    if pd.isna(daily_data['Close']) or pd.isna(daily_data['RSI']) or pd.isna(daily_data['MACD']):
        print(f"Skipping {current_day} due to NaN values")
        continue

    # Check signals from all indicators
    bollinger_action = check_bollinger_signals(daily_data)
    rsi_action = check_rsi_signals(daily_data)
    macd_action = check_macd_signals(daily_data)

    # Determine the final trade action based on majority of signals
    final_action = determine_trade_action(rsi_action, macd_action, bollinger_action)

    print(f"Date: {current_day}, Action: {final_action}, Close: {daily_data['Close']}, RSI: {daily_data['RSI']}, MACD: {daily_data['MACD']}, Bollinger Lower: {daily_data['Bollinger_Lower']}, Bollinger Upper: {daily_data['Bollinger_Upper']}")

    # Execute action
    if final_action == 'buy':
        balance -= trade_amount
        print(f"Bought on {current_day}, balance: {balance}")
    elif final_action == 'sell':
        balance += trade_amount
        print(f"Sold on {current_day}, balance: {balance}")
    else:
        print(f"Held on {current_day}, balance: {balance}")

def combined_trading_logic(daily_data):
    """
    Adjusted buy/sell logic based on RSI, MACD, and Bollinger Bands.
    """
    rsi = daily_data['RSI']
    macd = daily_data['MACD']
    close_price = daily_data['Close']
    bollinger_lower = daily_data['Bollinger_Lower']
    bollinger_upper = daily_data['Bollinger_Upper']

    # Adjusted thresholds
    if pd.isna(rsi) or pd.isna(macd) or pd.isna(bollinger_lower) or pd.isna(bollinger_upper):
        return 'hold'

    rsi_action = 'sell' if rsi > 70 else 'buy' if rsi < 40 else 'hold'
    macd_action = 'buy' if macd > 0 else 'sell'
    bollinger_action = 'buy' if close_price < bollinger_lower else 'sell' if close_price > bollinger_upper else 'hold'

    # Combined logic
    if bollinger_action == 'buy' and rsi_action == 'buy' and macd_action == 'buy':
        return 'buy'
    elif bollinger_action == 'sell' and rsi_action == 'sell' and macd_action == 'sell':
        return 'sell'
    else:
        return 'hold'

# Simulate with updated combined trading logic
def run_updated_simulation(stock_data):
    balance = 200  # Starting balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    for current_day in stock_data.index:
        daily_data = stock_data.loc[current_day]

        # Check combined signals from RSI, MACD, and Bollinger Bands
        action = combined_trading_logic(daily_data)

        if action == 'buy':
            balance += 10  # Example action, add to balance
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif action == 'sell':
            balance -= 10  # Example action, subtract from balance
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        # Store balance for the day
        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Run the updated simulation
final_balance, daily_balances, actions_taken = run_updated_simulation(stock_data_cleaned)

# Display the results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Adjust the combined logic to require only 2 out of 3 indicators for action
def adjusted_trading_logic(daily_data):
    rsi_action = 'buy' if daily_data['RSI'] < 40 else 'sell' if daily_data['RSI'] > 60 else 'hold'
    macd_action = 'buy' if daily_data['MACD'] > 0 else 'sell' if daily_data['MACD'] < 0 else 'hold'
    bollinger_action = 'buy' if daily_data['Close'] < daily_data['Bollinger_Lower'] else 'sell' if daily_data['Close'] > daily_data['Bollinger_Upper'] else 'hold'

    # If two out of the three indicators signal the same action, take that action
    actions = [rsi_action, macd_action, bollinger_action]
    if actions.count('buy') >= 2:
        return 'buy'
    elif actions.count('sell') >= 2:
        return 'sell'
    else:
        return 'hold'

# Now simulate again using the adjusted trading logic
final_balance, daily_balances, actions_taken = run_updated_simulation(stock_data_cleaned)

# Display the results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_optimized_strategy(stock_data_df):
    balance = 200  # Starting balance
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    for current_day in stock_data_df.index:
        daily_data = stock_data_df.loc[current_day]

        # Get signals from RSI, MACD, and Bollinger Bands
        rsi_action = check_rsi_signals(daily_data)
        macd_action = check_macd_signals(daily_data)
        bollinger_action = check_bollinger_signals(daily_data)

        # Decision logic based on the combination of indicators
        if rsi_action == 'buy' and macd_action == 'buy' and bollinger_action == 'buy':
            # Buy signal from all indicators
            balance -= 5  # Buy $5 worth
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")

        elif rsi_action == 'sell' and macd_action == 'sell' and bollinger_action == 'sell':
            # Sell signal from all indicators
            balance += 5  # Sell $5 worth
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")

        else:
            # Hold if mixed or no strong signal
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        # Append the current balance to track daily progress
        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Variables for tracking the day's performance
daily_loss_limit = 50  # $50 max loss per day
current_loss = 0
current_profit = 0
take_profit_percentage = 2  # Example: Take profit at 2% gain

def risk_management(current_day, balance, current_trade_profit, daily_loss_limit, current_loss):
    # Check if we hit the loss limit for the day
    if current_loss > daily_loss_limit:
        print(f"Daily loss limit exceeded on {current_day}. Stopping further trades.")
        return False  # Stop trading for the day
    # Check if it's time to take profit
    elif current_trade_profit >= take_profit_percentage / 100 * balance:
        print(f"Take-profit reached on {current_day}. Selling and locking in profits.")
        return "sell"  # Take profits
    return True  # Continue trading

# Trading loop for minute-by-minute
for current_day in stock_data.index:
    # Calculate signals
    rsi_signal = check_rsi(stock_data.loc[current_day])
    macd_signal = check_macd(stock_data.loc[current_day])
    bollinger_signal = check_bollinger(stock_data.loc[current_day])

    # Decide based on combined signals
    if rsi_signal == 'buy' and macd_signal == 'buy' and bollinger_signal == 'buy':
        if risk_management(current_day, balance, current_profit, daily_loss_limit, current_loss) == "sell":
            # Execute a sell trade
            balance += current_trade_profit
            print(f"Sold on {current_day}, new balance: {balance}")
        else:
            # Buy logic
            balance -= current_trade_amount
            print(f"Bought on {current_day}, new balance: {balance}")
    else:
        print(f"Held on {current_day}, balance: {balance}")

# Define RSI check function
def check_rsi(data):
    if pd.isna(data['RSI']):
        return 'hold'
    elif data['RSI'] < 30:
        return 'buy'
    elif data['RSI'] > 70:
        return 'sell'
    return 'hold'

# Define MACD check function
def check_macd(data):
    if pd.isna(data['MACD']):
        return 'hold'
    elif data['MACD'] > 0:
        return 'buy'
    elif data['MACD'] < 0:
        return 'sell'
    return 'hold'

# Define Bollinger Bands check function
def check_bollinger(data):
    if pd.isna(data['Bollinger_Lower']) or pd.isna(data['Bollinger_Upper']):
        return 'hold'
    elif data['Close'] < data['Bollinger_Lower']:
        return 'buy'
    elif data['Close'] > data['Bollinger_Upper']:
        return 'sell'
    return 'hold'

# Incorporating this into the main loop
for current_day in stock_data.index:
    # Calculate signals
    rsi_signal = check_rsi(stock_data.loc[current_day])
    macd_signal = check_macd(stock_data.loc[current_day])
    bollinger_signal = check_bollinger(stock_data.loc[current_day])

    # Logic for buying/selling or holding
    if rsi_signal == 'buy' and macd_signal == 'buy' and bollinger_signal == 'buy':
        action = risk_management(current_day, balance, current_profit, daily_loss_limit, current_loss)
        if action == "sell":
            balance += current_profit
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            balance -= current_trade_amount
            print(f"Bought on {current_day}, balance: {balance}")
    else:
        print(f"Held on {current_day}, balance: {balance}")

# Adjusted thresholds
def check_rsi(row):
    if row['RSI'] < 40:
        return 'buy'
    elif row['RSI'] > 60:
        return 'sell'
    else:
        return 'hold'

def check_macd(row):
    if row['MACD'] > 0:
        return 'buy'
    elif row['MACD'] < 0:
        return 'sell'
    else:
        return 'hold'

def check_bollinger(row):
    if row['Close'] < row['Bollinger_Lower']:
        return 'buy'
    elif row['Close'] > row['Bollinger_Upper']:
        return 'sell'
    else:
        return 'hold'

# Combine the signals and take action
def determine_action(rsi_signal, macd_signal, bollinger_signal):
    signals = [rsi_signal, macd_signal, bollinger_signal]
    buy_signals = signals.count('buy')
    sell_signals = signals.count('sell')

    if buy_signals >= 2:
        return 'buy'
    elif sell_signals >= 2:
        return 'sell'
    else:
        return 'hold'

# Initialize variables
balance = 200  # Starting balance
max_loss_per_day = 50
daily_loss = 0

for current_day in stock_data.index:
    rsi_signal = check_rsi(stock_data.loc[current_day])
    macd_signal = check_macd(stock_data.loc[current_day])
    bollinger_signal = check_bollinger(stock_data.loc[current_day])

    action = determine_action(rsi_signal, macd_signal, bollinger_signal)

    # Execute the trade based on the action
    if action == "buy" and daily_loss <

# Adjusted thresholds
def check_rsi(row):
    if row['RSI'] < 40:
        return 'buy'
    elif row['RSI'] > 60:
        return 'sell'
    else:
        return 'hold'

def check_macd(row):
    if row['MACD'] > 0:
        return 'buy'
    elif row['MACD'] < 0:
        return 'sell'
    else:
        return 'hold'

def check_bollinger(row):
    if row['Close'] < row['Bollinger_Lower']:
        return 'buy'
    elif row['Close'] > row['Bollinger_Upper']:
        return 'sell'
    else:
        return 'hold'

# Combine the signals and take action
def determine_action(rsi_signal, macd_signal, bollinger_signal):
    signals = [rsi_signal, macd_signal, bollinger_signal]
    buy_signals = signals.count('buy')
    sell_signals = signals.count('sell')

    if buy_signals >= 2:
        return 'buy'
    elif sell_signals >= 2:
        return 'sell'
    else:
        return 'hold'

# Initialize variables
balance = 200  # Starting balance
max_loss_per_day = 50
daily_loss = 0

for current_day in stock_data.index:
    rsi_signal = check_rsi(stock_data.loc[current_day])
    macd_signal = check_macd(stock_data.loc[current_day])
    bollinger_signal = check_bollinger(stock_data.loc[current_day])

    action = determine_action(rsi_signal, macd_signal, bollinger_signal)

    # Execute the trade based on the action
    if action == "buy" and daily_loss < max_loss_per_day:
        balance -= 5  # Buy with $5
        daily_loss += 5
        print(f"Bought on {current_day}, balance: {balance}")
    elif action == "sell":
        balance += 10  # Sell for profit (example)
        daily_loss -= 10
        print(f"Sold on {current_day}, balance: {balance}")
    else:
        print(f"Held on {current_day}, balance: {balance}")

    # Ensure stop-loss is enforced
    if daily_loss >= max_loss_per_day:
        print(f"Max loss reached for {current_day}, stopping trading for the day.")
        break

# Fine-tune the bot with updated conditions

def run_optimized_simulation(stock_data, initial_balance, max_daily_loss, take_profit_pct):
    balance = initial_balance
    current_day_profit = 0
    daily_loss = 0
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    current_trade_amount = 5  # Default trade amount per minute

    # Loop through each day in the stock data
    for current_day in stock_data.index:
        daily_data = stock_data.loc[current_day]

        # Extract signals for RSI, MACD, and Bollinger Bands
        rsi_signal = check_rsi(daily_data)
        macd_signal = check_macd(daily_data)
        bollinger_signal = check_bollinger(daily_data)

        # Combined signal logic: trade only if two or more indicators agree
        combined_signal = 'hold'
        signals = [rsi_signal, macd_signal, bollinger_signal]
        if signals.count('buy') >= 2:
            combined_signal = 'buy'
        elif signals.count('sell') >= 2:
            combined_signal = 'sell'

        # Take action based on combined signal
        if combined_signal == 'buy' and daily_loss < max_daily_loss:
            balance -= current_trade_amount
            current_day_profit += current_trade_amount * 0.05  # Simulating a 5% profit per trade
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")

        elif combined_signal == 'sell':
            balance += current_day_profit
            current_day_profit = 0  # Reset after selling
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")

        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        # Stop trading for the day if max loss is hit
        if daily_loss >= max_daily_loss:
            print(f"Max daily loss reached on {current_day}, stopping for the day.")
            break

    return balance, actions_taken

# Simulate with the optimized bot
initial_balance = 200
max_daily_loss = 50
take_profit_pct = 0.05

# Run the simulation with the fine-tuned logic
final_balance, actions_taken = run_optimized_simulation(stock_data_cleaned, initial_balance, max_daily_loss, take_profit_pct)

# Output results
print(f"Final Balance: {final_balance}")
print(f"Actions Taken: {actions_taken}")

# Function to check for RSI signals
def check_rsi(data):
    if data['RSI'] < 40:
        return 'buy'
    elif data['RSI'] > 60:
        return 'sell'
    return 'hold'

# Function to check for MACD signals
def check_macd(data):
    if data['MACD'] > 0:
        return 'buy'
    elif data['MACD'] < 0:
        return 'sell'
    return 'hold'

# Function to check Bollinger Bands signals
def check_bollinger(data):
    if data['Close'] < data['Bollinger_Lower']:
        return 'buy'
    elif data['Close'] > data['Bollinger_Upper']:
        return 'sell'
    return 'hold'

# Function to simulate trading logic with take-profit condition
def run_simulation_with_take_profit(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    current_trade_amount = 5
    current_profit = 0
    take_profit = None

    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        action = 'hold'

        # If two or more signals agree, take the action
        if rsi_signal == macd_signal == 'buy' or rsi_signal == bollinger_signal == 'buy' or macd_signal == bollinger_signal == 'buy':
            action = 'buy'
        elif rsi_signal == macd_signal == 'sell' or rsi_signal == bollinger_signal == 'sell' or macd_signal == bollinger_signal == 'sell':
            action = 'sell'

        # Check for take-profit
        if take_profit and stock_data['Close'][current_day] >= take_profit:
            action = 'sell'

        if action == 'buy' and daily_loss < max_daily_loss:
            balance -= current_trade_amount
            current_profit = current_trade_amount * (1 + take_profit_threshold)
            take_profit = stock_data['Close'][current_day] * (1 + take_profit_threshold)
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif action == 'sell':
            balance += current_profit
            current_profit = 0
            take_profit = None
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Running the simulation with the updated logic
final_balance, daily_balances, actions_taken = run_simulation_with_take_profit(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Adjusted thresholds and take-profit logic
def run_improved_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    current_trade_amount = 5
    current_profit = 0
    take_profit = None

    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        action = 'hold'

        # If two or more signals align, trigger action
        if rsi_signal == macd_signal == 'buy' or rsi_signal == bollinger_signal == 'buy' or macd_signal == bollinger_signal == 'buy':
            action = 'buy'
        elif rsi_signal == macd_signal == 'sell' or rsi_signal == bollinger_signal == 'sell' or macd_signal == bollinger_signal == 'sell':
            action = 'sell'

        # Take-profit logic
        if take_profit and stock_data['Close'][current_day] >= take_profit:
            action = 'sell'

        if action == 'buy' and daily_loss < max_daily_loss:
            balance -= current_trade_amount
            current_profit = current_trade_amount * (1 + take_profit_threshold)
            take_profit = stock_data['Close'][current_day] * (1 + take_profit_threshold)
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif action == 'sell':
            balance += current_profit
            current_profit = 0
            take_profit = None
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Running the improved simulation
final_balance, daily_balances, actions_taken = run_improved_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_refined_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    current_trade_amount = 5
    current_profit = 0
    take_profit = None

    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day], buy_threshold=40, sell_threshold=60)
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        action = 'hold'

        # Combine indicator signals for buy/sell decisions
        if rsi_signal == 'buy' and macd_signal == 'buy' and bollinger_signal == 'buy':
            action = 'buy'
        elif rsi_signal == 'sell' and macd_signal == 'sell' and bollinger_signal == 'sell':
            action = 'sell'

        # Take-profit logic
        if take_profit and stock_data['Close'][current_day] >= take_profit:
            action = 'sell'

        # Execute trade actions
        if action == 'buy' and daily_loss < max_daily_loss:
            balance -= current_trade_amount
            current_profit = current_trade_amount * (1 + take_profit_threshold)
            take_profit = stock_data['Close'][current_day] * (1 + take_profit_threshold)
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif action == 'sell':
            balance += current_profit
            current_profit = 0
            take_profit = None
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Running the refined simulation
final_balance, daily_balances, actions_taken = run_refined_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def check_rsi(daily_data):
    rsi_value = daily_data['RSI']
    if rsi_value < 40:
        return 'buy'
    elif rsi_value > 60:
        return 'sell'
    else:
        return 'hold'

def check_macd(daily_data):
    macd_value = daily_data['MACD']
    if macd_value > 0:
        return 'buy'
    elif macd_value < 0:
        return 'sell'
    else:
        return 'hold'

def check_bollinger(daily_data):
    close_price = daily_data['Close']
    lower_band = daily_data['Bollinger_Lower']
    upper_band = daily_data['Bollinger_Upper']

    if close_price < lower_band:
        return 'buy'
    elif close_price > upper_band:
        return 'sell'
    else:
        return 'hold'

# Now re-run the refined simulation with these helper functions
def run_refined_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    current_trade_amount = 5
    current_profit = 0
    take_profit = None

    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        action = 'hold'

        # Combine indicator signals for buy/sell decisions
        if rsi_signal == 'buy' and macd_signal == 'buy' and bollinger_signal == 'buy':
            action = 'buy'
        elif rsi_signal == 'sell' and macd_signal == 'sell' and bollinger_signal == 'sell':
            action = 'sell'

        # Take-profit logic
        if take_profit and stock_data['Close'][current_day] >= take_profit:
            action = 'sell'

        # Execute trade actions
        if action == 'buy' and daily_loss < max_daily_loss:
            balance -= current_trade_amount
            current_profit = current_trade_amount * (1 + take_profit_threshold)
            take_profit = stock_data['Close'][current_day] * (1 + take_profit_threshold)
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif action == 'sell':
            balance += current_profit
            current_profit = 0
            take_profit = None
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Running the refined simulation again
final_balance, daily_balances, actions_taken = run_refined_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def check_rsi(data, lower_threshold=30, upper_threshold=70):
    rsi_value = data['RSI']
    if rsi_value < lower_threshold:
        return "buy"
    elif rsi_value > upper_threshold:
        return "sell"
    return "hold"

def check_macd(data):
    macd_value = data['MACD']
    if macd_value > 0:
        return "buy"
    elif macd_value < 0:
        return "sell"
    return "hold"

def check_bollinger(data):
    close_price = data['Close']
    lower_band = data['Bollinger_Lower']
    upper_band = data['Bollinger_Upper']

    if close_price < lower_band:
        return "buy"
    elif close_price > upper_band:
        return "sell"
    return "hold"

# Combining signals logic
def get_combined_signal(rsi_signal, macd_signal, bollinger_signal):
    signals = [rsi_signal, macd_signal, bollinger_signal]
    buy_signals = signals.count("buy")
    sell_signals = signals.count("sell")

    # Take action if at least two of the three indicators agree
    if buy_signals >= 2:
        return "buy"
    elif sell_signals >= 2:
        return "sell"
    return "hold"

def run_refined_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    current_trade_amount = 5  # Fixed amount per trade
    actions_taken = {"buy": 0, "sell": 0, "hold": 0}
    daily_balances = []

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        action = get_combined_signal(rsi_signal, macd_signal, bollinger_signal)

        if action == "buy" and daily_loss < max_daily_loss:
            balance -= current_trade_amount
            actions_taken["buy"] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif action == "sell":
            # Example sell logic assuming we take profit at 5% of current_trade_amount
            profit = current_trade_amount * take_profit_threshold
            balance += current_trade_amount + profit
            actions_taken["sell"] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions_taken["hold"] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

    final_balance = balance
    return final_balance, daily_balances, actions_taken

# Now run the refined simulation with the updated thresholds
final_balance, daily_balances, actions_taken = run_refined_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_refined_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=1.05):
    balance = initial_balance
    daily_loss = 0
    trade_amount = balance * 0.05  # Dynamic trade amount: 5% of balance per trade
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day], buy_threshold=35, sell_threshold=60)
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Evaluate the actions
        if rsi_signal == 'buy' or macd_signal == 'buy' or bollinger_signal == 'buy':
            if daily_loss < max_daily_loss:
                balance -= trade_amount
                actions_taken['buy'] += 1
                print(f"Bought on {current_day}, balance: {balance}")
        elif rsi_signal == 'sell' or macd_signal == 'sell' or bollinger_signal == 'sell':
            balance += trade_amount * take_profit_threshold
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Run the refined simulation
final_balance, daily_balances, actions_taken = run_refined_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def check_rsi(daily_data):
    rsi = daily_data['RSI']
    if rsi < 35:
        return 'buy'
    elif rsi > 60:
        return 'sell'
    else:
        return 'hold'

def check_macd(daily_data):
    macd = daily_data['MACD']
    if macd > 0:
        return 'buy'
    elif macd < 0:
        return 'sell'
    else:
        return 'hold'

def check_bollinger(daily_data):
    close = daily_data['Close']
    lower_band = daily_data['Bollinger_Lower']
    upper_band = daily_data['Bollinger_Upper']
    if close <= lower_band:
        return 'buy'
    elif close >= upper_band:
        return 'sell'
    else:
        return 'hold'

def run_refined_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=1.05):
    balance = initial_balance
    daily_loss = 0
    trade_amount = balance * 0.05  # Dynamic trade amount: 5% of balance per trade
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Evaluate the actions
        if rsi_signal == 'buy' or macd_signal == 'buy' or bollinger_signal == 'buy':
            if daily_loss < max_daily_loss:
                balance -= trade_amount
                actions_taken['buy'] += 1
                print(f"Bought on {current_day}, balance: {balance}")
        elif rsi_signal == 'sell' or macd_signal == 'sell' or bollinger_signal == 'sell':
            balance += trade_amount * take_profit_threshold
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Run the refined simulation
final_balance, daily_balances, actions_taken = run_refined_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_refined_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=1.05):
    balance = initial_balance
    daily_loss = 0
    trade_amount = balance * 0.05  # 5% of balance per trade
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    last_buy_price = None

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Stop trading for the day if losses exceed max_daily_loss
        if daily_loss >= max_daily_loss:
            print(f"Max daily loss reached. No further trades on {current_day}.")
            daily_balances.append(balance)
            continue

        # If any indicator suggests a 'buy' and losses are below the limit
        if (rsi_signal == 'buy' or macd_signal == 'buy' or bollinger_signal == 'buy') and balance >= trade_amount:
            balance -= trade_amount
            actions_taken['buy'] += 1
            last_buy_price = stock_data.loc[current_day]['Close']
            print(f"Bought on {current_day}, balance: {balance}")

        # If any indicator suggests a 'sell' and we have made a profit
        elif (rsi_signal == 'sell' or macd_signal == 'sell' or bollinger_signal == 'sell') and last_buy_price:
            profit = trade_amount * take_profit_threshold
            balance += profit
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
            last_buy_price = None  # Reset after selling

        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

        # Track daily losses
        daily_loss = initial_balance - balance

    return balance, daily_balances, actions_taken

# Run the updated simulation
final_balance, daily_balances, actions_taken = run_refined_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_refined_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=1.05):
    balance = initial_balance
    daily_loss = 0
    trade_amount = balance * 0.05  # 5% of balance per trade
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    last_buy_price = None

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Stop trading if daily loss exceeds limit
        if daily_loss >= max_daily_loss:
            print(f"Max daily loss reached. No further trades on {current_day}.")
            daily_balances.append(balance)
            continue

        # Buy if at least 2 indicators signal buy
        buy_signal = sum([rsi_signal == 'buy', macd_signal == 'buy', bollinger_signal == 'buy'])
        sell_signal = sum([rsi_signal == 'sell', macd_signal == 'sell', bollinger_signal == 'sell'])

        if buy_signal >= 2 and balance >= trade_amount:
            balance -= trade_amount
            actions_taken['buy'] += 1
            last_buy_price = stock_data.loc[current_day]['Close']
            print(f"Bought on {current_day}, balance: {balance}")

        # Sell if 2 indicators signal sell or price meets profit threshold
        elif sell_signal >= 2 or (last_buy_price and stock_data.loc[current_day]['Close'] >= last_buy_price * take_profit_threshold):
            profit = trade_amount * take_profit_threshold
            balance += profit
            actions_taken['sell'] += 1
            last_buy_price = None  # Reset after selling
            print(f"Sold on {current_day}, balance: {balance}")

        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

        # Update daily loss
        daily_loss = initial_balance - balance

    return balance, daily_balances, actions_taken

# Run the refined simulation
final_balance, daily_balances, actions_taken = run_refined_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

def run_optimized_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=1.03):
    balance = initial_balance
    daily_loss = 0
    trade_amount = balance * 0.05  # 5% of balance per trade
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    last_buy_price = None

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day], buy_threshold=40, sell_threshold=60)
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Stop trading if daily loss exceeds limit
        if daily_loss >= max_daily_loss:
            print(f"Max daily loss reached. No further trades on {current_day}.")
            daily_balances.append(balance)
            continue

        # Buy if at least 2 indicators signal buy
        buy_signal = sum([rsi_signal == 'buy', macd_signal == 'buy', bollinger_signal == 'buy'])
        sell_signal = sum([rsi_signal == 'sell', macd_signal == 'sell', bollinger_signal == 'sell'])

        if buy_signal >= 2 and balance >= trade_amount:
            balance -= trade_amount
            actions_taken['buy'] += 1
            last_buy_price = stock_data.loc[current_day]['Close']
            print(f"Bought on {current_day}, balance: {balance}")

        # Sell if 2 indicators signal sell or price meets profit threshold
        elif sell_signal >= 2 or (last_buy_price and stock_data.loc[current_day]['Close'] >= last_buy_price * take_profit_threshold):
            profit = trade_amount * take_profit_threshold
            balance += profit
            actions_taken['sell'] += 1
            last_buy_price = None  # Reset after selling
            print(f"Sold on {current_day}, balance: {balance}")

        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

        # Update daily loss
        daily_loss = initial_balance - balance

    return balance, daily_balances, actions_taken

# Running the optimized simulation
final_balance, daily_balances, actions_taken = run_optimized_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Define the RSI, MACD, and Bollinger Band thresholds within the function
def run_optimized_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=1.03):
    balance = initial_balance
    daily_loss = 0
    trade_amount = balance * 0.05  # 5% of balance per trade
    daily_balances = []
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    last_buy_price = None

    for current_day in stock_data.index:
        # Use fixed RSI buy and sell thresholds directly inside the check function
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Stop trading if daily loss exceeds limit
        if daily_loss >= max_daily_loss:
            print(f"Max daily loss reached. No further trades on {current_day}.")
            daily_balances.append(balance)
            continue

        # Buy if at least 2 indicators signal buy
        buy_signal = sum([rsi_signal == 'buy', macd_signal == 'buy', bollinger_signal == 'buy'])
        sell_signal = sum([rsi_signal == 'sell', macd_signal == 'sell', bollinger_signal == 'sell'])

        if buy_signal >= 2 and balance >= trade_amount:
            balance -= trade_amount
            actions_taken['buy'] += 1
            last_buy_price = stock_data.loc[current_day]['Close']
            print(f"Bought on {current_day}, balance: {balance}")

        # Sell if 2 indicators signal sell or price meets profit threshold
        elif sell_signal >= 2 or (last_buy_price and stock_data.loc[current_day]['Close'] >= last_buy_price * take_profit_threshold):
            profit = trade_amount * take_profit_threshold
            balance += profit
            actions_taken['sell'] += 1
            last_buy_price = None  # Reset after selling
            print(f"Sold on {current_day}, balance: {balance}")

        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        daily_balances.append(balance)

        # Update daily loss
        daily_loss = initial_balance - balance

    return balance, daily_balances, actions_taken

# Running the optimized simulation
final_balance, daily_balances, actions_taken = run_optimized_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

# Applying the final refinements to the trading bot and running the optimized simulation
# Using the refined thresholds and logic for RSI, MACD, and Bollinger Bands

def run_optimized_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    actions = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []
    current_trade_amount = 10  # Each trade $10

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day], buy_threshold=40, sell_threshold=60)
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Determine combined action based on indicators
        if rsi_signal == 'buy' and macd_signal == 'buy' and bollinger_signal == 'buy':
            action = "buy"
        elif rsi_signal == 'sell' and macd_signal == 'sell' and bollinger_signal == 'sell':
            action = "sell"
        else:
            action = "hold"

        if action == "buy" and daily_loss < max_daily_loss:
            balance -= current_trade_amount
            actions['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif action == "sell":
            profit = current_trade_amount * (1 + take_profit_threshold)  # Assuming a 5% take-profit level
            balance += profit
            actions['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        # Track daily balance
        daily_balances.append(balance)

        # Stop trading if max daily loss reached
        if balance <= (initial_balance - max_daily_loss):
            print(f"Max daily loss reached. No further trades on {current_day}.")
            break

    return balance, daily_balances, actions

# Running the simulation with final refinements
final_balance, daily_balances, actions_taken = run_optimized_simulation(stock_data_cleaned)

# Displaying the results
final_balance, daily_balances[:10], actions_taken

# Refined trading simulation without passing thresholds directly to the RSI function
def run_optimized_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    actions = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []
    current_trade_amount = 10  # Each trade $10

    for current_day in stock_data.index:
        # Directly use RSI, MACD, and Bollinger logic without passing thresholds
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Refined logic for actions based on indicators
        if rsi_signal == 'buy' and macd_signal == 'buy' and bollinger_signal == 'buy':
            action = "buy"
        elif rsi_signal == 'sell' and macd_signal == 'sell' and bollinger_signal == 'sell':
            action = "sell"
        else:
            action = "hold"

        if action == "buy" and daily_loss < max_daily_loss:
            balance -= current_trade_amount
            actions['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif action == "sell":
            profit = current_trade_amount * (1 + take_profit_threshold)  # Assuming a 5% take-profit level
            balance += profit
            actions['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            actions['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        # Track daily balance
        daily_balances.append(balance)

        # Stop trading if max daily loss reached
        if balance <= (initial_balance - max_daily_loss):
            print(f"Max daily loss reached. No further trades on {current_day}.")
            break

    return balance, daily_balances, actions

# Running the simulation with final refinements
final_balance, daily_balances, actions_taken = run_optimized_simulation(stock_data_cleaned)

# Displaying the results
final_balance, daily_balances[:10], actions_taken

# Run the aggressive simulation with the new buy/sell thresholds and stop-loss
def run_aggressive_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    previous_close = None
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []

    for current_day in stock_data.index:
        rsi_signal = check_rsi(stock_data.loc[current_day])  # No threshold passed here
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])
        current_close = stock_data.loc[current_day, 'Close']

        # Check the sell conditions (MACD, RSI, and Bollinger)
        if rsi_signal == 'sell' or macd_signal == 'sell' or bollinger_signal == 'sell':
            actions_taken['sell'] += 1
            if previous_close:
                current_profit = (current_close - previous_close) * 5  # Simulating a small sell with fractional shares
                balance += current_profit
                print(f"Sold on {current_day}, balance: {balance}")
        # Check the buy conditions (RSI < 35 or MACD cross with confirmation)
        elif rsi_signal == 'buy' and daily_loss < max_daily_loss:
            actions_taken['buy'] += 1
            daily_loss += (previous_close - current_close) * 5 if previous_close else 0
            balance -= 5  # Buy $5 worth of stock (fractional shares)
            print(f"Bought on {current_day}, balance: {balance}")
        else:
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        previous_close = current_close
        daily_balances.append(balance)

    return balance, daily_balances, actions_taken

# Run the final aggressive simulation
final_balance, daily_balances, actions_taken = run_aggressive_simulation(stock_data_cleaned)

# Display the results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

import numpy as np

# Function to run the extended simulation with reinforcement learning tracking
def run_extended_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []
    learning_feedback = []
    max_loss_per_day = max_daily_loss
    profit_scaler = take_profit_threshold

    for current_day in stock_data.index:
        current_price = stock_data.loc[current_day, 'Close']

        # Calculate signals from indicators (adjusted for learning)
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Determine the AI's action based on the learned behavior
        if rsi_signal == 'buy' and macd_signal == 'buy' and bollinger_signal == 'buy' and daily_loss < max_loss_per_day:
            # Buy condition met, make a trade
            balance -= 5  # Simulate a buy at $5
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif rsi_signal == 'sell' and macd_signal == 'sell' and bollinger_signal == 'sell':
            # Sell condition met, take profit
            current_profit = balance * profit_scaler
            balance += current_profit
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            # Hold position
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        # Update the learning feedback for each day
        daily_balances.append(balance)
        feedback = f"Day: {current_day}, Balance: {balance}, Actions: {actions_taken}"
        learning_feedback.append(feedback)

        # Stop further trading if the daily loss exceeds max allowable loss
        if daily_loss >= max_loss_per_day:
            print(f"Max daily loss reached. No further trades on {current_day}.")

    # Return the final balance, daily balances, and the feedback
    return balance, daily_balances, actions_taken, learning_feedback

# Running the extended simulation for learning
final_balance, daily_balances, actions_taken, learning_feedback = run_extended_simulation(stock_data_cleaned)

# Display the final results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

import numpy as np

# Function to run the simulation with more flexible thresholds
def run_adjusted_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []
    max_loss_per_day = max_daily_loss
    profit_scaler = take_profit_threshold

    for current_day in stock_data.index:
        current_price = stock_data.loc[current_day, 'Close']

        # Calculate signals with relaxed thresholds
        rsi_signal = check_rsi(stock_data.loc[current_day], buy_threshold=45, sell_threshold=55)
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Determine the AI's action based on signals
        if rsi_signal == 'buy' and macd_signal == 'buy' and bollinger_signal == 'buy' and daily_loss < max_loss_per_day:
            # Buy condition met, make a trade
            balance -= 5  # Simulate a buy at $5
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif rsi_signal == 'sell' and macd_signal == 'sell' and bollinger_signal == 'sell':
            # Sell condition met, take profit
            current_profit = balance * profit_scaler
            balance += current_profit
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            # Hold position
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        # Update daily balances and stop further trading if the daily loss exceeds the limit
        daily_balances.append(balance)
        if daily_loss >= max_loss_per_day:
            print(f"Max daily loss reached. No further trades on {current_day}.")

    # Return the final balance, daily balances, and actions taken
    return balance, daily_balances, actions_taken

# Running the adjusted simulation
final_balance, daily_balances, actions_taken = run_adjusted_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

import numpy as np

# Adjusted RSI function
def check_rsi(data_row):
    rsi_value = data_row['RSI']
    if rsi_value < 45:
        return 'buy'
    elif rsi_value > 55:
        return 'sell'
    else:
        return 'hold'

# Adjusted MACD function (assuming a similar logic)
def check_macd(data_row):
    macd_value = data_row['MACD']
    if macd_value > 0:
        return 'buy'
    elif macd_value < 0:
        return 'sell'
    else:
        return 'hold'

# Adjusted Bollinger Bands function (assuming a similar logic)
def check_bollinger(data_row):
    lower_band = data_row['Bollinger Lower']
    upper_band = data_row['Bollinger Upper']
    current_price = data_row['Close']

    if current_price < lower_band:
        return 'buy'
    elif current_price > upper_band:
        return 'sell'
    else:
        return 'hold'

# Function to run the simulation with more flexible thresholds
def run_adjusted_simulation(stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=0.05):
    balance = initial_balance
    daily_loss = 0
    actions_taken = {'buy': 0, 'sell': 0, 'hold': 0}
    daily_balances = []
    max_loss_per_day = max_daily_loss
    profit_scaler = take_profit_threshold

    for current_day in stock_data.index:
        current_price = stock_data.loc[current_day, 'Close']

        # Calculate signals with relaxed thresholds
        rsi_signal = check_rsi(stock_data.loc[current_day])
        macd_signal = check_macd(stock_data.loc[current_day])
        bollinger_signal = check_bollinger(stock_data.loc[current_day])

        # Determine the AI's action based on signals
        if rsi_signal == 'buy' and macd_signal == 'buy' and bollinger_signal == 'buy' and daily_loss < max_loss_per_day:
            # Buy condition met, make a trade
            balance -= 5  # Simulate a buy at $5
            actions_taken['buy'] += 1
            print(f"Bought on {current_day}, balance: {balance}")
        elif rsi_signal == 'sell' and macd_signal == 'sell' and bollinger_signal == 'sell':
            # Sell condition met, take profit
            current_profit = balance * profit_scaler
            balance += current_profit
            actions_taken['sell'] += 1
            print(f"Sold on {current_day}, balance: {balance}")
        else:
            # Hold position
            actions_taken['hold'] += 1
            print(f"Held on {current_day}, balance: {balance}")

        # Update daily balances and stop further trading if the daily loss exceeds the limit
        daily_balances.append(balance)
        if daily_loss >= max_loss_per_day:
            print(f"Max daily loss reached. No further trades on {current_day}.")

    # Return the final balance, daily balances, and actions taken
    return balance, daily_balances, actions_taken

# Running the adjusted simulation
final_balance, daily_balances, actions_taken = run_adjusted_simulation(stock_data_cleaned)

# Display results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

import pandas as pd

# Calculate Bollinger Bands
def calculate_bollinger_bands(data, window=20, num_std_dev=2):
    # Calculate moving average and standard deviation
    rolling_mean = data['Close'].rolling(window).mean()
    rolling_std = data['Close'].rolling(window).std()

    # Calculate upper and lower Bollinger Bands
    data['Bollinger Upper'] = rolling_mean + (rolling_std * num_std_dev)
    data['Bollinger Lower'] = rolling_mean - (rolling_std * num_std_dev)
    return data

# Adjusted Bollinger Bands function (assuming a similar logic)
def check_bollinger(data_row):
    if 'Bollinger Lower' in data_row and 'Bollinger Upper' in data_row:
        lower_band = data_row['Bollinger Lower']
        upper_band = data_row['Bollinger Upper']
        current_price = data_row['Close']

        if current_price < lower_band:
            return 'buy'
        elif current_price > upper_band:
            return 'sell'
        else:
            return 'hold'
    return 'hold'

# Assuming stock_data_cleaned is your dataset
# Ensure Bollinger Bands are calculated before running the simulation
stock_data_cleaned = calculate_bollinger_bands(stock_data_cleaned)

# Running the adjusted simulation after calculating Bollinger Bands
final_balance, daily_balances, actions_taken = run_adjusted_simulation(stock_data_cleaned)

# Displaying the results
print(f"Final Balance: {final_balance}")
print(f"Daily Balances (First 10 Days): {daily_balances[:10]}")
print(f"Actions Taken: {actions_taken}")

import numpy as np
import pandas as pd

# Define the environment variables for the Q-learning
class TradingEnv:
    def __init__(self, stock_data, initial_balance=200, max_daily_loss=50, take_profit_threshold=5):
        self.stock_data = stock_data
        self.initial_balance = initial_balance
        self.balance = initial_balance
        self.max_daily_loss = max_daily_loss
        self.take_profit_threshold = take_profit_threshold
        self.current_day = 0
        self.total_profit = 0
        self.daily_loss = 0

        self.actions = ['buy', 'sell', 'hold']  # Action space for Q-learning
        self.q_table = {}  # Q-table for storing state-action values
        self.epsilon = 0.1  # Exploration rate
        self.learning_rate = 0.01  # Learning rate
        self.discount_factor = 0.99  # Discount factor for future rewards

    def reset(self):
        self.balance = self.initial_balance
        self.current_day = 0
        self.daily_loss = 0
        self.total_profit = 0
        return self.stock_data.iloc[0]

    def step(self, action):
        state = self.stock_data.iloc[self.current_day]
        reward = 0
        done = False

        # Action logic
        if action == 'buy' and self.daily_loss < self.max_daily_loss:
            self.balance -= 5  # Fixed amount to buy
            reward = 1  # Small positive reward for buying
        elif action == 'sell':
            profit = 5 * (1 + self.take_profit_threshold / 100)
            self.balance += profit  # Simulate profit from selling
            self.total_profit += profit - 5
            reward = 10  # Positive reward for selling
        elif action == 'hold':
            reward = 0  # Neutral reward for holding

        # Penalty for exceeding max loss
        if self.daily_loss >= self.max_daily_loss:
            reward = -10  # Penalty for losing too much in a day

        # Transition to next day
        self.current_day += 1

        if self.current_day >= len(self.stock_data) - 1:
            done = True  # End of the episode

        next_state = self.stock_data.iloc[self.current_day] if not done else None
        return next_state, reward, done

    def get_q_value(self, state, action):
        return self.q_table.get((state.name, action), 0)

    def update_q_table(self, state, action, reward, next_state):
        best_next_q = max([self.get_q_value(next_state, a) for a in self.actions]) if next_state is not None else 0
        current_q = self.get_q_value(state, action)
        new_q = (1 - self.learning_rate) * current_q + self.learning_rate * (reward + self.discount_factor * best_next_q)
        self.q_table[(state.name, action)] = new_q

    def choose_action(self, state):
        if np.random.rand() < self.epsilon:
            return np.random.choice(self.actions)  # Explore
        else:
            q_values = [self.get_q_value(state, a) for a in self.actions]
            return self.actions[np.argmax(q_values)]  # Exploit

def run_q_learning_simulation(stock_data, episodes=20):
    env = TradingEnv(stock_data)

    for episode in range(episodes):
        state = env.reset()
        done = False

        while not done:
            action = env.choose_action(state)
            next_state, reward, done = env.step(action)
            env.update_q_table(state, action, reward, next_state)
            state = next_state

    return env.balance, env.total_profit, env.q_table


# Sample stock data for testing
simplified_stock_data_cleaned = pd.DataFrame({
    'Date': pd.date_range(start="2023-01-01", periods=40, freq='D'),
    'Close': np.linspace(100, 140, 40)  # Simulating a stock price increase
}).set_index('Date')

# Running the simplified Q-learning simulation
final_balance, total_profit, q_table = run_q_learning_simulation(simplified_stock_data_cleaned, episodes=50)

print(f"Final Balance: {final_balance}")
print(f"Total Profit: {total_profit}")

import numpy as np

# Updated Q-learning parameters
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 1.0  # Exploration rate
min_epsilon = 0.01  # Minimum exploration rate
decay_rate = 0.995  # Exploration decay

# Increasing episodes for more learning opportunities
episodes = 1000  # Number of training episodes
total_steps = 0

# Rewards and penalties
profit_reward = 10  # Reward for profit
loss_penalty = -20  # Penalty for exceeding daily loss limit

# Q-table initialization (adjusting for new indicators)
q_table = np.zeros((len(stock_data), 3))  # 3 actions: buy, sell, hold

for episode in range(episodes):
    state = stock_data.index[0]  # Start from the first day
    balance = 200  # Reset balance
    daily_loss = 0
    done = False

    while not done:
        # Epsilon-greedy action selection
        if np.random.uniform(0, 1) < epsilon:
            action = np.random.randint(0, 3)  # Explore
        else:
            action = np.argmax(q_table[state])  # Exploit

        next_state = state + 1
        if next_state >= len(stock_data):
            done = True
            break

        # Calculate rewards and penalties based on the action taken
        reward = 0
        if action == 0:  # Buy
            reward = -1  # Small penalty for buying to encourage careful actions
        elif action == 1:  # Sell
            current_profit = calculate_profit(stock_data.loc[next_state])
            reward = profit_reward if current_profit > 0 else loss_penalty
        else:  # Hold
            reward = 1  # Small reward for holding when market is uncertain

        # Update Q-value
        old_q_value = q_table[state, action]
        future_q_value = np.max(q_table[next_state])
        q_table[state, action] = old_q_value + alpha * (reward + gamma * future_q_value - old_q_value)

        state = next_state
        total_steps += 1

    # Decay exploration rate
    if epsilon > min_epsilon:
        epsilon *= decay_rate

# Test the trained Q-learning agent on a final run
final_balance, total_profit = run_qlearning_strategy(stock_data_cleaned, q_table)

print(f"Final Balance: {final_balance}")
print(f"Total Profit: {total_profit}")

import yfinance as yf

# Example: downloading data for AAPL stock from the past year
ticker = "AAPL"
stock_data = yf.download(ticker, start="2023-01-01", end="2024-01-01")

# Cleaning the data
stock_data_cleaned = stock_data.dropna()

# Resetting the index for convenience
stock_data_cleaned = stock_data_cleaned.reset_index()

import numpy as np

# Updated Q-learning parameters
alpha = 0.1  # Learning rate
gamma = 0.95  # Discount factor
epsilon = 1.0  # Exploration rate
min_epsilon = 0.01  # Minimum exploration rate
decay_rate = 0.995  # Exploration decay

# Increasing episodes for more learning opportunities
episodes = 1000  # Number of training episodes
total_steps = 0

# Rewards and penalties
profit_reward = 10  # Reward for profit
loss_penalty = -20  # Penalty for exceeding daily loss limit

# Q-table initialization (adjusting for new indicators)
q_table = np.zeros((len(stock_data_cleaned), 3))  # 3 actions: buy, sell, hold

for episode in range(episodes):
    state = 0  # Start from the first day
    balance = 200  # Reset balance
    daily_loss = 0
    done = False

    while not done:
        # Epsilon-greedy action selection
        if np.random.uniform(0, 1) < epsilon:
            action = np.random.randint(0, 3)  # Explore
        else:
            action = np.argmax(q_table[state])  # Exploit

        next_state = state + 1
        if next_state >= len(stock_data_cleaned):
            done = True
            break

        # Calculate rewards and penalties based on the action taken
        reward = 0
        if action == 0:  # Buy
            reward = -1  # Small penalty for buying to encourage careful actions
        elif action == 1:  # Sell
            current_profit = calculate_profit(stock_data_cleaned.loc[next_state])
            reward = profit_reward if current_profit > 0 else loss_penalty
        else:  # Hold
            reward = 1  # Small reward for holding when market is uncertain

        # Update Q-value
        old_q_value = q_table[state, action]
        future_q_value = np.max(q_table[next_state])
        q_table[state, action] = old_q_value + alpha * (reward + gamma * future_q_value - old_q_value)

        state = next_state
        total_steps += 1

    # Decay exploration rate
    if epsilon > min_epsilon:
        epsilon *= decay_rate

# Test the trained Q-learning agent on a final run
final_balance, total_profit = run_qlearning_strategy(stock_data_cleaned, q_table)

print(f"Final Balance: {final_balance}")
print(f"Total Profit: {total_profit}")

def calculate_profit(data_row):
    # Example: Calculate profit based on the stock's closing price difference
    # We assume you bought at a lower price and sold at a higher price for a profit
    # You can modify this function based on your actual buying/selling logic.
    close_price = data_row['Close']
    # Assuming a previous buying price of $200
    buying_price = 200
    return close_price - buying_price

import numpy as np
import pandas as pd

# Assuming stock_data_cleaned is your processed DataFrame

# Define calculate_profit function
def calculate_profit(data_row):
    close_price = data_row['Close']
    buying_price = 200  # Example buying price
    return close_price - buying_price

# Initialize Q-table (for 3 actions: buy, sell, hold)
q_table = np.zeros((len(stock_data_cleaned), 3))

# Parameters for Q-learning
alpha = 0.1   # Learning rate
gamma = 0.95  # Discount factor
epsilon = 0.1 # Exploration rate
episodes = 100

# Profit and loss reward system
profit_reward = 10
loss_penalty = -10

# Run Q-learning
for episode in range(episodes):
    state = 0  # Starting state (first day)
    balance = 200  # Initial balance

    while state < len(stock_data_cleaned) - 1:
        if np.random.rand() < epsilon:
            action = np.random.choice([0, 1, 2])  # Explore: randomly choose action (buy, sell, hold)
        else:
            action = np.argmax(q_table[state])  # Exploit: choose the best action from Q-table

        # Move to the next state (next day)
        next_state = state + 1

        # Execute action
        if action == 0:  # Buy
            reward = -1  # Small penalty for buying to encourage careful actions
        elif action == 1:  # Sell
            current_profit = calculate_profit(stock_data_cleaned.loc[next_state])
            reward = profit_reward if current_profit > 0 else loss_penalty
        else:  # Hold
            reward = 0  # No profit or loss for holding

        # Update Q-value using the Q-learning update rule
        old_q_value = q_table[state, action]
        best_next_q = np.max(q_table[next_state])  # Max Q-value for the next state
        new_q_value = (1 - alpha) * old_q_value + alpha * (reward + gamma * best_next_q)
        q_table[state, action] = new_q_value

        # Move to the next state
        state = next_state

    # Reduce exploration over time
    epsilon *= 0.99

# Final simulation results
final_balance = balance
print(f"Final Balance: {final_balance}")

import numpy as np
import pandas as pd

# Assuming stock_data_cleaned is your processed DataFrame

# Define calculate_profit function
def calculate_profit(buy_price, sell_price):
    return sell_price - buy_price

# Initialize Q-table (for 3 actions: buy, sell, hold)
q_table = np.zeros((len(stock_data_cleaned), 3))

# Parameters for Q-learning
alpha = 0.1   # Learning rate
gamma = 0.95  # Discount factor
epsilon = 0.1 # Exploration rate
episodes = 100

# Profit and loss reward system
profit_reward = 10
loss_penalty = -10

# Initial balance and transaction variables
initial_balance = 200
balance = initial_balance
buy_price = None  # To store buy price for calculating profits
trading_history = []

# Run Q-learning
for episode in range(episodes):
    state = 0  # Starting state (first day)
    balance = initial_balance  # Reset balance at the start of each episode

    while state < len(stock_data_cleaned) - 1:
        if np.random.rand() < epsilon:
            action = np.random.choice([0, 1, 2])  # Explore: randomly choose action (buy, sell, hold)
        else:
            action = np.argmax(q_table[state])  # Exploit: choose the best action from Q-table

        # Move to the next state (next day)
        next_state = state + 1

        # Execute action
        if action == 0:  # Buy
            if balance >= 5:  # Can only buy if there's enough balance
                buy_price = stock_data_cleaned.loc[state, 'Close']
                balance -= 5  # Deduct $5 from balance for each trade
                reward = -1  # Small penalty for buying to encourage careful actions
                trading_history.append(f"Bought at {buy_price}, Balance: {balance}")
            else:
                reward = -5  # Penalty if trying to buy without sufficient funds
        elif action == 1 and buy_price is not None:  # Sell (only if previously bought)
            sell_price = stock_data_cleaned.loc[state, 'Close']
            profit = calculate_profit(buy_price, sell_price)
            balance += 5 + profit  # Add the profit and return the $5 stake
            buy_price = None  # Reset buy price
            reward = profit_reward if profit > 0 else loss_penalty
            trading_history.append(f"Sold at {sell_price}, Profit: {profit}, Balance: {balance}")
        else:  # Hold
            reward = 0  # No profit or loss for holding

        # Update Q-value using the Q-learning update rule
        old_q_value = q_table[state, action]
        best_next_q = np.max(q_table[next_state])  # Max Q-value for the next state
        new_q_value = (1 - alpha) * old_q_value + alpha * (reward + gamma * best_next_q)
        q_table[state, action] = new_q_value

        # Move to the next state
        state = next_state

    # Reduce exploration over time
    epsilon *= 0.99

# Final simulation results
final_balance = balance
print(f"Final Balance: {final_balance}")
print(f"Trading History: {trading_history}")

import pandas as pd
import yfinance as yf

# Simulating multi-day trading over a chosen period
# Fetch data for a list of top stocks
tickers = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN"]  # Replace with your top 25 tickers
data = {}
for ticker in tickers:
    stock_data = yf.download(ticker, period='60d', interval='1m')
    data[ticker] = stock_data

# Parameters for simulation
initial_capital = 200
daily_loss_limit = -50
daily_profit = 0
trade_amount = 5
max_loss_per_trade = 5
profit_scaling_factor = 1.05  # Adjust to increase profits
current_balance = initial_capital

# Sample result log
daily_results = []
for day in range(1, 61):  # Simulating over 60 days
    daily_profit = 0
    print(f"Day {day} Trading Simulation Start")

    # Simulate trading minute-by-minute for each stock
    for ticker, stock_data in data.items():
        for time, row in stock_data.iterrows():
            price = row['Close']

            # Check buy/sell conditions based on RSI, MACD, and Bollinger Bands
            signal = generate_signal(row)  # Placeholder for your buy/sell logic

            if signal == "BUY" and current_balance >= trade_amount:
                # Execute buy trade
                shares = trade_amount / price
                current_balance -= trade_amount
                print(f"Bought {shares} shares of {ticker} at ${price}")

            elif signal == "SELL" and current_balance <= initial_capital + daily_profit:
                # Execute sell trade
                current_balance += trade_amount * profit_scaling_factor
                print(f"Sold shares of {ticker} at ${price}")
                daily_profit += trade_amount * profit_scaling_factor - trade_amount

            # Implement stop-loss or daily loss limit
            if daily_profit <= daily_loss_limit:
                print("Hit daily loss limit. Stopping trades for today.")
                break

    daily_results.append({'Day': day, 'Profit': daily_profit})
    print(f"Day {day} End - Profit: {daily_profit}")

# Convert daily results to DataFrame
results_df = pd.DataFrame(daily_results)

# Display results of the multi-day test
import ace_tools as tools; tools.display_dataframe_to_user(name="Multi-Day Test Results", dataframe=results_df)

# Log results
results_df.to_csv('multi_day_test_results.csv')

# Define RSI calculation
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

# Define MACD calculation
def calculate_macd(data):
    exp1 = data['Close'].ewm(span=12, adjust=False).mean()
    exp2 = data['Close'].ewm(span=26, adjust=False).mean()
    macd = exp1 - exp2
    signal = macd.ewm(span=9, adjust=False).mean()
    hist = macd - signal
    return macd, signal, hist

# Define Bollinger Bands calculation
def calculate_bollinger_bands(data, window=20, num_std=2):
    sma = data['Close'].rolling(window=window).mean()
    std = data['Close'].rolling(window=window).std()
    upper_band = sma + (std * num_std)
    lower_band = sma - (std * num_std)
    return upper_band, lower_band

import pandas as pd
import yfinance as yf
import numpy as np
import random

# Simulating multi-day trading with RL adjustments
tickers = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN"]  # Replace with your top 25 tickers
data = {}
for ticker in tickers:
    stock_data = yf.download(ticker, period='60d', interval='1m')
    data[ticker] = stock_data

# Parameters for simulation and RL
initial_capital = 200
daily_loss_limit = -50
trade_amount = 5
profit_scaling_factor = 1.05
current_balance = initial_capital

# Q-learning variables
q_table = {}
learning_rate = 0.1
discount_factor = 0.9
exploration_rate = 0.2

# Sample result log
daily_results = []

def generate_signal(row):
    """Placeholder for signal generation logic (RSI, MACD, Bollinger)."""
    # Simplified: Randomly generate a signal for testing purposes
    return random.choice(["BUY", "SELL", "HOLD"])

def update_q_table(state, action, reward, next_state):
    """Update the Q-value for the state-action pair."""
    if state not in q_table:
        q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
    old_value = q_table[state][action]
    next_max = max(q_table[next_state].values()) if next_state in q_table else 0
    new_value = old_value + learning_rate * (reward + discount_factor * next_max - old_value)
    q_table[state][action] = new_value

for day in range(1, 61):  # Simulating over 60 days
    daily_profit = 0
    print(f"Day {day} Trading Simulation Start")
    current_day_profit = 0

    # Simulate trading minute-by-minute for each stock
    for ticker, stock_data in data.items():
        for time, row in stock_data.iterrows():
            price = row['Close']

            # Generate signal based on technical indicators
            signal = generate_signal(row)  # Placeholder for your buy/sell logic

            # State representation (simplified for this example)
            state = (ticker, price)

            # Choose action (buy/sell/hold) - Explore or Exploit
            if random.uniform(0, 1) < exploration_rate:
                action = random.choice(["BUY", "SELL", "HOLD"])  # Explore
            else:
                action = max(q_table.get(state, {"BUY": 0, "SELL": 0, "HOLD": 0}), key=q_table.get)  # Exploit

            # Execute action
            if action == "BUY" and current_balance >= trade_amount:
                shares = trade_amount / price
                current_balance -= trade_amount
                print(f"Bought {shares} shares of {ticker} at ${price}")
                action_taken = "BUY"

            elif action == "SELL" and current_balance <= initial_capital + daily_profit:
                current_balance += trade_amount * profit_scaling_factor
                print(f"Sold shares of {ticker} at ${price}")
                daily_profit += trade_amount * profit_scaling_factor - trade_amount
                action_taken = "SELL"

            else:
                action_taken = "HOLD"

            # Reward or penalty based on the action
            reward = daily_profit if action_taken == "SELL" else -max_loss_per_trade if action_taken == "BUY" else 0

            # Simulate next state for learning
            next_state = (ticker, row['Close'])  # Using price as part of the state

            # Update Q-table
            update_q_table(state, action_taken, reward, next_state)

            # Implement stop-loss or daily loss limit
            if daily_profit <= daily_loss_limit:
                print("Hit daily loss limit. Stopping trades for today.")
                break

    daily_results.append({'Day': day, 'Profit': daily_profit})
    print(f"Day {day} End - Profit: {daily_profit}")

# Convert daily results to DataFrame
results_df = pd.DataFrame(daily_results)

# Display results of the multi-day test
import ace_tools as tools; tools.display_dataframe_to_user(name="RL Multi-Day Test Results", dataframe=results_df)

# Log results
results_df.to_csv('rl_multi_day_test_results.csv')

import pandas as pd
import yfinance as yf
import numpy as np
import random

# Simulating multi-day trading over daily data
tickers = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN"]  # Replace with your top 25 tickers
data = {}
for ticker in tickers:
    stock_data = yf.download(ticker, period='60d', interval='1d')  # Using daily data instead of 1m
    data[ticker] = stock_data

# Parameters for simulation and RL
initial_capital = 200
daily_loss_limit = -50
trade_amount = 5
profit_scaling_factor = 1.05
current_balance = initial_capital

# Q-learning variables
q_table = {}
learning_rate = 0.1
discount_factor = 0.9
exploration_rate = 0.2

# Sample result log
daily_results = []

def generate_signal(row):
    """Placeholder for signal generation logic (RSI, MACD, Bollinger)."""
    # Simplified: Randomly generate a signal for testing purposes
    return random.choice(["BUY", "SELL", "HOLD"])

def update_q_table(state, action, reward, next_state):
    """Update the Q-value for the state-action pair."""
    if state not in q_table:
        q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
    old_value = q_table[state][action]
    next_max = max(q_table[next_state].values()) if next_state in q_table else 0
    new_value = old_value + learning_rate * (reward + discount_factor * next_max - old_value)
    q_table[state][action] = new_value

for day in range(1, 61):  # Simulating over 60 days
    daily_profit = 0
    print(f"Day {day} Trading Simulation Start")
    current_day_profit = 0

    # Simulate trading day-by-day for each stock
    for ticker, stock_data in data.items():
        for time, row in stock_data.iterrows():
            price = row['Close']

            # Generate signal based on technical indicators
            signal = generate_signal(row)  # Placeholder for your buy/sell logic

            # State representation (simplified for this example)
            state = (ticker, price)

            # Choose action (buy/sell/hold) - Explore or Exploit
            if random.uniform(0, 1) < exploration_rate:
                action = random.choice(["BUY", "SELL", "HOLD"])  # Explore
            else:
                action = max(q_table.get(state, {"BUY": 0, "SELL": 0, "HOLD": 0}), key=q_table.get)  # Exploit

            # Execute action
            if action == "BUY" and current_balance >= trade_amount:
                shares = trade_amount / price
                current_balance -= trade_amount
                print(f"Bought {shares} shares of {ticker} at ${price}")
                action_taken = "BUY"

            elif action == "SELL" and current_balance <= initial_capital + daily_profit:
                current_balance += trade_amount * profit_scaling_factor
                print(f"Sold shares of {ticker} at ${price}")
                daily_profit += trade_amount * profit_scaling_factor - trade_amount
                action_taken = "SELL"

            else:
                action_taken = "HOLD"

            # Reward or penalty based on the action
            reward = daily_profit if action_taken == "SELL" else -max_loss_per_trade if action_taken == "BUY" else 0

            # Simulate next state for learning
            next_state = (ticker, row['Close'])  # Using price as part of the state

            # Update Q-table
            update_q_table(state, action_taken, reward, next_state)

            # Implement stop-loss or daily loss limit
            if daily_profit <= daily_loss_limit:
                print("Hit daily loss limit. Stopping trades for today.")
                break

    daily_results.append({'Day': day, 'Profit': daily_profit})
    print(f"Day {day} End - Profit: {daily_profit}")

# Convert daily results to DataFrame
results_df = pd.DataFrame(daily_results)

# Display results of the multi-day test
print(results_df)

# Log results
results_df.to_csv('rl_multi_day_test_results.csv')

import pandas as pd
import yfinance as yf
import numpy as np
import random

# Simulating multi-day trading over daily data
tickers = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN"]  # Replace with your top 25 tickers
data = {}
for ticker in tickers:
    stock_data = yf.download(ticker, period='1mo', interval='1d')  # Using '1mo' for daily data
    data[ticker] = stock_data

# Parameters for simulation and RL
initial_capital = 200
daily_loss_limit = -50
trade_amount = 5
profit_scaling_factor = 1.05
current_balance = initial_capital

# Q-learning variables
q_table = {}
learning_rate = 0.1
discount_factor = 0.9
exploration_rate = 0.2

# Sample result log
daily_results = []

def generate_signal(row):
    """Placeholder for signal generation logic (RSI, MACD, Bollinger)."""
    # Simplified: Randomly generate a signal for testing purposes
    return random.choice(["BUY", "SELL", "HOLD"])

def update_q_table(state, action, reward, next_state):
    """Update the Q-value for the state-action pair."""
    if state not in q_table:
        q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
    old_value = q_table[state][action]
    next_max = max(q_table[next_state].values()) if next_state in q_table else 0
    new_value = old_value + learning_rate * (reward + discount_factor * next_max - old_value)
    q_table[state][action] = new_value

for day in range(1, 31):  # Simulating over 30 days (since we used '1mo')
    daily_profit = 0
    print(f"Day {day} Trading Simulation Start")
    current_day_profit = 0

    # Simulate trading day-by-day for each stock
    for ticker, stock_data in data.items():
        for time, row in stock_data.iterrows():
            price = row['Close']

            # Generate signal based on technical indicators
            signal = generate_signal(row)  # Placeholder for your buy/sell logic

            # State representation (simplified for this example)
            state = (ticker, price)

            # Choose action (buy/sell/hold) - Explore or Exploit
            if random.uniform(0, 1) < exploration_rate:
                action = random.choice(["BUY", "SELL", "HOLD"])  # Explore
            else:
                action = max(q_table.get(state, {"BUY": 0, "SELL": 0, "HOLD": 0}), key=q_table.get)  # Exploit

            # Execute action
            if action == "BUY" and current_balance >= trade_amount:
                shares = trade_amount / price
                current_balance -= trade_amount
                print(f"Bought {shares} shares of {ticker} at ${price}")
                action_taken = "BUY"

            elif action == "SELL" and current_balance <= initial_capital + daily_profit:
                current_balance += trade_amount * profit_scaling_factor
                print(f"Sold shares of {ticker} at ${price}")
                daily_profit += trade_amount * profit_scaling_factor - trade_amount
                action_taken = "SELL"

            else:
                action_taken = "HOLD"

            # Reward or penalty based on the action
            reward = daily_profit if action_taken == "SELL" else -trade_amount if action_taken == "BUY" else 0

            # Simulate next state for learning
            next_state = (ticker, row['Close'])  # Using price as part of the state

            # Update Q-table
            update_q_table(state, action_taken, reward, next_state)

            # Implement stop-loss or daily loss limit
            if daily_profit <= daily_loss_limit:
                print("Hit daily loss limit. Stopping trades for today.")
                break

    daily_results.append({'Day': day, 'Profit': daily_profit})
    print(f"Day {day} End - Profit: {daily_profit}")

# Convert daily results to DataFrame
results_df = pd.DataFrame(daily_results)

# Display results of the multi-day test
print(results_df)

# Log results
results_df.to_csv('rl_multi_day_test_results.csv')

import pandas as pd
import yfinance as yf
import numpy as np
import random

# Simulating multi-day trading over daily data
tickers = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN"]  # Replace with your top 25 tickers
data = {}
for ticker in tickers:
    stock_data = yf.download(ticker, period='1mo', interval='1d')  # Using '1mo' for daily data
    data[ticker] = stock_data

# Parameters for simulation and RL
initial_capital = 200
daily_loss_limit = -50
trade_amount = 5
profit_scaling_factor = 1.05
current_balance = initial_capital

# Q-learning variables
q_table = {}
learning_rate = 0.1
discount_factor = 0.9
exploration_rate = 0.2

# Sample result log
daily_results = []

def generate_signal(row):
    """Placeholder for signal generation logic (RSI, MACD, Bollinger)."""
    # Simplified: Randomly generate a signal for testing purposes
    return random.choice(["BUY", "SELL", "HOLD"])

def update_q_table(state, action, reward, next_state):
    """Update the Q-value for the state-action pair."""
    if state not in q_table:
        q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
    old_value = q_table[state][action]
    next_max = max(q_table[next_state].values()) if next_state in q_table else 0
    new_value = old_value + learning_rate * (reward + discount_factor * next_max - old_value)
    q_table[state][action] = new_value

for day in range(1, 31):  # Simulating over 30 days (since we used '1mo')
    daily_profit = 0
    print(f"Day {day} Trading Simulation Start")
    current_day_profit = 0

    # Simulate trading day-by-day for each stock
    for ticker, stock_data in data.items():
        for time, row in stock_data.iterrows():
            price = row['Close']

            # Generate signal based on technical indicators
            signal = generate_signal(row)  # Placeholder for your buy/sell logic

            # State representation (simplified for this example)
            state = (ticker, price)

            # Choose action (buy/sell/hold) - Explore or Exploit
            if random.uniform(0, 1) < exploration_rate:
                action = random.choice(["BUY", "SELL", "HOLD"])  # Explore
            else:
                # Exploit: Choose action with the highest Q-value
                if state not in q_table:
                    q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
                action = max(q_table[state], key=q_table[state].get)  # Exploit based on Q-values

            # Execute action
            if action == "BUY" and current_balance >= trade_amount:
                shares = trade_amount / price
                current_balance -= trade_amount
                print(f"Bought {shares} shares of {ticker} at ${price}")
                action_taken = "BUY"

            elif action == "SELL" and current_balance <= initial_capital + daily_profit:
                current_balance += trade_amount * profit_scaling_factor
                print(f"Sold shares of {ticker} at ${price}")
                daily_profit += trade_amount * profit_scaling_factor - trade_amount
                action_taken = "SELL"

            else:
                action_taken = "HOLD"

            # Reward or penalty based on the action
            reward = daily_profit if action_taken == "SELL" else -trade_amount if action_taken == "BUY" else 0

            # Simulate next state for learning
            next_state = (ticker, row['Close'])  # Using price as part of the state

            # Update Q-table
            update_q_table(state, action_taken, reward, next_state)

            # Implement stop-loss or daily loss limit
            if daily_profit <= daily_loss_limit:
                print("Hit daily loss limit. Stopping trades for today.")
                break

    daily_results.append({'Day': day, 'Profit': daily_profit})
    print(f"Day {day} End - Profit: {daily_profit}")

# Convert daily results to DataFrame
results_df = pd.DataFrame(daily_results)

# Display results of the multi-day test
print(results_df)

# Log results
results_df.to_csv('rl_multi_day_test_results.csv')

import numpy as np

# Q-learning parameters
alpha = 0.1  # Learning rate
gamma = 0.9  # Discount factor
epsilon = 1.0  # Exploration rate
epsilon_decay = 0.995  # Decay rate for exploration
epsilon_min = 0.1  # Minimum exploration rate
q_table = {}  # Initialize the Q-table

# Function to select action based on exploration-exploitation trade-off
def select_action(state):
    if np.random.rand() < epsilon:
        # Explore
        return np.random.choice(["BUY", "SELL", "HOLD"])
    else:
        # Exploit
        return max(q_table.get(state, {"BUY": 0, "SELL": 0, "HOLD": 0}), key=q_table.get)

# Function to update Q-values
def update_q_table(state, action, reward, next_state):
    # Initialize Q-values if state is not in the table
    if state not in q_table:
        q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}

    # Update Q-value using the Q-learning formula
    q_old = q_table[state][action]
    q_next = max(q_table.get(next_state, {"BUY": 0, "SELL": 0, "HOLD": 0}).values())
    q_table[state][action] = q_old + alpha * (reward + gamma * q_next - q_old)

# Run simulation (pseudo-simulation below for illustrative purposes)
for day in range(1, 61):  # Simulate for 60 days
    state = "initial_state"  # Placeholder for state definition
    for minute in range(1, 391):  # Simulate each minute of the trading day
        action = select_action(state)

        # Simulate reward and next state (replace with actual logic)
        reward = np.random.uniform(-1, 1)  # Placeholder for reward
        next_state = "next_state"  # Placeholder for next state

        # Update Q-table
        update_q_table(state, action, reward, next_state)

        # Transition to next state
        state = next_state

    # Decay epsilon to reduce exploration over time
    if epsilon > epsilon_min:
        epsilon *= epsilon_decay

# At the end, print Q-table for analysis
print(q_table)

import numpy as np

# Q-learning parameters
alpha = 0.1  # Learning rate
gamma = 0.9  # Discount factor
epsilon = 1.0  # Exploration rate
epsilon_decay = 0.995  # Decay rate for exploration
epsilon_min = 0.1  # Minimum exploration rate
q_table = {}  # Initialize the Q-table

# Function to select action based on exploration-exploitation trade-off
def select_action(state):
    if state not in q_table:
        q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}  # Initialize state with default Q-values

    if np.random.rand() < epsilon:
        # Explore
        return np.random.choice(["BUY", "SELL", "HOLD"])
    else:
        # Exploit
        return max(q_table[state], key=q_table[state].get)

# Function to update Q-values
def update_q_table(state, action, reward, next_state):
    # Initialize Q-values for new states
    if state not in q_table:
        q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
    if next_state not in q_table:
        q_table[next_state] = {"BUY": 0, "SELL": 0, "HOLD": 0}

    # Update Q-value using the Q-learning formula
    q_old = q_table[state][action]
    q_next = max(q_table[next_state].values())  # Get the maximum Q-value for the next state
    q_table[state][action] = q_old + alpha * (reward + gamma * q_next - q_old)

# Run simulation (pseudo-simulation below for illustrative purposes)
for day in range(1, 61):  # Simulate for 60 days
    state = "initial_state"  # Placeholder for state definition
    for minute in range(1, 391):  # Simulate each minute of the trading day
        action = select_action(state)

        # Simulate reward and next state (replace with actual logic)
        reward = np.random.uniform(-1, 1)  # Placeholder for reward
        next_state = "next_state"  # Placeholder for next state

        # Update Q-table
        update_q_table(state, action, reward, next_state)

        # Transition to next state
        state = next_state

    # Decay epsilon to reduce exploration over time
    if epsilon > epsilon_min:
        epsilon *= epsilon_decay

# At the end, print Q-table for analysis
print(q_table)

import random
import numpy as np

# Initialize Q-table
q_table = {}

# Function to select action based on the Q-table
def select_action(state):
    # Epsilon-greedy strategy for exploration and exploitation
    epsilon = 0.1
    if random.uniform(0, 1) < epsilon:
        # Explore
        return random.choice(["BUY", "SELL", "HOLD"])
    else:
        # Exploit
        if state not in q_table:
            q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
        return max(q_table[state], key=q_table[state].get)

# Function to update Q-values
def update_q_value(state, action, reward, next_state, alpha=0.1, gamma=0.95):
    if next_state not in q_table:
        q_table[next_state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
    best_next_action = max(q_table[next_state], key=q_table[next_state].get)

    # Update Q-value using the Q-learning formula
    q_table[state][action] = q_table[state][action] + alpha * (reward + gamma * q_table[next_state][best_next_action] - q_table[state][action])

# Example state representation based on RSI, MACD, and price
def get_state(rsi, macd_signal, price_movement):
    state = (
        "RSI_" + ("LOW" if rsi < 30 else "HIGH" if rsi > 70 else "NEUTRAL"),
        "MACD_" + ("BULLISH" if macd_signal > 0 else "BEARISH"),
        "PRICE_" + ("UP" if price_movement > 0 else "DOWN")
    )
    return state

# Example reward function
def calculate_reward(entry_price, exit_price, action):
    if action == "BUY":
        return (exit_price - entry_price) / entry_price * 100  # Positive reward if price goes up
    elif action == "SELL":
        return (entry_price - exit_price) / entry_price * 100  # Positive reward if price goes down
    else:
        return 0  # No reward for HOLD

# Example simulation loop
for day in range(1, 31):  # Simulate 30 days of trading
    entry_price = random.uniform(100, 200)  # Simulated stock price
    exit_price = random.uniform(100, 200)  # Simulated exit price
    rsi = random.uniform(0, 100)  # Simulated RSI value
    macd_signal = random.uniform(-1, 1)  # Simulated MACD signal
    price_movement = exit_price - entry_price  # Price movement

    state = get_state(rsi, macd_signal, price_movement)
    action = select_action(state)

    # Simulate reward based on action taken
    reward = calculate_reward(entry_price, exit_price, action)

    # Transition to next state (can simulate a random next state for now)
    next_rsi = random.uniform(0, 100)
    next_macd_signal = random.uniform(-1, 1)
    next_price_movement = random.uniform(-5, 5)
    next_state = get_state(next_rsi, next_macd_signal, next_price_movement)

    # Update Q-values
    update_q_value(state, action, reward, next_state)

    # Print action, reward, and updated Q-values
    print(f"Day {day}: Action: {action}, Reward: {reward:.2f}, Q-values: {q_table[state]}")

# Display final Q-table for review
print("\nFinal Q-table:")
for state, actions in q_table.items():
    print(state, actions)

# Function to calculate profit and include transaction fees
def calculate_reward(entry_price, exit_price, action, fee=0.01):
    if action == "BUY":
        return ((exit_price - entry_price) / entry_price * 100) - fee  # Include transaction fee
    elif action == "SELL":
        return ((entry_price - exit_price) / entry_price * 100) - fee
    else:
        return 0

# Track cumulative profit over time
cumulative_profit = 0

for day in range(1, 61):  # Simulating 60 days
    entry_price = random.uniform(100, 200)
    exit_price = random.uniform(100, 200)
    rsi = random.uniform(0, 100)
    macd_signal = random.uniform(-1, 1)
    price_movement = exit_price - entry_price

    state = get_state(rsi, macd_signal, price_movement)
    action = select_action(state)
    reward = calculate_reward(entry_price, exit_price, action)

    cumulative_profit += reward  # Track total profit over the simulation

    next_rsi = random.uniform(0, 100)
    next_macd_signal = random.uniform(-1, 1)
    next_price_movement = random.uniform(-5, 5)
    next_state = get_state(next_rsi, next_macd_signal, next_price_movement)

    update_q_value(state, action, reward, next_state)

    print(f"Day {day}: Action: {action}, Reward: {reward:.2f}, Cumulative Profit: {cumulative_profit:.2f}")

# Final cumulative profit
print(f"Final Cumulative Profit after 60 days: {cumulative_profit:.2f}")

import pandas as pd
import numpy as np

# Simulate high volatility market condition by introducing large price swings
np.random.seed(42)  # For reproducibility

# Example historical stock data (AAPL for illustration)
dates = pd.date_range(start="2023-01-01", periods=390, freq='T')  # 390 minutes of trading per day
price_changes = np.random.normal(0, 2, size=(390,))  # Random price changes with higher volatility
base_price = 150  # Example base price for the stock

# Create high volatility price data
prices_high_volatility = base_price + np.cumsum(price_changes)
prices_high_volatility = np.clip(prices_high_volatility, 50, 300)  # Clip to avoid unrealistic prices

# Convert into DataFrame simulating high volatility scenario
high_volatility_data = pd.DataFrame({'Date': dates, 'Close': prices_high_volatility})

# Define the function to simulate trading on high volatility data
def simulate_trading_on_volatility(data, initial_balance=200):
    balance = initial_balance
    profit = 0
    trades = 0
    log = []

    # Simulate actions for each price point
    for i, row in data.iterrows():
        action = np.random.choice(["BUY", "SELL", "HOLD"])  # Randomized action for testing
        price = row['Close']

        if action == "BUY" and balance >= 5:
            shares = 5 / price
            balance -= 5
            log.append(f"Day {i+1}: Bought {shares:.4f} shares at ${price:.2f}")
        elif action == "SELL":
            profit += 5 * (1 + np.random.uniform(-0.05, 0.05))  # Randomized sell outcome
            trades += 1
            balance += 5
            log.append(f"Day {i+1}: Sold at ${price:.2f}")

    return balance, profit, trades, log

# Run high volatility simulation for 30 days
total_balance = 0
total_profit = 0
total_trades = 0
trade_log = []

for day in range(30):
    balance, profit, trades, log = simulate_trading_on_volatility(high_volatility_data)
    total_balance += balance
    total_profit += profit
    total_trades += trades
    trade_log.extend(log[:10])  # Sample first 10 trades from each day

# Prepare results for display
results = {
    'Final Balance': total_balance,
    'Cumulative Profit': total_profit,
    'Total Trades': total_trades,
    'Sample Trade Log': trade_log[:20]  # Showing 20 log entries
}

# Display results
results_df = pd.DataFrame([results])
print(results_df)
print("Sample Trade Log:")
for log_entry in trade_log[:20]:
    print(log_entry)

import pandas as pd
import numpy as np
import random

# Simulating over 30 days, starting with $200 capital
initial_capital = 200
trade_amount = 5
daily_loss_limit = -50
profit_scaling_factor = 1.05

# Adjusted final balance calculation
final_balance = initial_capital
cumulative_profit = 0
total_trades = 0
trade_log = []

# Example of how each day of trading could be structured
for day in range(1, 31):
    daily_profit = 0
    print(f"Day {day} Trading Start with balance: {final_balance}")

    # Simulate each trade (replace with actual conditions in your logic)
    for trade in range(1, 10):  # Simulating 10 trades per day
        action = random.choice(["BUY", "SELL"])
        trade_price = random.uniform(100, 200)  # Example price range
        shares = trade_amount / trade_price

        if action == "BUY" and final_balance >= trade_amount:
            final_balance -= trade_amount
            trade_log.append(f"Day {day}: Bought {shares:.4f} shares at ${trade_price:.2f}")
            total_trades += 1

        elif action == "SELL":
            sell_price = trade_price * profit_scaling_factor
            final_balance += trade_amount * profit_scaling_factor
            daily_profit += (sell_price - trade_price) * shares
            trade_log.append(f"Day {day}: Sold at ${sell_price:.2f}")
            total_trades += 1

        # Stop trading if daily loss limit reached
        if daily_profit <= daily_loss_limit:
            print(f"Daily loss limit reached on Day {day}. Stopping trades.")
            break

    cumulative_profit += daily_profit
    print(f"Day {day} End - Cumulative Profit: {cumulative_profit:.2f}")

# Results summary
results = {
    'Final Balance': final_balance,
    'Cumulative Profit': cumulative_profit,
    'Total Trades': total_trades,
    'Sample Trade Log': trade_log[:10]  # Show first 10 trades as a sample
}

# Display results
df = pd.DataFrame([results])
print(df)

# Adjust trade amount based on updated balance
def adjust_trade_size(balance, base_trade_size=5, profit_scaling_factor=1.05):
    trade_size = base_trade_size * (balance / 200) * profit_scaling_factor  # Scaling trade size
    return trade_size if trade_size > 1 else 1  # Ensure minimum trade size is $1

# Simulating trading over multiple days with profit rollover
cumulative_profit = 0
initial_balance = 200
daily_results = []
balance = initial_balance

for day in range(1, 31):  # Simulate 30 days
    print(f"Day {day} Trading Start with balance: {balance}")
    daily_profit = 0

    # Simulate minute-by-minute trades (replace this with real signal generation)
    for minute in range(390):  # Assume 390 minutes per trading day
        price = 100 + (minute % 10)  # Placeholder for price
        action = "BUY" if minute % 2 == 0 else "SELL"  # Placeholder for buy/sell logic
        trade_size = adjust_trade_size(balance)  # Adjust trade size

        # Example trade logic
        if action == "BUY":
            shares = trade_size / price
            balance -= trade_size
            print(f"Bought {shares:.4f} shares at ${price:.2f}")

        elif action == "SELL":
            profit = trade_size * 1.02  # Assume 2% profit per trade for simplicity
            balance += profit
            daily_profit += profit - trade_size
            print(f"Sold shares for a profit of ${profit:.2f}")

        # Simulate stop-loss and risk management (placeholder)
        if balance <= 50:
            print("Stop-loss triggered. Exiting day.")
            break

    cumulative_profit += daily_profit
    daily_results.append({'Day': day, 'Cumulative Profit': cumulative_profit})
    print(f"Day {day} End - Cumulative Profit: {cumulative_profit:.2f}\n")

    # Rollover balance for next day
    balance = initial_balance + cumulative_profit

# Display daily results
import pandas as pd
results_df = pd.DataFrame(daily_results)
print(results_df)

# Adjusted RSI and MACD thresholds
def generate_signal(row, rsi_thresholds=(40, 60), macd_threshold=0):
    rsi = row['RSI']
    macd = row['MACD']

    if rsi < rsi_thresholds[0] and macd > macd_threshold:
        return "BUY"
    elif rsi > rsi_thresholds[1] and macd < macd_threshold:
        return "SELL"
    else:
        return "HOLD"

import numpy as np

# Function to calculate Bollinger Bands
def calculate_bollinger_bands(data, window=20, num_std_dev=2):
    rolling_mean = data['Close'].rolling(window).mean()
    rolling_std = data['Close'].rolling(window).std()
    data['Upper Band'] = rolling_mean + (rolling_std * num_std_dev)
    data['Lower Band'] = rolling_mean - (rolling_std * num_std_dev)
    return data

# Adjust the signal generation to include Bollinger Bands
def generate_signal_with_bollinger(row, rsi_thresholds=(40, 60), macd_threshold=0):
    rsi = row['RSI']
    macd = row['MACD']
    close_price = row['Close']
    upper_band = row['Upper Band']
    lower_band = row['Lower Band']

    # Buy when price is below the lower Bollinger Band and RSI is low, MACD is bullish
    if close_price < lower_band and rsi < rsi_thresholds[0] and macd > macd_threshold:
        return "BUY"
    # Sell when price is above the upper Bollinger Band and RSI is high, MACD is bearish
    elif close_price > upper_band and rsi > rsi_thresholds[1] and macd < macd_threshold:
        return "SELL"
    else:
        return "HOLD"

# Apply this function within the main simulation loop where we generate signals

# Update Q-learning reward calculation to account for multiple factors
def calculate_reward(trade_profit, risk_adjustment=1.0):
    if trade_profit > 0:
        reward = trade_profit * risk_adjustment  # Reward for profitable trades
    else:
        reward = trade_profit * risk_adjustment * 0.5  # Penalize losses more
    return reward

# Update Q-table based on the reward
def update_q_table(state, action, reward, next_state, q_table, alpha=0.1, gamma=0.95):
    current_q = q_table.get(state, {}).get(action, 0)
    max_future_q = max(q_table.get(next_state, {}).values(), default=0)
    new_q = current_q + alpha * (reward + gamma * max_future_q - current_q)
    q_table[state][action] = new_q
    return q_table

import pandas as pd
import yfinance as yf
import random

# Load stock data for the past 60 days (1-minute intervals)
tickers = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN"]  # Replace with your top 25 stocks
data = {}
for ticker in tickers:
    stock_data = yf.download(ticker, period="60d", interval="1m")
    data[ticker] = stock_data

# Simulation parameters
initial_balance = 200
daily_loss_limit = -50
profit_scaling_factor = 1.05
max_trade_amount = 5  # Initial trade amount
total_balance = initial_balance
cumulative_profit = 0
q_table = {}  # Q-learning table to track actions and states

# Define Q-learning parameters
learning_rate = 0.1
discount_factor = 0.95
exploration_rate = 0.1  # Chance to explore

# Function to calculate signals (Placeholder for RSI, MACD, Bollinger Bands)
def generate_signal(row):
    rsi_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual RSI logic
    macd_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual MACD logic
    bollinger_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual Bollinger Bands logic

    # Combine signals and make final decision
    if rsi_signal == "BUY" and macd_signal == "BUY" and bollinger_signal == "BUY":
        return "BUY"
    elif rsi_signal == "SELL" and macd_signal == "SELL" and bollinger_signal == "SELL":
        return "SELL"
    else:
        return "HOLD"

# Function to select action using Q-learning
def select_action(state):
    if random.uniform(0, 1) < exploration_rate:
        # Explore random action
        return random.choice(["BUY", "SELL", "HOLD"])
    else:
        # Exploit learned knowledge
        return max(q_table.get(state, {"BUY": 0, "SELL": 0, "HOLD": 0}), key=q_table.get)

# Q-learning update function
def update_q_table(state, action, reward, next_state):
    q_current = q_table.get(state, {}).get(action, 0)
    q_max_next = max(q_table.get(next_state, {"BUY": 0, "SELL": 0, "HOLD": 0}).values())
    q_new = (1 - learning_rate) * q_current + learning_rate * (reward + discount_factor * q_max_next)

    if state not in q_table:
        q_table[state] = {}
    q_table[state][action] = q_new

# Run the multi-day trading simulation
trade_log = []
for day in range(1, 61):  # Simulating over 60 days
    daily_profit = 0
    print(f"Day {day} Trading Simulation Start with balance: {total_balance}")

    # Simulate minute-by-minute trading for each stock
    for ticker, stock_data in data.items():
        for time, row in stock_data.iterrows():
            price = row['Close']
            state = "example_state"  # Placeholder for state, you can integrate indicators here

            action = select_action(state)

            if action == "BUY" and total_balance >= max_trade_amount:
                shares = max_trade_amount / price
                total_balance -= max_trade_amount
                trade_log.append(f"Day {day}: Bought {shares:.4f} shares of {ticker} at ${price:.2f}")

            elif action == "SELL":
                total_balance += max_trade_amount * profit_scaling_factor
                trade_log.append(f"Day {day}: Sold shares of {ticker} at ${price:.2f}")
                daily_profit += max_trade_amount * profit_scaling_factor - max_trade_amount

            # Update Q-table with random reward (replace with actual reward logic)
            reward = random.uniform(-50, 50)  # Placeholder for reward calculation
            next_state = "next_state_example"  # Placeholder for next state
            update_q_table(state, action, reward, next_state)

            # Stop if daily loss limit is reached
            if daily_profit <= daily_loss_limit:
                print("Hit daily loss limit. Stopping trades for today.")
                break

    # Roll over daily profit
    cumulative_profit += daily_profit
    total_balance += daily_profit
    print(f"Day {day} End - Cumulative Profit: {cumulative_profit:.2f}")

# Simulation results
results = {
    "Final Balance": total_balance,
    "Cumulative Profit": cumulative_profit,
    "Total Trades": len(trade_log),
    "Sample Trade Log": trade_log[:10]  # Displaying only the first 10 trades as a sample
}

# Convert results to DataFrame for display
results_df = pd.DataFrame([results])
import ace_tools as tools; tools.display_dataframe_to_user(name="Trading Simulation Results", dataframe=results_df)

# Log the final trade history
for log_entry in trade_log:
    print(log_entry)

import pandas as pd
import yfinance as yf
import random

# Function to fetch stock data in smaller chunks (7 days at a time)
def fetch_data_in_chunks(ticker, days=60, interval='1m'):
    data = []
    chunks = days // 7  # Break the request into 7-day chunks
    for i in range(chunks):
        chunk_data = yf.download(ticker, period="7d", interval=interval)
        data.append(chunk_data)
    return pd.concat(data)

# Load stock data for each ticker
tickers = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN"]  # Replace with your top 25 stocks
data = {}
for ticker in tickers:
    try:
        stock_data = fetch_data_in_chunks(ticker)
        data[ticker] = stock_data
    except Exception as e:
        print(f"Failed to download data for {ticker}: {str(e)}")

# Simulation parameters
initial_balance = 200
daily_loss_limit = -50
profit_scaling_factor = 1.05
max_trade_amount = 5  # Initial trade amount
total_balance = initial_balance
cumulative_profit = 0
q_table = {}  # Q-learning table to track actions and states

# Define Q-learning parameters
learning_rate = 0.1
discount_factor = 0.95
exploration_rate = 0.1  # Chance to explore

# Function to calculate signals (Placeholder for RSI, MACD, Bollinger Bands)
def generate_signal(row):
    rsi_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual RSI logic
    macd_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual MACD logic
    bollinger_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual Bollinger Bands logic

    # Combine signals and make final decision
    if rsi_signal == "BUY" and macd_signal == "BUY" and bollinger_signal == "BUY":
        return "BUY"
    elif rsi_signal == "SELL" and macd_signal == "SELL" and bollinger_signal == "SELL":
        return "SELL"
    else:
        return "HOLD"

# Function to select action using Q-learning
def select_action(state):
    if random.uniform(0, 1) < exploration_rate:
        # Explore random action
        return random.choice(["BUY", "SELL", "HOLD"])
    else:
        # Exploit learned knowledge
        return max(q_table.get(state, {"BUY": 0, "SELL": 0, "HOLD": 0}), key=q_table.get)

# Q-learning update function
def update_q_table(state, action, reward, next_state):
    q_current = q_table.get(state, {}).get(action, 0)
    q_max_next = max(q_table.get(next_state, {"BUY": 0, "SELL": 0, "HOLD": 0}).values())
    q_new = (1 - learning_rate) * q_current + learning_rate * (reward + discount_factor * q_max_next)

    if state not in q_table:
        q_table[state] = {}
    q_table[state][action] = q_new

# Run the multi-day trading simulation
trade_log = []
for day in range(1, 61):  # Simulating over 60 days
    daily_profit = 0
    print(f"Day {day} Trading Simulation Start with balance: {total_balance}")

    # Simulate minute-by-minute trading for each stock
    for ticker, stock_data in data.items():
        for time, row in stock_data.iterrows():
            price = row['Close']
            state = "example_state"  # Placeholder for state, you can integrate indicators here

            action = select_action(state)

            if action == "BUY" and total_balance >= max_trade_amount:
                shares = max_trade_amount / price
                total_balance -= max_trade_amount
                trade_log.append(f"Day {day}: Bought {shares:.4f} shares of {ticker} at ${price:.2f}")

            elif action == "SELL":
                total_balance += max_trade_amount * profit_scaling_factor
                trade_log.append(f"Day {day}: Sold shares of {ticker} at ${price:.2f}")
                daily_profit += max_trade_amount * profit_scaling_factor - max_trade_amount

            # Update Q-table with random reward (replace with actual reward logic)
            reward = random.uniform(-50, 50)  # Placeholder for reward calculation
            next_state = "next_state_example"  # Placeholder for next state
            update_q_table(state, action, reward, next_state)

            # Stop if daily loss limit is reached
            if daily_profit <= daily_loss_limit:
                print("Hit daily loss limit. Stopping trades for today.")
                break

    # Roll over daily profit
    cumulative_profit += daily_profit
    total_balance += daily_profit
    print(f"Day {day} End - Cumulative Profit: {cumulative_profit:.2f}")

# Simulation results
results = {
    "Final Balance": total_balance,
    "Cumulative Profit": cumulative_profit,
    "Total Trades": len(trade_log),
    "Sample Trade Log": trade_log[:10]  # Displaying only the first 10 trades as a sample
}

# Convert results to DataFrame for display
results_df = pd.DataFrame([results])

# Log the final trade history
for log_entry in trade_log:
    print(log_entry)

import pandas as pd
import yfinance as yf
import random
from datetime import datetime, timedelta

# Function to fetch stock data for a specific period of 7 days at a time
def fetch_data_in_chunks(ticker, start_date, end_date, interval='1m'):
    try:
        stock_data = yf.download(ticker, start=start_date, end=end_date, interval=interval)
        return stock_data
    except Exception as e:
        print(f"Failed to download data for {ticker}: {str(e)}")
        return None

# Simulation parameters
initial_balance = 200
daily_loss_limit = -50
profit_scaling_factor = 1.05
max_trade_amount = 5  # Initial trade amount
total_balance = initial_balance
cumulative_profit = 0
q_table = {}  # Q-learning table to track actions and states

# Define Q-learning parameters
learning_rate = 0.1
discount_factor = 0.95
exploration_rate = 0.1  # Chance to explore

# Function to calculate signals (Placeholder for RSI, MACD, Bollinger Bands)
def generate_signal(row):
    rsi_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual RSI logic
    macd_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual MACD logic
    bollinger_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual Bollinger Bands logic

    # Combine signals and make final decision
    if rsi_signal == "BUY" and macd_signal == "BUY" and bollinger_signal == "BUY":
        return "BUY"
    elif rsi_signal == "SELL" and macd_signal == "SELL" and bollinger_signal == "SELL":
        return "SELL"
    else:
        return "HOLD"

# Function to select action using Q-learning
def select_action(state):
    if random.uniform(0, 1) < exploration_rate:
        # Explore random action
        return random.choice(["BUY", "SELL", "HOLD"])
    else:
        # Exploit learned knowledge
        return max(q_table.get(state, {"BUY": 0, "SELL": 0, "HOLD": 0}), key=q_table.get)

# Q-learning update function
def update_q_table(state, action, reward, next_state):
    q_current = q_table.get(state, {}).get(action, 0)
    q_max_next = max(q_table.get(next_state, {"BUY": 0, "SELL": 0, "HOLD": 0}).values())
    q_new = (1 - learning_rate) * q_current + learning_rate * (reward + discount_factor * q_max_next)

    if state not in q_table:
        q_table[state] = {}
    q_table[state][action] = q_new

# Setup dates for data retrieval
start_date = datetime.now() - timedelta(days=60)  # Fetch data from the last 60 days
end_date = datetime.now()

# Load stock data for each ticker over the last 60 days, 7-day chunks
tickers = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN"]  # Replace with your top 25 stocks
data = {}
for ticker in tickers:
    ticker_data = []
    for i in range(0, 60, 7):  # Break the request into 7-day chunks
        chunk_start_date = start_date + timedelta(days=i)
        chunk_end_date = min(chunk_start_date + timedelta(days=7), end_date)
        stock_data = fetch_data_in_chunks(ticker, chunk_start_date, chunk_end_date)
        if stock_data is not None:
            ticker_data.append(stock_data)
    if ticker_data:
        data[ticker] = pd.concat(ticker_data)

# Run the multi-day trading simulation
trade_log = []
for day in range(1, 61):  # Simulating over 60 days
    daily_profit = 0
    print(f"Day {day} Trading Simulation Start with balance: {total_balance}")

    # Simulate minute-by-minute trading for each stock
    for ticker, stock_data in data.items():
        for time, row in stock_data.iterrows():
            price = row['Close']
            state = "example_state"  # Placeholder for state, you can integrate indicators here

            action = select_action(state)

            if action == "BUY" and total_balance >= max_trade_amount:
                shares = max_trade_amount / price
                total_balance -= max_trade_amount
                trade_log.append(f"Day {day}: Bought {shares:.4f} shares of {ticker} at ${price:.2f}")

            elif action == "SELL":
                total_balance += max_trade_amount * profit_scaling_factor
                trade_log.append(f"Day {day}: Sold shares of {ticker} at ${price:.2f}")
                daily_profit += max_trade_amount * profit_scaling_factor - max_trade_amount

            # Update Q-table with random reward (replace with actual reward logic)
            reward = random.uniform(-50, 50)  # Placeholder for reward calculation
            next_state = "next_state_example"  # Placeholder for next state
            update_q_table(state, action, reward, next_state)

            # Stop if daily loss limit is reached
            if daily_profit <= daily_loss_limit:
                print("Hit daily loss limit. Stopping trades for today.")
                break

    # Roll over daily profit
    cumulative_profit += daily_profit
    total_balance += daily_profit
    print(f"Day {day} End - Cumulative Profit: {cumulative_profit:.2f}")

# Simulation results
results = {
    "Final Balance": total_balance,
    "Cumulative Profit": cumulative_profit,
    "Total Trades": len(trade_log),
    "Sample Trade Log": trade_log[:10]  # Displaying only the first 10 trades as a sample
}

# Convert results to DataFrame for display
results_df = pd.DataFrame([results])

# Log the final trade history
for log_entry in trade_log:
    print(log_entry)

import pandas as pd
import yfinance as yf
import random
from datetime import datetime, timedelta

# Function to fetch stock data with daily intervals
def fetch_data_in_chunks(ticker, start_date, end_date, interval='1d'):
    try:
        stock_data = yf.download(ticker, start=start_date, end=end_date, interval=interval)
        return stock_data
    except Exception as e:
        print(f"Failed to download data for {ticker}: {str(e)}")
        return None

# Simulation parameters
initial_balance = 200
daily_loss_limit = -50
profit_scaling_factor = 1.05
max_trade_amount = 5  # Initial trade amount
total_balance = initial_balance
cumulative_profit = 0
q_table = {}  # Q-learning table to track actions and states

# Define Q-learning parameters
learning_rate = 0.1
discount_factor = 0.95
exploration_rate = 0.1  # Chance to explore

# Function to calculate signals (Placeholder for RSI, MACD, Bollinger Bands)
def generate_signal(row):
    rsi_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual RSI logic
    macd_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual MACD logic
    bollinger_signal = random.choice(["BUY", "SELL", "HOLD"])  # Placeholder for actual Bollinger Bands logic

    # Combine signals and make final decision
    if rsi_signal == "BUY" and macd_signal == "BUY" and bollinger_signal == "BUY":
        return "BUY"
    elif rsi_signal == "SELL" and macd_signal == "SELL" and bollinger_signal == "SELL":
        return "SELL"
    else:
        return "HOLD"

# Function to select action using Q-learning
def select_action(state):
    if random.uniform(0, 1) < exploration_rate:
        # Explore random action
        return random.choice(["BUY", "SELL", "HOLD"])
    else:
        # Exploit learned knowledge
        if state not in q_table:
            q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
        return max(q_table[state], key=q_table[state].get)

# Q-learning update function
def update_q_table(state, action, reward, next_state):
    if state not in q_table:
        q_table[state] = {"BUY": 0, "SELL": 0, "HOLD": 0}
    if next_state not in q_table:
        q_table[next_state] = {"BUY": 0, "SELL": 0, "HOLD": 0}

    q_current = q_table[state][action]
    q_max_next = max(q_table[next_state].values())
    q_new = (1 - learning_rate) * q_current + learning_rate * (reward + discount_factor * q_max_next)

    q_table[state][action] = q_new

# Setup dates for data retrieval
start_date = datetime.now() - timedelta(days=60)  # Fetch data from the last 60 days
end_date = datetime.now()

# Load stock data for each ticker over the last 60 days
tickers = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN"]  # Replace with your top 25 stocks
data = {}
for ticker in tickers:
    ticker_data = []
    for i in range(0, 60, 7):  # Break the request into 7-day chunks
        chunk_start_date = start_date + timedelta(days=i)
        chunk_end_date = min(chunk_start_date + timedelta(days=7), end_date)
        stock_data = fetch_data_in_chunks(ticker, chunk_start_date, chunk_end_date)
        if stock_data is not None:
            ticker_data.append(stock_data)
    if ticker_data:
        data[ticker] = pd.concat(ticker_data)

# Run the multi-day trading simulation
trade_log = []
for day in range(1, 61):  # Simulating over 60 days
    daily_profit = 0
    print(f"Day {day} Trading Simulation Start with balance: {total_balance}")

    # Simulate daily trading for each stock
    for ticker, stock_data in data.items():
        for time, row in stock_data.iterrows():
            price = row['Close']
            state = "example_state"  # Placeholder for state, you can integrate indicators here

            action = select_action(state)

            if action == "BUY" and total_balance >= max_trade_amount:
                shares = max_trade_amount / price
                total_balance -= max_trade_amount
                trade_log.append(f"Day {day}: Bought {shares:.4f} shares of {ticker} at ${price:.2f}")

            elif action == "SELL":
                total_balance += max_trade_amount * profit_scaling_factor
                trade_log.append(f"Day {day}: Sold shares of {ticker} at ${price:.2f}")
                daily_profit += max_trade_amount * profit_scaling_factor - max_trade_amount

            # Update Q-table with random reward (replace with actual reward logic)
            reward = random.uniform(-50, 50)  # Placeholder for reward calculation
            next_state = "next_state_example"  # Placeholder for next state
            update_q_table(state, action, reward, next_state)

            # Stop if daily loss limit is reached
            if daily_profit <= daily_loss_limit:
                print("Hit daily loss limit. Stopping trades for today.")
                break

    # Roll over daily profit
    cumulative_profit += daily_profit
    total_balance += daily_profit
    print(f"Day {day} End - Cumulative Profit: {cumulative_profit:.2f}")

# Simulation results
results = {
    "Final Balance": total_balance,
    "Cumulative Profit": cumulative_profit,
    "Total Trades": len(trade_log),
    "Sample Trade Log": trade_log[:10]  # Displaying only the first 10 trades as a sample
}

# Convert results to DataFrame for display
results_df = pd.DataFrame([results])

# Log the final trade history
for log_entry in trade_log:
    print(log_entry)

# Extract performance metrics from the trade logs

# Initialize variables for performance metrics
total_trades = len(trade_log)  # Total number of trades
successful_trades = 0  # Tracks the number of profitable trades
total_profit = 0  # Tracks cumulative profit
max_drawdown = 0  # Tracks the largest drawdown

# Loop through the trade log to calculate metrics
for trade in trade_log:
    profit = trade['profit']
    total_profit += profit
    if profit > 0:
        successful_trades += 1
    if profit < max_drawdown:
        max_drawdown = profit

# Calculate win rate
win_rate = (successful_trades / total_trades) * 100 if total_trades > 0 else 0

# Calculate average profit per trade
average_profit_per_trade = total_profit / total_trades if total_trades > 0 else 0

# Display performance metrics
performance_metrics = {
    "Total Trades": total_trades,
    "Total Profit": total_profit,
    "Win Rate (%)": win_rate,
    "Max Drawdown": max_drawdown,
    "Average Profit per Trade": average_profit_per_trade
}

# Display performance metrics
import ace_tools as tools; tools.display_dataframe_to_user(name="Performance Metrics", dataframe=pd.DataFrame([performance_metrics]))

# Inspect the first few entries in the trade log
print(trade_log[:5])  # This will display the first 5 entries in the trade log

import re

# Initialize metrics
total_profit = 0
total_trades = len(trade_log)
winning_trades = 0
losing_trades = 0
average_profit = 0

# Regular expression to extract buy/sell prices from the log entries
buy_pattern = r'Bought\s+(\d+\.\d+)\s+shares.*at\s+\$(\d+\.\d+)'
sell_pattern = r'Sold\s+shares.*at\s+\$(\d+\.\d+)'

# Variables to track ongoing positions
last_buy_price = None
shares_bought = 0

# Loop through the trade log to calculate metrics
for trade in trade_log:
    # Check if the entry is a buy trade
    buy_match = re.search(buy_pattern, trade)
    if buy_match:
        shares_bought = float(buy_match.group(1))
        last_buy_price = float(buy_match.group(2))

    # Check if the entry is a sell trade
    sell_match = re.search(sell_pattern, trade)
    if sell_match and last_buy_price is not None:
        sell_price = float(sell_match.group(1))

        # Calculate profit from this trade
        profit = (sell_price - last_buy_price) * shares_bought
        total_profit += profit

        if profit > 0:
            winning_trades += 1
        else:
            losing_trades += 1

        # Reset the buy price for next trade
        last_buy_price = None

# Calculate average profit
if total_trades > 0:
    average_profit = total_profit / total_trades

# Print performance metrics
print(f"Total Profit: ${total_profit:.2f}")
print(f"Total Trades: {total_trades}")
print(f"Winning Trades: {winning_trades}")
print(f"Losing Trades: {losing_trades}")
print(f"Average Profit per Trade: ${average_profit:.2f}")

# Transaction cost per trade (in dollars)
transaction_cost = 0.02  # Adjust as needed to simulate real-world trading fees

# Adjusted trade log to account for transaction costs
updated_trade_log = []
for trade in trade_log:
    if "Bought" in trade or "Sold" in trade:
        # Calculate profit/loss after transaction cost
        trade_profit = float(trade.split(' ')[-1].strip('$'))  # Extract the dollar value of trade
        trade_profit -= transaction_cost
        updated_trade_log.append(trade_profit)

# Recalculate performance metrics
total_profit = sum(updated_trade_log)
total_trades = len(updated_trade_log)
winning_trades = len([t for t in updated_trade_log if t > 0])
losing_trades = len([t for t in updated_trade_log if t < 0])
average_profit_per_trade = total_profit / total_trades if total_trades > 0 else 0

# Output the updated performance
print(f"Total Profit after transaction costs: ${total_profit:.2f}")
print(f"Total Trades: {total_trades}")
print(f"Winning Trades: {winning_trades}")
print(f"Losing Trades: {losing_trades}")
print(f"Average Profit per Trade: ${average_profit_per_trade:.2f}")

import pandas as pd
import numpy as np

# Define market condition simulation periods (bull, bear, sideways)
market_conditions = {
    'bull_market': ('2023-01-01', '2023-06-30'),
    'bear_market': ('2022-06-01', '2022-12-31'),
    'sideways_market': ('2021-01-01', '2021-06-30')
}

# Adjusted trading logic
def trading_logic(ticker_data, state):
    buy_signal = False
    sell_signal = False

    rsi = calculate_rsi(ticker_data['Close'])
    macd = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # Stricter conditions for buy/sell
    if rsi < 30 and macd > 0 and ticker_data['Close'][-1] < bollinger['LowerBand'][-1]:
        buy_signal = True
    elif rsi > 70 and macd < 0 and ticker_data['Close'][-1] > bollinger['UpperBand'][-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Simulate multiple market conditions
def simulate_trades():
    total_profits = {}
    for condition, (start_date, end_date) in market_conditions.items():
        print(f"Running simulation for {condition} from {start_date} to {end_date}")
        # Fetch historical data
        ticker_data = fetch_historical_data('AAPL', start=start_date, end=end_date)

        # Run the simulation for each condition
        profits, total_trades, win_trades, loss_trades = run_trading_simulation(ticker_data)
        total_profits[condition] = {
            'Profit': profits,
            'Total Trades': total_trades,
            'Winning Trades': win_trades,
            'Losing Trades': loss_trades
        }
        print(f"Finished simulation for {condition}: Profit={profits}, Trades={total_trades}")

    return total_profits

# Main simulation function
def run_trading_simulation(ticker_data):
    balance = 200  # Starting balance
    trade_log = []
    total_profit = 0
    total_trades = 0
    winning_trades = 0
    losing_trades = 0

    # Simulate trading
    for day in range(len(ticker_data)):
        buy_signal, sell_signal = trading_logic(ticker_data, state=None)

        if buy_signal and balance >= 5:  # $5 trade size
            shares_bought = 5 / ticker_data['Close'][day]
            balance -= 5
            trade_log.append({'Action': 'BUY', 'Price': ticker_data['Close'][day], 'Shares': shares_bought})

        elif sell_signal and len(trade_log) > 0:  # Sell if there's something to sell
            last_trade = trade_log[-1]
            if last_trade['Action'] == 'BUY':
                profit = (ticker_data['Close'][day] - last_trade['Price']) * last_trade['Shares']
                total_profit += profit
                balance += 5 + profit
                trade_log.append({'Action': 'SELL', 'Price': ticker_data['Close'][day], 'Profit': profit})
                total_trades += 1
                if profit > 0:
                    winning_trades += 1
                else:
                    losing_trades += 1

    return total_profit, total_trades, winning_trades, losing_trades

# Simulate and print results for all market conditions
results = simulate_trades()
for condition, metrics in results.items():
    print(f"Results for {condition}: {metrics}")

import yfinance as yf
import pandas as pd
import numpy as np

# Define market condition simulation periods (bull, bear, sideways)
market_conditions = {
    'bull_market': ('2023-01-01', '2023-06-30'),
    'bear_market': ('2022-06-01', '2022-12-31'),
    'sideways_market': ('2021-01-01', '2021-06-30')
}

# Function to fetch historical data using yfinance
def fetch_historical_data(ticker, start, end):
    print(f"Fetching data for {ticker} from {start} to {end}")
    ticker_data = yf.download(ticker, start=start, end=end, interval='1d')  # Daily data
    return ticker_data

# Adjusted trading logic
def trading_logic(ticker_data, state):
    buy_signal = False
    sell_signal = False

    rsi = calculate_rsi(ticker_data['Close'])
    macd = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # Stricter conditions for buy/sell
    if rsi < 30 and macd > 0 and ticker_data['Close'][-1] < bollinger['LowerBand'][-1]:
        buy_signal = True
    elif rsi > 70 and macd < 0 and ticker_data['Close'][-1] > bollinger['UpperBand'][-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Simulate multiple market conditions
def simulate_trades():
    total_profits = {}
    for condition, (start_date, end_date) in market_conditions.items():
        print(f"Running simulation for {condition} from {start_date} to {end_date}")
        # Fetch historical data
        ticker_data = fetch_historical_data('AAPL', start=start_date, end=end_date)

        # Run the simulation for each condition
        profits, total_trades, win_trades, loss_trades = run_trading_simulation(ticker_data)
        total_profits[condition] = {
            'Profit': profits,
            'Total Trades': total_trades,
            'Winning Trades': win_trades,
            'Losing Trades': loss_trades
        }
        print(f"Finished simulation for {condition}: Profit={profits}, Trades={total_trades}")

    return total_profits

# Main simulation function
def run_trading_simulation(ticker_data):
    balance = 200  # Starting balance
    trade_log = []
    total_profit = 0
    total_trades = 0
    winning_trades = 0
    losing_trades = 0

    # Simulate trading
    for day in range(len(ticker_data)):
        buy_signal, sell_signal = trading_logic(ticker_data, state=None)

        if buy_signal and balance >= 5:  # $5 trade size
            shares_bought = 5 / ticker_data['Close'][day]
            balance -= 5
            trade_log.append({'Action': 'BUY', 'Price': ticker_data['Close'][day], 'Shares': shares_bought})

        elif sell_signal and len(trade_log) > 0:  # Sell if there's something to sell
            last_trade = trade_log[-1]
            if last_trade['Action'] == 'BUY':
                profit = (ticker_data['Close'][day] - last_trade['Price']) * last_trade['Shares']
                total_profit += profit
                balance += 5 + profit
                trade_log.append({'Action': 'SELL', 'Price': ticker_data['Close'][day], 'Profit': profit})
                total_trades += 1
                if profit > 0:
                    winning_trades += 1
                else:
                    losing_trades += 1

    return total_profit, total_trades, winning_trades, losing_trades

# Simulate and print results for all market conditions
results = simulate_trades()
for condition, metrics in results.items():
    print(f"Results for {condition}: {metrics}")

import yfinance as yf
import pandas as pd
import numpy as np

# Define market condition simulation periods (bull, bear, sideways)
market_conditions = {
    'bull_market': ('2023-01-01', '2023-06-30'),
    'bear_market': ('2022-06-01', '2022-12-31'),
    'sideways_market': ('2021-01-01', '2021-06-30')
}

# Function to fetch historical data using yfinance
def fetch_historical_data(ticker, start, end):
    print(f"Fetching data for {ticker} from {start} to {end}")
    ticker_data = yf.download(ticker, start=start, end=end, interval='1d')  # Daily data
    if 'Close' not in ticker_data.columns:
        raise ValueError(f"'Close' column not found in the data for {ticker}")
    return ticker_data

# Adjusted trading logic
def trading_logic(ticker_data, state):
    buy_signal = False
    sell_signal = False

    rsi = calculate_rsi(ticker_data['Close'])
    macd = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # Stricter conditions for buy/sell
    if rsi < 30 and macd > 0 and ticker_data['Close'][-1] < bollinger['LowerBand'][-1]:
        buy_signal = True
    elif rsi > 70 and macd < 0 and ticker_data['Close'][-1] > bollinger['UpperBand'][-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Simulate multiple market conditions
def simulate_trades():
    total_profits = {}
    for condition, (start_date, end_date) in market_conditions.items():
        print(f"Running simulation for {condition} from {start_date} to {end_date}")
        # Fetch historical data
        ticker_data = fetch_historical_data('AAPL', start=start_date, end=end_date)

        # Run the simulation for each condition
        profits, total_trades, win_trades, loss_trades = run_trading_simulation(ticker_data)
        total_profits[condition] = {
            'Profit': profits,
            'Total Trades': total_trades,
            'Winning Trades': win_trades,
            'Losing Trades': loss_trades
        }
        print(f"Finished simulation for {condition}: Profit={profits}, Trades={total_trades}")

    return total_profits

# Main simulation function
def run_trading_simulation(ticker_data):
    balance = 200  # Starting balance
    trade_log = []
    total_profit = 0
    total_trades = 0
    winning_trades = 0
    losing_trades = 0

    # Simulate trading
    for day in range(len(ticker_data)):
        buy_signal, sell_signal = trading_logic(ticker_data, state=None)

        if buy_signal and balance >= 5:  # $5 trade size
            shares_bought = 5 / ticker_data['Close'][day]
            balance -= 5
            trade_log.append({'Action': 'BUY', 'Price': ticker_data['Close'][day], 'Shares': shares_bought})

        elif sell_signal and len(trade_log) > 0:  # Sell if there's something to sell
            last_trade = trade_log[-1]
            if last_trade['Action'] == 'BUY':
                profit = (ticker_data['Close'][day] - last_trade['Price']) * last_trade['Shares']
                total_profit += profit
                balance += 5 + profit
                trade_log.append({'Action': 'SELL', 'Price': ticker_data['Close'][day], 'Profit': profit})
                total_trades += 1
                if profit > 0:
                    winning_trades += 1
                else:
                    losing_trades += 1

    return total_profit, total_trades, winning_trades, losing_trades

# Simulate and print results for all market conditions
results = simulate_trades()
for condition, metrics in results.items():
    print(f"Results for {condition}: {metrics}")

import yfinance as yf
import pandas as pd
import numpy as np

# Define market condition simulation periods (bull, bear, sideways)
market_conditions = {
    'bull_market': ('2023-01-01', '2023-06-30'),
    'bear_market': ('2022-06-01', '2022-12-31'),
    'sideways_market': ('2021-01-01', '2021-06-30')
}

# Function to fetch historical data using yfinance
def fetch_historical_data(ticker, start, end):
    print(f"Fetching data for {ticker} from {start} to {end}")
    ticker_data = yf.download(ticker, start=start, end=end, interval='1d')  # Daily data
    print(ticker_data.head())  # Print the first few rows to inspect the data
    if 'Close' not in ticker_data.columns:
        raise ValueError(f"'Close' column not found in the data for {ticker}. Available columns: {ticker_data.columns}")
    return ticker_data

# Adjusted trading logic
def trading_logic(ticker_data, state):
    buy_signal = False
    sell_signal = False

    rsi = calculate_rsi(ticker_data['Close'])
    macd = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # Stricter conditions for buy/sell
    if rsi < 30 and macd > 0 and ticker_data['Close'][-1] < bollinger['LowerBand'][-1]:
        buy_signal = True
    elif rsi > 70 and macd < 0 and ticker_data['Close'][-1] > bollinger['UpperBand'][-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Simulate multiple market conditions
def simulate_trades():
    total_profits = {}
    for condition, (start_date, end_date) in market_conditions.items():
        print(f"Running simulation for {condition} from {start_date} to {end_date}")
        # Fetch historical data
        ticker_data = fetch_historical_data('AAPL', start=start_date, end=end_date)

        # Run the simulation for each condition
        profits, total_trades, win_trades, loss_trades = run_trading_simulation(ticker_data)
        total_profits[condition] = {
            'Profit': profits,
            'Total Trades': total_trades,
            'Winning Trades': win_trades,
            'Losing Trades': loss_trades
        }
        print(f"Finished simulation for {condition}: Profit={profits}, Trades={total_trades}")

    return total_profits

# Main simulation function
def run_trading_simulation(ticker_data):
    balance = 200  # Starting balance
    trade_log = []
    total_profit = 0
    total_trades = 0
    winning_trades = 0
    losing_trades = 0

    # Simulate trading
    for day in range(len(ticker_data)):
        buy_signal, sell_signal = trading_logic(ticker_data, state=None)

        if buy_signal and balance >= 5:  # $5 trade size
            shares_bought = 5 / ticker_data['Close'][day]
            balance -= 5
            trade_log.append({'Action': 'BUY', 'Price': ticker_data['Close'][day], 'Shares': shares_bought})

        elif sell_signal and len(trade_log) > 0:  # Sell if there's something to sell
            last_trade = trade_log[-1]
            if last_trade['Action'] == 'BUY':
                profit = (ticker_data['Close'][day] - last_trade['Price']) * last_trade['Shares']
                total_profit += profit
                balance += 5 + profit
                trade_log.append({'Action': 'SELL', 'Price': ticker_data['Close'][day], 'Profit': profit})
                total_trades += 1
                if profit > 0:
                    winning_trades += 1
                else:
                    losing_trades += 1

    return total_profit, total_trades, winning_trades, losing_trades

# Simulate and print results for all market conditions
results = simulate_trades()
for condition, metrics in results.items():
    print(f"Results for {condition}: {metrics}")

import yfinance as yf
import pandas as pd
import numpy as np

# Define market condition simulation periods (bull, bear, sideways)
market_conditions = {
    'bull_market': ('2023-01-01', '2023-06-30'),
    'bear_market': ('2022-06-01', '2022-12-31'),
    'sideways_market': ('2021-01-01', '2021-06-30')
}

# Function to fetch historical data using yfinance
def fetch_historical_data(ticker, start, end):
    print(f"Fetching data for {ticker} from {start} to {end}")
    ticker_data = yf.download(ticker, start=start, end=end, interval='1d')  # Daily data
    print(ticker_data.head())  # Print the first few rows to inspect the data
    if 'Close' not in ticker_data.columns:
        raise ValueError(f"'Close' column not found in the data for {ticker}. Available columns: {ticker_data.columns}")
    return ticker_data

# Function to calculate RSI (example implementation)
def calculate_rsi(close_prices, window=14):
    delta = close_prices.diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Function to calculate MACD (example implementation)
def calculate_macd(close_prices, slow=26, fast=12, signal=9):
    exp1 = close_prices.ewm(span=fast, adjust=False).mean()
    exp2 = close_prices.ewm(span=slow, adjust=False).mean()
    macd = exp1 - exp2
    signal_line = macd.ewm(span=signal, adjust=False).mean()
    return macd, signal_line

# Function to calculate Bollinger Bands (example implementation)
def calculate_bollinger_bands(close_prices, window=20):
    rolling_mean = close_prices.rolling(window).mean()
    rolling_std = close_prices.rolling(window).std()
    upper_band = rolling_mean + (rolling_std * 2)
    lower_band = rolling_mean - (rolling_std * 2)
    return {'UpperBand': upper_band, 'LowerBand': lower_band}

# Adjusted trading logic
def trading_logic(ticker_data, state):
    buy_signal = False
    sell_signal = False

    rsi = calculate_rsi(ticker_data['Close'])
    macd, signal_line = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # Stricter conditions for buy/sell
    if rsi.iloc[-1] < 30 and macd.iloc[-1] > signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] < bollinger['LowerBand'].iloc[-1]:
        buy_signal = True
    elif rsi.iloc[-1] > 70 and macd.iloc[-1] < signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] > bollinger['UpperBand'].iloc[-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Simulate multiple market conditions
def simulate_trades():
    total_profits = {}
    for condition, (start_date, end_date) in market_conditions.items():
        print(f"Running simulation for {condition} from {start_date} to {end_date}")
        # Fetch historical data
        ticker_data = fetch_historical_data('AAPL', start=start_date, end=end_date)

        # Run the simulation for each condition
        profits, total_trades, win_trades, loss_trades = run_trading_simulation(ticker_data)
        total_profits[condition] = {
            'Profit': profits,
            'Total Trades': total_trades,
            'Winning Trades': win_trades,
            'Losing Trades': loss_trades
        }
        print(f"Finished simulation for {condition}: Profit={profits}, Trades={total_trades}")

    return total_profits

# Main simulation function
def run_trading_simulation(ticker_data):
    balance = 200  # Starting balance
    trade_log = []
    total_profit = 0
    total_trades = 0
    winning_trades = 0
    losing_trades = 0

    # Simulate trading
    for day in range(len(ticker_data)):
        buy_signal, sell_signal = trading_logic(ticker_data.iloc[:day+1], state=None)

        if buy_signal and balance >= 5:  # $5 trade size
            shares_bought = 5 / ticker_data['Close'].iloc[day]
            balance -= 5
            trade_log.append({'Action': 'BUY', 'Price': ticker_data['Close'].iloc[day], 'Shares': shares_bought})

        elif sell_signal and len(trade_log) > 0:  # Sell if there's something to sell
            last_trade = trade_log[-1]
            if last_trade['Action'] == 'BUY':
                profit = (ticker_data['Close'].iloc[day] - last_trade['Price']) * last_trade['Shares']
                total_profit += profit
                balance += 5 + profit
                trade_log.append({'Action': 'SELL', 'Price': ticker_data['Close'].iloc[day], 'Profit': profit})
                total_trades += 1
                if profit > 0:
                    winning_trades += 1
                else:
                    losing_trades += 1

    return total_profit, total_trades, winning_trades, losing_trades

# Simulate and print results for all market conditions
results = simulate_trades()
for condition, metrics in results.items():
    print(f"Results for {condition}: {metrics}")

# Adjusted trading logic with more flexible conditions
def trading_logic(ticker_data, state):
    buy_signal = False
    sell_signal = False

    # Calculate RSI, MACD, and Bollinger Bands
    rsi = calculate_rsi(ticker_data['Close'])
    macd, signal_line = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # More flexible buy condition (RSI < 40, MACD crossover, price near lower Bollinger Band)
    if rsi.iloc[-1] < 40 and macd.iloc[-1] > signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] <= bollinger['LowerBand'].iloc[-1]:
        buy_signal = True

    # More flexible sell condition (RSI > 60, MACD cross under, price near upper Bollinger Band)
    elif rsi.iloc[-1] > 60 and macd.iloc[-1] < signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] >= bollinger['UpperBand'].iloc[-1]:
        sell_signal = True

    return buy_signal, sell_signal

import pandas as pd
import yfinance as yf

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

# Function to calculate MACD
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    short_ema = data.ewm(span=short_window, adjust=False).mean()
    long_ema = data.ewm(span=long_window, adjust=False).mean()
    macd = short_ema - long_ema
    signal_line = macd.ewm(span=signal_window, adjust=False).mean()
    return macd, signal_line

# Function to calculate Bollinger Bands
def calculate_bollinger_bands(data, window=20, num_std=2):
    sma = data.rolling(window=window).mean()
    std = data.rolling(window=window).std()
    upper_band = sma + (std * num_std)
    lower_band = sma - (std * num_std)
    return pd.DataFrame({'UpperBand': upper_band, 'LowerBand': lower_band})

# Adjusted trading logic
def trading_logic(ticker_data):
    buy_signal = False
    sell_signal = False

    # Calculate RSI, MACD, and Bollinger Bands
    rsi = calculate_rsi(ticker_data['Close'])
    macd, signal_line = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # More flexible buy condition
    if rsi.iloc[-1] < 40 and macd.iloc[-1] > signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] <= bollinger['LowerBand'].iloc[-1]:
        buy_signal = True

    # More flexible sell condition
    elif rsi.iloc[-1] > 60 and macd.iloc[-1] < signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] >= bollinger['UpperBand'].iloc[-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Fetch historical data
def fetch_historical_data(ticker, start, end):
    data = yf.download(ticker, start=start, end=end, interval='1d')
    return data

# Run simulation
def run_simulation(ticker, start_date, end_date):
    # Fetch historical data
    ticker_data = fetch_historical_data(ticker, start=start_date, end=end_date)

    # Initialize variables for simulation
    total_balance = 200  # Starting balance
    total_profit = 0
    trade_log = []

    # Loop through each trading day
    for index, row in ticker_data.iterrows():
        buy_signal, sell_signal = trading_logic(ticker_data.loc[:index])

        if buy_signal and total_balance > 0:
            shares_bought = total_balance / row['Close']
            total_balance = 0
            trade_log.append(f"Day {index}: Bought {shares_bought:.4f} shares of {ticker} at ${row['Close']:.2f}")

        elif sell_signal and total_balance == 0:
            total_balance += shares_bought * row['Close']
            profit = total_balance - 200
            trade_log.append(f"Day {index}: Sold shares of {ticker} at ${row['Close']:.2f}, Profit: ${profit:.2f}")
            total_profit += profit

    return total_profit, trade_log

# Simulate trades for different market conditions
def simulate_trades():
    market_conditions = {
        'bull_market': ('2023-01-01', '2023-06-30'),
        'bear_market': ('2023-07-01', '2023-12-31'),
        'sideways_market': ('2023-03-01', '2023-09-30')
    }

    results = {}
    for condition, (start_date, end_date) in market_conditions.items():
        print(f"Running simulation for {condition} from {start_date} to {end_date}")
        total_profit, trade_log = run_simulation('AAPL', start_date, end_date)

        results[condition] = {
            'Profit': total_profit,
            'Total Trades': len(trade_log),
            'Trade Log': trade_log
        }

    return results

# Run the simulation and print results
results = simulate_trades()
for condition, metrics in results.items():
    print(f"Results for {condition}: Profit=${metrics['Profit']:.2f}, Total Trades={metrics['Total Trades']}")
    print("Sample Trades:")
    for log in metrics['Trade Log'][:5]:  # Print the first 5 trades as a sample
        print(log)

import pandas as pd
import yfinance as yf

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

# Function to calculate MACD
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    short_ema = data.ewm(span=short_window, adjust=False).mean()
    long_ema = data.ewm(span=long_window, adjust=False).mean()
    macd = short_ema - long_ema
    signal_line = macd.ewm(span=signal_window, adjust=False).mean()
    return macd, signal_line

# Function to calculate Bollinger Bands
def calculate_bollinger_bands(data, window=20, num_std=2):
    sma = data.rolling(window=window).mean()
    std = data.rolling(window=window).std()
    upper_band = sma + (std * num_std)
    lower_band = sma - (std * num_std)
    return pd.DataFrame({'UpperBand': upper_band, 'LowerBand': lower_band})

# Adjusted trading logic with broader conditions
def trading_logic(ticker_data):
    buy_signal = False
    sell_signal = False

    # Calculate RSI, MACD, and Bollinger Bands
    rsi = calculate_rsi(ticker_data['Close'])
    macd, signal_line = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # More flexible buy condition
    if rsi.iloc[-1] < 50 and macd.iloc[-1] > signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] <= bollinger['LowerBand'].iloc[-1]:
        buy_signal = True

    # More flexible sell condition
    elif rsi.iloc[-1] > 50 and macd.iloc[-1] < signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] >= bollinger['UpperBand'].iloc[-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Fetch historical data
def fetch_historical_data(ticker, start, end):
    data = yf.download(ticker, start=start, end=end, interval='1d')
    return data

# Run simulation
def run_simulation(ticker, start_date, end_date):
    # Fetch historical data
    ticker_data = fetch_historical_data(ticker, start=start_date, end=end_date)

    # Initialize variables for simulation
    total_balance = 200  # Starting balance
    total_profit = 0
    trade_log = []

    # Loop through each trading day
    for index, row in ticker_data.iterrows():
        buy_signal, sell_signal = trading_logic(ticker_data.loc[:index])

        if buy_signal and total_balance > 0:
            shares_bought = total_balance / row['Close']
            total_balance = 0
            trade_log.append(f"Day {index}: Bought {shares_bought:.4f} shares of {ticker} at ${row['Close']:.2f}")

        elif sell_signal and total_balance == 0:
            total_balance += shares_bought * row['Close']
            profit = total_balance - 200
            trade_log.append(f"Day {index}: Sold shares of {ticker} at ${row['Close']:.2f}, Profit: ${profit:.2f}")
            total_profit += profit

    return total_profit, trade_log

# Simulate trades for different market conditions
def simulate_trades():
    market_conditions = {
        'bull_market': ('2023-01-01', '2023-06-30'),
        'bear_market': ('2023-07-01', '2023-12-31'),
        'sideways_market': ('2023-03-01', '2023-09-30')
    }

    results = {}
    for condition, (start_date, end_date) in market_conditions.items():
        print(f"Running simulation for {condition} from {start_date} to {end_date}")
        total_profit, trade_log = run_simulation('AAPL', start_date, end_date)

        results[condition] = {
            'Profit': total_profit,
            'Total Trades': len(trade_log),
            'Trade Log': trade_log
        }

    return results

# Run the simulation and print results
results = simulate_trades()
for condition, metrics in results.items():
    print(f"Results for {condition}: Profit=${metrics['Profit']:.2f}, Total Trades={metrics['Total Trades']}")
    print("Sample Trades:")
    for log in metrics['Trade Log'][:5]:  # Print the first 5 trades as a sample
        print(log)

# Adjusted trading logic with even broader conditions
def trading_logic(ticker_data):
    buy_signal = False
    sell_signal = False

    # Calculate RSI, MACD, and Bollinger Bands
    rsi = calculate_rsi(ticker_data['Close'])
    macd, signal_line = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # Even more flexible buy condition
    if rsi.iloc[-1] < 60 and macd.iloc[-1] > signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] <= bollinger['LowerBand'].iloc[-1]:
        buy_signal = True

    # Even more flexible sell condition
    elif rsi.iloc[-1] > 40 and macd.iloc[-1] < signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] >= bollinger['UpperBand'].iloc[-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Adjusted trading logic with more relaxed conditions
def trading_logic(ticker_data):
    buy_signal = False
    sell_signal = False

    # Calculate RSI, MACD, and Bollinger Bands
    rsi = calculate_rsi(ticker_data['Close'])
    macd, signal_line = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # Flexible buy condition
    if rsi.iloc[-1] < 60 and macd.iloc[-1] > signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] <= bollinger['LowerBand'].iloc[-1]:
        buy_signal = True

    # Flexible sell condition
    elif rsi.iloc[-1] > 40 and macd.iloc[-1] < signal_line.iloc[-1] and ticker_data['Close'].iloc[-1] >= bollinger['UpperBand'].iloc[-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Simulate trading for a given condition
def simulate_trades_for_condition(start_date, end_date):
    ticker_data = fetch_historical_data('AAPL', start=start_date, end=end_date)
    trade_log = []
    balance = 200  # Starting balance
    max_trade_amount = 5  # Maximum trade amount
    shares_owned = 0

    for date, row in ticker_data.iterrows():
        buy_signal, sell_signal = trading_logic(ticker_data.loc[:date])

        if buy_signal and balance >= max_trade_amount:
            # Buy as many shares as possible with the current balance
            shares_to_buy = max_trade_amount / row['Close']
            shares_owned += shares_to_buy
            balance -= shares_to_buy * row['Close']
            trade_log.append(f"Day {date}: Bought {shares_to_buy:.4f} shares at ${row['Close']:.2f}")

        elif sell_signal and shares_owned > 0:
            # Sell all shares owned
            balance += shares_owned * row['Close']
            trade_log.append(f"Day {date}: Sold shares at ${row['Close']:.2f}")
            shares_owned = 0

    total_profit = balance - 200
    return total_profit, len(trade_log), trade_log

# Run simulation for each market condition
def simulate_trades():
    results = {}

    # Bull market simulation
    print("Running simulation for bull_market from 2023-01-01 to 2023-06-30")
    bull_profit, bull_trades, bull_log = simulate_trades_for_condition("2023-01-01", "2023-06-30")
    results["bull_market"] = {
        "Profit": bull_profit,
        "Total Trades": bull_trades,
        "Sample Trades": bull_log[:10]  # Show first 10 trades for reference
    }

    # Bear market simulation
    print("Running simulation for bear_market from 2023-07-01 to 2023-12-31")
    bear_profit, bear_trades, bear_log = simulate_trades_for_condition("2023-07-01", "2023-12-31")
    results["bear_market"] = {
        "Profit": bear_profit,
        "Total Trades": bear_trades,
        "Sample Trades": bear_log[:10]
    }

    # Sideways market simulation
    print("Running simulation for sideways_market from 2023-03-01 to 2023-09-30")
    sideways_profit, sideways_trades, sideways_log = simulate_trades_for_condition("2023-03-01", "2023-09-30")
    results["sideways_market"] = {
        "Profit": sideways_profit,
        "Total Trades": sideways_trades,
        "Sample Trades": sideways_log[:10]
    }

    return results

# Run and print the simulation results
results = simulate_trades()
for condition, metrics in results.items():
    print(f"Results for {condition}: Profit=${metrics['Profit']:.2f}, Total Trades={metrics['Total Trades']}")
    print("Sample Trades:", metrics["Sample Trades"])

# Adjusted trading logic with even more relaxed conditions
def trading_logic(ticker_data):
    buy_signal = False
    sell_signal = False

    # Calculate RSI, MACD, and Bollinger Bands
    rsi = calculate_rsi(ticker_data['Close'])
    macd, signal_line = calculate_macd(ticker_data['Close'])
    bollinger = calculate_bollinger_bands(ticker_data['Close'])

    # Even more flexible buy condition
    if rsi.iloc[-1] < 70 and macd.iloc[-1] > signal_line.iloc[-1]:
        buy_signal = True

    # Even more flexible sell condition
    elif rsi.iloc[-1] > 30 and macd.iloc[-1] < signal_line.iloc[-1]:
        sell_signal = True

    return buy_signal, sell_signal

# Simulate trading for a given condition
def simulate_trades_for_condition(start_date, end_date):
    ticker_data = fetch_historical_data('AAPL', start=start_date, end=end_date)
    trade_log = []
    balance = 200  # Starting balance
    max_trade_amount = 5  # Maximum trade amount
    shares_owned = 0

    for date, row in ticker_data.iterrows():
        buy_signal, sell_signal = trading_logic(ticker_data.loc[:date])

        if buy_signal and balance >= max_trade_amount:
            # Buy as many shares as possible with the current balance
            shares_to_buy = max_trade_amount / row['Close']
            shares_owned += shares_to_buy
            balance -= shares_to_buy * row['Close']
            trade_log.append(f"Day {date}: Bought {shares_to_buy:.4f} shares at ${row['Close']:.2f}")

        elif sell_signal and shares_owned > 0:
            # Sell all shares owned
            balance += shares_owned * row['Close']
            trade_log.append(f"Day {date}: Sold shares at ${row['Close']:.2f}")
            shares_owned = 0

    total_profit = balance - 200
    return total_profit, len(trade_log), trade_log

# Run simulation for each market condition
def simulate_trades():
    results = {}

    # Bull market simulation
    print("Running simulation for bull_market from 2023-01-01 to 2023-06-30")
    bull_profit, bull_trades, bull_log = simulate_trades_for_condition("2023-01-01", "2023-06-30")
    results["bull_market"] = {
        "Profit": bull_profit,
        "Total Trades": bull_trades,
        "Sample Trades": bull_log[:10]  # Show first 10 trades for reference
    }

    # Bear market simulation
    print("Running simulation for bear_market from 2023-07-01 to 2023-12-31")
    bear_profit, bear_trades, bear_log = simulate_trades_for_condition("2023-07-01", "2023-12-31")
    results["bear_market"] = {
        "Profit": bear_profit,
        "Total Trades": bear_trades,
        "Sample Trades": bear_log[:10]
    }

    # Sideways market simulation
    print("Running simulation for sideways_market from 2023-03-01 to 2023-09-30")
    sideways_profit, sideways_trades, sideways_log = simulate_trades_for_condition("2023-03-01", "2023-09-30")
    results["sideways_market"] = {
        "Profit": sideways_profit,
        "Total Trades": sideways_trades,
        "Sample Trades": sideways_log[:10]
    }

    return results

# Run and print the simulation results
results = simulate_trades()
for condition, metrics in results.items():
    print(f"Results for {condition}: Profit=${metrics['Profit']:.2f}, Total Trades={metrics['Total Trades']}")
    print("Sample Trades:", metrics["Sample Trades"])

# List of top 25 stocks to trade on
top_25_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'FB', 'NFLX', 'BRK.B', 'V',
                 'JPM', 'UNH', 'HD', 'PG', 'MA', 'DIS', 'BAC', 'KO', 'PFE', 'XOM', 'INTC', 'CSCO', 'PEP', 'CMCSA', 'ADBE']

# Adjusted stop-loss and take-profit
stop_loss_percentage = 0.02  # 2% stop-loss
take_profit_percentage = 0.05  # 5% take-profit

def execute_trade_decision(price, buy_price, action):
    if action == "BUY":
        return price
    elif action == "SELL":
        return price
    elif action == "HOLD":
        # Evaluate if stop-loss or take-profit conditions are hit
        if buy_price is not None:
            price_change = (price - buy_price) / buy_price
            if price_change <= -stop_loss_percentage:
                print(f"Stop-loss triggered. Selling at {price}.")
                return price
            elif price_change >= take_profit_percentage:
                print(f"Take-profit triggered. Selling at {price}.")
                return price
        return None

# Fine-tuning RSI and MACD thresholds
rsi_buy_threshold = 35  # Buy when RSI is lower than 35 (more aggressive in bear markets)
rsi_sell_threshold = 65  # Sell when RSI is higher than 65

# Re-run the simulation for the top 25 stocks
def simulate_trades_with_top_25_stocks():
    market_conditions = ["bull_market", "bear_market", "sideways_market"]
    results = {}

    for condition in market_conditions:
        if condition == "bull_market":
            start_date = "2023-01-01"
            end_date = "2023-06-30"
        elif condition == "bear_market":
            start_date = "2023-07-01"
            end_date = "2023-12-31"
        else:
            start_date = "2023-03-01"
            end_date = "2023-09-30"

        print(f"Running simulation for {condition} from {start_date} to {end_date}")

        # Initialize overall metrics
        total_profit = 0
        total_trades = 0
        winning_trades = 0
        losing_trades = 0

        # Loop through each stock in the top 25
        for stock in top_25_stocks:
            print(f"Fetching data for {stock} from {start_date} to {end_date}")
            ticker_data = fetch_historical_data(stock, start=start_date, end=end_date)
            stock_trades = []  # Keep track of individual stock trades

            # Simulate trades for each stock
            for i in range(len(ticker_data)):
                price = ticker_data['Close'][i]
                # Implement buy/sell logic based on RSI/MACD/Bollinger Bands
                action = select_action(price)
                trade_price = execute_trade_decision(price, None, action)
                if trade_price:
                    stock_trades.append(trade_price)

            # Calculate profit for the stock and update overall metrics
            profit = sum(stock_trades)  # Simple profit calculation, improve as needed
            total_profit += profit
            total_trades += len(stock_trades)
            if profit > 0:
                winning_trades += 1
            else:
                losing_trades += 1

        # Store results for the current market condition
        results[condition] = {
            'Profit': total_profit,
            'Total Trades': total_trades,
            'Winning Trades': winning_trades,
            'Losing Trades': losing_trades
        }

    return results

# Run the simulation with top 25 stocks
results = simulate_trades_with_top_25_stocks()

# Display the results
for condition, metrics in results.items():
    print(f"Results for {condition}: {metrics}")

import yfinance as yf
import pandas as pd

# Fetch historical data (adjust this for your top 25 tickers)
def fetch_historical_data(ticker, start, end):
    ticker_data = yf.download(ticker, start=start, end=end, interval="1m")
    return ticker_data

# Simulate trading on the provided data
def simulate_trades(ticker_data, starting_balance, max_trade_amount=5):
    total_balance = starting_balance
    trade_log = []
    total_trades = 0
    winning_trades = 0
    losing_trades = 0

    for i in range(len(ticker_data) - 1):
        price = ticker_data['Close'].iloc[i]
        next_price = ticker_data['Close'].iloc[i + 1]

        # Simulate a buy
        shares_bought = max_trade_amount / price
        total_trades += 1

        # Calculate profit/loss
        profit = (next_price - price) * shares_bought
        total_balance += profit

        # Log the trade and its outcome
        if profit > 0:
            winning_trades += 1
        else:
            losing_trades += 1

        trade_log.append(f"Day {ticker_data.index[i]}: Bought {shares_bought:.4f} shares at ${price:.2f}, Sold at ${next_price:.2f}, Profit: ${profit:.2f}")

    return total_balance, total_trades, winning_trades, losing_trades, trade_log

# Run the simulation for different market conditions
def simulate_market_conditions():
    conditions = {
        'bull_market': ('2023-01-01', '2023-06-30'),
        'bear_market': ('2023-07-01', '2023-12-31'),
        'sideways_market': ('2023-03-01', '2023-09-30')
    }

    results = {}
    for condition, (start_date, end_date) in conditions.items():
        print(f"Running simulation for {condition} from {start_date} to {end_date}")
        ticker_data = fetch_historical_data('AAPL', start=start_date, end=end_date)  # Replace 'AAPL' with the tickers you want
        final_balance, total_trades, winning_trades, losing_trades, trade_log = simulate_trades(ticker_data, starting_balance=200)

        results[condition] = {
            'Final Balance': final_balance,
            'Total Trades': total_trades,
            'Winning Trades': winning_trades,
            'Losing Trades': losing_trades,
            'Sample Trades': trade_log[:10]  # Limit to first 10 trades for sample output
        }

    return results

# Run the simulation
market_results = simulate_market_conditions()

# Display results
for market_condition, metrics in market_results.items():
    print(f"Results for {market_condition}: Final Balance=${metrics['Final Balance']:.2f}, Total Trades={metrics['Total Trades']}, Winning Trades={metrics['Winning Trades']}, Losing Trades={metrics['Losing Trades']}")
    print(f"Sample Trades: {metrics['Sample Trades']}")

import yfinance as yf
import pandas as pd

# Fetch historical data (adjust this for your top 25 tickers)
def fetch_historical_data(ticker, start, end):
    # Use daily interval instead of 1-minute to allow for longer periods
    ticker_data = yf.download(ticker, start=start, end=end, interval="1d")
    return ticker_data

# Simulate trading on the provided data
def simulate_trades(ticker_data, starting_balance, max_trade_amount=5):
    total_balance = starting_balance
    trade_log = []
    total_trades = 0
    winning_trades = 0
    losing_trades = 0

    for i in range(len(ticker_data) - 1):
        price = ticker_data['Close'].iloc[i]
        next_price = ticker_data['Close'].iloc[i + 1]

        # Simulate a buy
        shares_bought = max_trade_amount / price
        total_trades += 1

        # Calculate profit/loss
        profit = (next_price - price) * shares_bought
        total_balance += profit

        # Log the trade and its outcome
        if profit > 0:
            winning_trades += 1
        else:
            losing_trades += 1

        trade_log.append(f"Day {ticker_data.index[i]}: Bought {shares_bought:.4f} shares at ${price:.2f}, Sold at ${next_price:.2f}, Profit: ${profit:.2f}")

    return total_balance, total_trades, winning_trades, losing_trades, trade_log

# Run the simulation for different market conditions
def simulate_market_conditions():
    conditions = {
        'bull_market': ('2023-01-01', '2023-06-30'),
        'bear_market': ('2023-07-01', '2023-12-31'),
        'sideways_market': ('2023-03-01', '2023-09-30')
    }

    results = {}
    for condition, (start_date, end_date) in conditions.items():
        print(f"Running simulation for {condition} from {start_date} to {end_date}")
        ticker_data = fetch_historical_data('AAPL', start=start_date, end=end_date)  # Replace 'AAPL' with the tickers you want
        final_balance, total_trades, winning_trades, losing_trades, trade_log = simulate_trades(ticker_data, starting_balance=200)

        results[condition] = {
            'Final Balance': final_balance,
            'Total Trades': total_trades,
            'Winning Trades': winning_trades,
            'Losing Trades': losing_trades,
            'Sample Trades': trade_log[:10]  # Limit to first 10 trades for sample output
        }

    return results

# Run the simulation
market_results = simulate_market_conditions()

# Display results
for market_condition, metrics in market_results.items():
    print(f"Results for {market_condition}: Final Balance=${metrics['Final Balance']:.2f}, Total Trades={metrics['Total Trades']}, Winning Trades={metrics['Winning Trades']}, Losing Trades={metrics['Losing Trades']}")
    print(f"Sample Trades: {metrics['Sample Trades']}")

import pandas as pd

# Simulated historical stock data (you can expand or replace this with real data)
data = {
    'Date': pd.date_range(start='2023-01-01', periods=60, freq='D'),
    'Close': [150, 151, 149, 153, 150, 151, 152, 154, 155, 156,
              157, 158, 156, 154, 152, 153, 155, 156, 157, 158,
              159, 160, 161, 162, 163, 164, 162, 160, 158, 156,
              157, 159, 161, 163, 164, 165, 163, 161, 159, 160,
              162, 163, 164, 165, 166, 167, 166, 165, 163, 162,
              164, 165, 166, 168, 167, 169, 170, 171, 172, 173]
}

# Create DataFrame
ticker_data = pd.DataFrame(data)

# Initial balance and parameters
initial_balance = 200
balance = initial_balance
profit = 0
trade_log = []
max_trade_amount = 5  # Starting max trade amount

# Function to simulate a buy
def buy_shares(balance, price, max_trade_amount):
    trade_amount = min(max_trade_amount, balance)
    shares_bought = trade_amount / price
    balance -= trade_amount
    return shares_bought, balance

# Function to simulate a sell
def sell_shares(balance, price, shares_bought):
    sale_amount = shares_bought * price
    balance += sale_amount
    return balance

# Loop through simulated historical data
for i in range(len(ticker_data) - 1):
    # Buy shares
    price_buy = ticker_data['Close'][i]
    shares_bought, balance = buy_shares(balance, price_buy, max_trade_amount)
    trade_log.append(f"Day {i+1}: Bought {shares_bought:.4f} shares at ${price_buy}")

    # Sell shares
    price_sell = ticker_data['Close'][i+1]
    balance = sell_shares(balance, price_sell, shares_bought)
    profit += (price_sell - price_buy) * shares_bought
    trade_log.append(f"Day {i+1}: Sold shares at ${price_sell}, Profit: ${profit:.2f}")

    # Scale trade size based on profits
    if profit > 0:
        max_trade_amount += profit * 0.1  # Scale up trade size with 10% of profits

# Print results
print(f"Final Balance: ${balance:.2f}")
print(f"Total Profit: ${profit:.2f}")
print(f"Trade Log: {trade_log}")

import random
import numpy as np

# Hyperparameters
learning_rate = 0.1  # Update this based on performance
discount_factor = 0.9  # Future rewards consideration
epsilon = 1.0  # Exploration rate
epsilon_min = 0.1
epsilon_decay = 0.995

# Initialize the Q-table
q_table = {}

def select_action(state):
    if random.random() < epsilon:  # Explore
        return random.choice(["BUY", "SELL", "HOLD"])
    else:  # Exploit
        return max(q_table.get(state, {"BUY": 0, "SELL": 0, "HOLD": 0}), key=q_table.get)

def update_q_value(state, action, reward, next_state):
    current_value = q_table.get(state, {"BUY": 0, "SELL": 0, "HOLD": 0})[action]
    next_max = max(q_table.get(next_state, {"BUY": 0, "SELL": 0, "HOLD": 0}).values())
    # Update Q-value using the Bellman equation
    new_value = (1 - learning_rate) * current_value + learning_rate * (reward + discount_factor * next_max)
    q_table[state][action] = new_value

# Decay epsilon after each episode
def decay_epsilon():
    global epsilon
    if epsilon > epsilon_min:
        epsilon *= epsilon_decay

from collections import deque

# Initialize experience replay buffer
experience_replay = deque(maxlen=2000)

def store_experience(state, action, reward, next_state):
    experience_replay.append((state, action, reward, next_state))

# Use experiences to update Q-values
def replay_experience(batch_size=32):
    if len(experience_replay) < batch_size:
        return
    mini_batch = random.sample(experience_replay, batch_size)
    for state, action, reward, next_state in mini_batch:
        update_q_value(state, action, reward, next_state)

import numpy as np

# Initialize variables for metrics
total_profit = 0
winning_trades = 0
losing_trades = 0
trade_log = []

def log_trade(action, entry_price, exit_price):
    global total_profit, winning_trades, losing_trades, trade_log

    profit = exit_price - entry_price
    total_profit += profit
    trade_log.append(f"{action} | Entry: {entry_price}, Exit: {exit_price}, Profit: {profit:.2f}")

    if profit > 0:
        winning_trades += 1
    else:
        losing_trades += 1

def calculate_metrics():
    if len(trade_log) == 0:
        return {"Total Profit": 0, "Winning Trades": 0, "Losing Trades": 0, "Win Ratio": 0, "Loss Ratio": 0}

    win_ratio = winning_trades / len(trade_log) * 100
    loss_ratio = losing_trades / len(trade_log) * 100
    avg_profit_per_trade = total_profit / len(trade_log)

    metrics = {
        "Total Profit": total_profit,
        "Winning Trades": winning_trades,
        "Losing Trades": losing_trades,
        "Win Ratio": win_ratio,
        "Loss Ratio": loss_ratio,
        "Average Profit per Trade": avg_profit_per_trade,
    }

    return metrics

import time
import logging

# Configure logging
logging.basicConfig(filename='trading_errors.log', level=logging.ERROR)

def fetch_data_with_retry(ticker, start, end, max_retries=3):
    for attempt in range(max_retries):
        try:
            # Fetch historical data
            data = fetch_historical_data(ticker, start, end)  # replace with your fetch function
            return data
        except Exception as e:
            logging.error(f"Error fetching data for {ticker}: {str(e)} - Attempt {attempt + 1}")
            time.sleep(2)  # Wait before retrying
    raise Exception(f"Failed to fetch data for {ticker} after {max_retries} attempts.")

def execute_trade_with_retry(action, amount, ticker, max_retries=3):
    for attempt in range(max_retries):
        try:
            if action == "buy":
                # Replace with your buy function
                buy_stock(ticker, amount)
            elif action == "sell":
                # Replace with your sell function
                sell_stock(ticker, amount)
            return
        except Exception as e:
            logging.error(f"Error executing {action} for {ticker}: {str(e)} - Attempt {attempt + 1}")
            time.sleep(2)  # Wait before retrying
    raise Exception(f"Failed to execute {action} for {ticker} after {max_retries} attempts.")

class TradingPerformance:
    def __init__(self):
        self.total_profit = 0.0
        self.total_trades = 0
        self.winning_trades = 0
        self.losing_trades = 0
        self.max_drawdown = 0.0
        self.trade_log = []

    def record_trade(self, profit):
        self.total_profit += profit
        self.total_trades += 1
        self.trade_log.append(profit)

        if profit > 0:
            self.winning_trades += 1
        elif profit < 0:
            self.losing_trades += 1

        # Calculate maximum drawdown
        current_balance = self.total_profit + 200  # Assuming initial balance of $200
        peak_balance = max(current_balance, self.total_profit)
        self.max_drawdown = min(self.max_drawdown, peak_balance - current_balance)

    def summary(self):
        win_rate = (self.winning_trades / self.total_trades) * 100 if self.total_trades > 0 else 0
        average_profit = self.total_profit / self.total_trades if self.total_trades > 0 else 0
        return {
            "Total Profit": self.total_profit,
            "Total Trades": self.total_trades,
            "Winning Trades": self.winning_trades,
            "Losing Trades": self.losing_trades,
            "Win Rate (%)": win_rate,
            "Average Profit per Trade": average_profit,
            "Maximum Drawdown": self.max_drawdown,
        }

# Example of usage
performance = TradingPerformance()

# In your trading logic, after each trade
profit = trade_result  # Assume trade_result is the profit from the trade
performance.record_trade(profit)

# At the end of the trading session, print the summary
print(performance.summary())

class TradingPerformance:
    def __init__(self):
        self.total_profit = 0.0
        self.total_trades = 0
        self.winning_trades = 0
        self.losing_trades = 0
        self.max_drawdown = 0.0
        self.trade_log = []

    def record_trade(self, profit):
        self.total_profit += profit
        self.total_trades += 1
        self.trade_log.append(profit)

        if profit > 0:
            self.winning_trades += 1
        elif profit < 0:
            self.losing_trades += 1

        # Calculate maximum drawdown
        current_balance = self.total_profit + 200  # Assuming initial balance of $200
        peak_balance = max(current_balance, self.total_profit)
        self.max_drawdown = min(self.max_drawdown, peak_balance - current_balance)

    def summary(self):
        win_rate = (self.winning_trades / self.total_trades) * 100 if self.total_trades > 0 else 0
        average_profit = self.total_profit / self.total_trades if self.total_trades > 0 else 0
        return {
            "Total Profit": self.total_profit,
            "Total Trades": self.total_trades,
            "Winning Trades": self.winning_trades,
            "Losing Trades": self.losing_trades,
            "Win Rate (%)": win_rate,
            "Average Profit per Trade": average_profit,
            "Maximum Drawdown": self.max_drawdown,
        }

# Example of usage
performance = TradingPerformance()

# Trading logic
for trade in trade_log:  # Replace this with your actual trading logic
    # Calculate profit/loss for each trade
    buy_price = trade['buy_price']
    sell_price = trade['sell_price']
    profit = sell_price - buy_price  # Adjust this based on how you log trades

    # Record the trade
    performance.record_trade(profit)

# At the end of the trading session, print the summary
print(performance.summary())

print(f"Buying at {buy_price}, Selling at {sell_price}, Profit: {profit}")

buy_price = get_buy_price(day)  # Replace with your logic
print(f"Day {day}: Buy Price: {buy_price}")

def get_buy_price(day, stock_data):
    # Example logic to retrieve the buy price
    # Assuming stock_data is a DataFrame containing historical prices
    if day < len(stock_data):
        return stock_data.iloc[day]['Close']  # Return the close price as the buy price
    return None  # Return None if the day is out of range

# Assuming stock_data is a DataFrame containing historical data
for day in range(number_of_days):  # Loop through days
    # Get the buy price for the day
    buy_price = get_buy_price(day, stock_data)

    # Debugging print statement
    print(f"Day {day}: Buy Price: {buy_price}")

    if buy_price is not None:
        current_price = get_current_price(day)  # Fetch current price for the day
        # Assuming some condition to sell
        sell_price = get_sell_price(day)  # Your logic to determine sell price
        profit = sell_price - buy_price  # Calculate profit
        performance.record_trade(profit)  # Record the trade
        print(f"Day {day}: Bought at {buy_price}, Sold at {sell_price}, Profit: {profit}")
    else:
        print(f"Skipping trade on Day {day} because buy_price is None.")

# Assuming stock_data is a DataFrame containing historical data
number_of_days = len(stock_data)  # Set number of days to the length of the DataFrame

import yfinance as yf

# Function to fetch historical data
def fetch_historical_data(ticker, start_date, end_date):
    return yf.download(ticker, start=start_date, end=end_date, interval='1d')

# Function to get the buy price
def get_buy_price(day, stock_data):
    if day < len(stock_data):
        return stock_data.iloc[day]['Close']  # Return the close price as the buy price
    return None  # Return None if the day is out of range

# Fetch the historical stock data
stock_data = fetch_historical_data('AAPL', '2023-01-01', '2023-12-31')
number_of_days = len(stock_data)  # Define number_of_days

# Performance tracker
class Performance:
    def __init__(self):
        self.total_profit = 0.0
        self.total_trades = 0
        self.winning_trades = 0
        self.losing_trades = 0

    def record_trade(self, profit):
        self.total_profit += profit
        self.total_trades += 1
        if profit > 0:
            self.winning_trades += 1
        elif profit < 0:
            self.losing_trades += 1

performance = Performance()

# Trading loop
for day in range(number_of_days):  # Loop through days
    buy_price = get_buy_price(day, stock_data)  # Get the buy price for the day

    if buy_price is not None:
        current_price = stock_data.iloc[day]['Close']  # Get the current price for simplicity
        # Assuming some condition to sell (you can replace this with your actual selling logic)
        sell_price = current_price * 1.01  # Example: sell for 1% more than buy price
        profit = sell_price - buy_price  # Calculate profit
        performance.record_trade(profit)  # Record the trade
        print(f"Day {day}: Bought at {buy_price}, Sold at {sell_price}, Profit: {profit}")
    else:
        print(f"Skipping trade on Day {day} because buy_price is None.")

# Display performance metrics
print(f"Total Profit: {performance.total_profit}")
print(f"Total Trades: {performance.total_trades}")
print(f"Winning Trades: {performance.winning_trades}")
print(f"Losing Trades: {performance.losing_trades}")

def execute_trade(stock, buy_price, sell_price):
    profit = sell_price - buy_price
    return profit

def trade_on_stocks(stock_data):
    total_profit = 0
    total_trades = 0
    winning_trades = 0
    losing_trades = 0

    for stock in stock_data:
        for day in range(len(stock_data[stock])):
            # Example buy and sell logic
            buy_price = stock_data[stock]['Close'][day]  # Replace with your logic for buying
            # Assume selling the next day for simplicity
            sell_price = stock_data[stock]['Close'][day + 1] if day + 1 < len(stock_data[stock]) else None

            if sell_price is not None:
                profit = execute_trade(stock, buy_price, sell_price)
                total_profit += profit
                total_trades += 1

                if profit > 0:
                    winning_trades += 1
                elif profit < 0:
                    losing_trades += 1

    return {
        'Total Profit': total_profit,
        'Total Trades': total_trades,
        'Winning Trades': winning_trades,
        'Losing Trades': losing_trades,
    }

def trade_with_risk_management(stock_data, stop_loss_percentage=0.02, take_profit_percentage=0.03):
    total_profit = 0
    total_trades = 0
    winning_trades = 0
    losing_trades = 0

    for stock in stock_data:
        for day in range(len(stock_data[stock])):
            buy_price = stock_data[stock]['Close'][day]  # Buy logic
            sell_price = stock_data[stock]['Close'][day + 1] if day + 1 < len(stock_data[stock]) else None

            if sell_price is not None:
                # Apply stop-loss and take-profit logic
                if sell_price <= buy_price * (1 - stop_loss_percentage):
                    # Stop-loss hit
                    profit = (sell_price - buy_price)
                    losing_trades += 1
                elif sell_price >= buy_price * (1 + take_profit_percentage):
                    # Take-profit hit
                    profit = (sell_price - buy_price)
                    winning_trades += 1
                else:
                    profit = 0  # No trade executed

                total_profit += profit
                total_trades += 1

    return {
        'Total Profit': total_profit,
        'Total Trades': total_trades,
        'Winning Trades': winning_trades,
        'Losing Trades': losing_trades,
    }

top_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'FB']  # Add your top 25 stocks
stock_data = {stock: fetch_historical_data(stock) for stock in top_stocks}

results = {}
for stock in top_stocks:
    results[stock] = trade_with_risk_management(stock_data[stock])

# Print results
for stock, metrics in results.items():
    print(f"Results for {stock}: {metrics}")

import yfinance as yf

def fetch_historical_data(ticker, start_date='2023-01-01', end_date='2023-12-31'):
    """Fetch historical stock data from Yahoo Finance."""
    try:
        stock_data = yf.download(ticker, start=start_date, end=end_date, interval='1d')
        return stock_data
    except Exception as e:
        print(f"Error fetching data for {ticker}: {e}")
        return None

top_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'FB']  # Add your top 25 stocks
stock_data = {stock: fetch_historical_data(stock, '2023-01-01', '2023-12-31') for stock in top_stocks}

results = {}
for stock in top_stocks:
    data = stock_data.get(stock)
    if data is not None:
        results[stock] = trade_with_risk_management(data)
    else:
        print(f"No data available for {stock}")

# Print results
for stock, metrics in results.items():
    print(f"Results for {stock}: {metrics}")

import yfinance as yf
import pandas as pd

def fetch_historical_data(ticker, start_date='2023-01-01', end_date='2023-12-31'):
    """Fetch historical stock data from Yahoo Finance."""
    try:
        stock_data = yf.download(ticker, start=start_date, end=end_date, interval='1d')
        print(stock_data.head())  # Inspect the first few rows of the DataFrame
        return stock_data
    except Exception as e:
        print(f"Error fetching data for {ticker}: {e}")
        return None

# Example usage for multiple stocks
top_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'FB']  # Add your top 25 stocks
stock_data = {stock: fetch_historical_data(stock) for stock in top_stocks}

# Check the keys and data types
for stock, data in stock_data.items():
    if data is not None:
        print(f"{stock} DataFrame:")
        print(data.info())  # Print info to see columns and data types

for day in range(number_of_days):  # Adjust as necessary
    # Get the closing price from the DataFrame
    price = data.iloc[day]['Close']  # Access the 'Close' column
    print(f"Day {day}: Price: {price}")

# Assuming 'data' is your DataFrame fetched from yfinance
number_of_days = len(data)  # Get the number of available rows in the DataFrame

for day in range(number_of_days):  # Loop through available days
    # Get the closing price from the DataFrame
    price = data.iloc[day]['Close']  # Access the 'Close' column
    print(f"Day {day}: Price: {price}")

print(data.head())  # Check the first few rows of the DataFrame
print(data.info())  # Check the structure and the number of rows

if not data.empty:
    number_of_days = len(data)
    for day in range(number_of_days):
        price = data.iloc[day]['Close']
        print(f"Day {day}: Price: {price}")
else:
    print("DataFrame is empty, no data available for this stock.")

import yfinance as yf

def fetch_historical_data(ticker, start_date, end_date):
    try:
        data = yf.download(ticker, start=start_date, end=end_date)
        if data.empty:
            print(f"No data available for {ticker} from {start_date} to {end_date}.")
        return data
    except Exception as e:
        print(f"Error fetching data for {ticker}: {e}")
        return pd.DataFrame()  # Return an empty DataFrame on error

# Example usage
top_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'FB']  # Add your top 25 stocks
start_date = "2023-01-01"
end_date = "2023-06-30"

# Fetch historical data for all stocks
stock_data = {stock: fetch_historical_data(stock, start_date, end_date) for stock in top_stocks}

# Check which stocks have data
for stock, data in stock_data.items():
    if data.empty:
        print(f"{stock} has no data.")
    else:
        print(f"Data for {stock} retrieved successfully with {len(data)} entries.")

top_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META']  # Update 'FB' to 'META'

# Fetch historical data for all stocks again
stock_data = {stock: fetch_historical_data(stock, start_date, end_date) for stock in top_stocks}

# Check which stocks have data
for stock, data in stock_data.items():
    if data.empty:
        print(f"{stock} has no data.")
    else:
        print(f"Data for {stock} retrieved successfully with {len(data)} entries.")

import pandas as pd
import numpy as np

# Example function to implement your trading logic
def trading_logic(stock_data, initial_balance=200):
    balance = initial_balance
    position = 0  # Number of shares currently held
    trade_log = []

    for index, row in stock_data.iterrows():
        price = row['Close']  # Assuming you're using the 'Close' price
        rsi_value = calculate_rsi(stock_data['Close'], window=14)  # Replace with your RSI calculation
        macd_value = calculate_macd(stock_data['Close'])  # Replace with your MACD calculation

        # Trading logic
        if rsi_value < 30 and balance >= price:  # Buy condition
            shares_to_buy = balance // price
            position += shares_to_buy
            balance -= shares_to_buy * price
            trade_log.append(f"Day {index}: Bought {shares_to_buy} shares at {price}")

        elif rsi_value > 70 and position > 0:  # Sell condition
            balance += position * price
            trade_log.append(f"Day {index}: Sold {position} shares at {price}, Profit: {position * (price - trade_price)}")
            position = 0  # Reset position after selling

    # Final balance
    final_balance = balance + position * price  # Include any remaining shares' value
    return final_balance, trade_log

# Example usage with your stock data
for stock, data in stock_data.items():
    if not data.empty:
        final_balance, log = trading_logic(data)
        print(f"{stock} Final Balance: ${final_balance:.2f}")
        print("Trade Log:", log)

import pandas as pd
import numpy as np

# Example function to implement your trading logic
def trading_logic(stock_data, initial_balance=200):
    balance = initial_balance
    position = 0  # Number of shares currently held
    trade_log = []

    # Calculate indicators once outside the loop
    stock_data['RSI'] = calculate_rsi(stock_data['Close'], window=14)
    stock_data['MACD'] = calculate_macd(stock_data['Close'])

    for index, row in stock_data.iterrows():
        price = row['Close']  # Current price
        rsi_value = row['RSI']
        macd_value = row['MACD']

        # Trading logic
        if rsi_value < 30 and balance >= price:  # Buy condition
            shares_to_buy = balance // price
            position += shares_to_buy
            balance -= shares_to_buy * price
            trade_log.append(f"Day {index}: Bought {shares_to_buy} shares at {price}")

        elif rsi_value > 70 and position > 0:  # Sell condition
            balance += position * price
            profit = position * (price - row['Close'])  # Calculate profit
            trade_log.append(f"Day {index}: Sold {position} shares at {price}, Profit: {profit:.2f}")
            position = 0  # Reset position after selling

    # Final balance
    final_balance = balance + position * price  # Include any remaining shares' value
    return final_balance, trade_log

# Example usage with your stock data
for stock, data in stock_data.items():
    if not data.empty:
        final_balance, log = trading_logic(data)
        print(f"{stock} Final Balance: ${final_balance:.2f}")
        print("Trade Log:", log)

import pandas as pd
import numpy as np

# Define your RSI calculation function
def calculate_rsi(prices, window=14):
    delta = prices.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

# Define your MACD calculation function
def calculate_macd(prices, short_window=12, long_window=26, signal_window=9):
    short_ema = prices.ewm(span=short_window, adjust=False).mean()
    long_ema = prices.ewm(span=long_window, adjust=False).mean()
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_window, adjust=False).mean()
    return macd - signal  # MACD line

# Example trading logic
def trading_logic(stock_data, initial_balance=200):
    balance = initial_balance
    position = 0  # Number of shares currently held
    trade_log = []

    # Calculate indicators and add them to the DataFrame
    stock_data['RSI'] = calculate_rsi(stock_data['Close'])
    stock_data['MACD'] = calculate_macd(stock_data['Close'])

    for index, row in stock_data.iterrows():
        price = row['Close']  # Current price
        rsi_value = row['RSI']
        macd_value = row['MACD']

        # Trading logic
        if rsi_value < 30 and balance >= price:  # Buy condition
            shares_to_buy = balance // price
            position += shares_to_buy
            balance -= shares_to_buy * price
            trade_log.append(f"Day {index}: Bought {shares_to_buy} shares at {price}")

        elif rsi_value > 70 and position > 0:  # Sell condition
            balance += position * price
            profit = position * (price - row['Close'])  # Calculate profit
            trade_log.append(f"Day {index}: Sold {position} shares at {price}, Profit: {profit:.2f}")
            position = 0  # Reset position after selling

    # Final balance
    final_balance = balance + position * price  # Include any remaining shares' value
    return final_balance, trade_log

# Example usage with your stock data
for stock, data in stock_data.items():
    if not data.empty:
        final_balance, log = trading_logic(data)
        print(f"{stock} Final Balance: ${final_balance:.2f}")
        print("Trade Log:", log)

def trading_logic_with_profit_scaling(data, initial_balance=200, max_trade_percentage=0.05):
    balance = initial_balance
    trade_log = []
    total_shares = 0

    for day in range(len(data)):
        # Get the closing price of the stock
        close_price = data['Close'].iloc[day]

        # Calculate trade amount (5% of balance)
        trade_amount = balance * max_trade_percentage

        # Calculate how many shares we can buy
        shares_to_buy = trade_amount / close_price

        # Simulate buying on odd days and selling on even days
        if day % 2 == 0:
            total_shares += shares_to_buy
            balance -= shares_to_buy * close_price
            trade_log.append(f"Day {data.index[day]}: Bought {shares_to_buy:.4f} shares at {close_price}")
        else:
            balance += total_shares * close_price
            trade_log.append(f"Day {data.index[day]}: Sold {total_shares:.4f} shares at {close_price}, Profit: {total_shares * close_price}")
            total_shares = 0

    final_balance = balance
    return final_balance, trade_log

top_25_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META']  # Add your full top 25 list here
stock_data = {stock: fetch_historical_data(stock) for stock in top_25_stocks}

for stock, data in stock_data.items():
    if not data.empty:
        final_balance, log = trading_logic_with_profit_scaling(data)
        print(f"{stock} Final Balance: ${final_balance:.2f}")
        print("Trade Log:", log[:5])  # Print first 5 trades for brevity

top_25_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META']  # Add your full top 25 list here
start_date = '2023-01-01'
end_date = '2023-06-30'

# Fetch historical data with start and end dates
stock_data = {stock: fetch_historical_data(stock, start_date, end_date) for stock in top_25_stocks}

# Loop through each stock's data and run the trading logic
for stock, data in stock_data.items():
    if not data.empty:
        final_balance, log = trading_logic_with_profit_scaling(data)
        print(f"{stock} Final Balance: ${final_balance:.2f}")
        print("Trade Log:", log[:5])  # Print first 5 trades for brevity

# Adjusted trading logic to reinvest profits and scale trade sizes
def trading_logic(stock_data, initial_balance=200.0, trade_size=5.0):
    balance = initial_balance
    trade_log = []
    for day in range(len(stock_data)):
        # Get price data for the current day
        price = stock_data['Close'].iloc[day]

        # Adjust the trade size based on current balance (scaled trades with profits)
        current_trade_size = min(trade_size, balance / price)

        # Buy logic
        if day % 2 == 0:  # Example buy condition
            shares_bought = current_trade_size / price
            balance -= shares_bought * price
            trade_log.append(f"Day {day}: Bought {shares_bought:.4f} shares at {price:.2f}")

        # Sell logic
        elif day % 2 == 1:  # Example sell condition
            shares_sold = current_trade_size / price
            balance += shares_sold * price
            profit = shares_sold * (price - stock_data['Close'].iloc[day - 1])
            trade_log.append(f"Day {day}: Sold shares at {price:.2f}, Profit: {profit:.2f}")

    return balance, trade_log


# Fetch historical data for the top 25 stocks
top_25_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META']  # Add the rest of your top 25 stocks
stock_data = {stock: fetch_historical_data(stock, '2023-01-01', '2023-06-30') for stock in top_25_stocks}

# Run the trading logic on each stock and log results
for stock, data in stock_data.items():
    if not data.empty:
        final_balance, log = trading_logic(data)
        print(f"{stock} Final Balance: ${final_balance:.2f}")
        print("Trade Log:", log)

# List of top 25 stocks for the backtest
top_25_stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA', 'NVDA', 'NFLX', 'ADBE', 'PYPL',
                 'INTC', 'CSCO', 'ORCL', 'AMD', 'QCOM', 'CRM', 'BABA', 'BA', 'DIS', 'V',
                 'MA', 'JPM', 'WMT', 'HD', 'PG']

# Initialize stock data dictionary
stock_data = {}

# Fetch historical data for all top 25 stocks
for stock in top_25_stocks:
    print(f"Fetching data for {stock}")
    stock_data[stock] = fetch_historical_data(stock, start_date='2023-01-01', end_date='2023-12-31')

# Run the trading bot for all stocks
for stock, data in stock_data.items():
    if not data.empty:
        print(f"Running backtest for {stock}")
        final_balance, trade_log = trading_logic(data)
        print(f"{stock} Final Balance: ${final_balance:.2f}")
        print(f"{stock} Trade Log: {trade_log}")
    else:
        print(f"No data for {stock}")

import pandas as pd

# Sample performance metrics for each stock
performance_data = {
    'Stock': ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META'],
    'Total Profit': [198.17, 199.13, 196.94, 196.77, 198.31],
    'Total Trades': [122, 125, 123, 128, 126],
    'Winning Trades': [70, 68, 67, 69, 72],
    'Losing Trades': [52, 57, 56, 59, 54],
    'Win Rate (%)': [57.38, 54.4, 54.47, 53.91, 57.14],
    'Average Profit per Trade': [1.62, 1.59, 1.60, 1.54, 1.57]
}

# Create a DataFrame for easy reading
df_performance = pd.DataFrame(performance_data)

# Display the DataFrame
print(df_performance)

# If you are in a Jupyter notebook or Google Colab, you can also use this:
df_performance.style.format({
    'Total Profit': '${:,.2f}',
    'Average Profit per Trade': '${:,.2f}',
    'Win Rate (%)': '{:.2f}%',
    'Total Trades': '{:,.0f}',
    'Winning Trades': '{:,.0f}',
    'Losing Trades': '{:,.0f}'
})

from twilio.rest import Client

# Twilio credentials
account_sid = 'ACa5985a497c5e83be2657929f9fb6028b'
auth_token = 'e3b93b3e0f6296d5aacc2c9646bc3347'
client = Client(account_sid, auth_token)

def send_sms(message):
    client.messages.create(
        body=message,
        from_='+18775365923',
        to='+16314877979'
    )

# Example usage inside the bot
send_sms("Trade executed: Bought XYZ at $100")

!pip install twilio

import time
from twilio.rest import Client

# Twilio credentials
account_sid = 'ACa5985a497c5e83be2657929f9fb6028b'
auth_token = 'e3b93b3e0f6296d5aacc2c9646bc3347'
client = Client(account_sid, auth_token)

# Initialize variables to track daily profit and trade activity
total_profit = 0
total_trades = 0
winning_trades = 0
losing_trades = 0

# This function sends the SMS
def send_sms_update(message):
    client.messages.create(
        to="+16314877979",  # Replace with your phone number
        from_="+18775365923",  # Replace with your Twilio number
        body=message
    )

# Function to calculate profit/loss and send hourly updates
def calculate_profit_loss_and_send_alert(hour, trades_log):
    global total_profit, total_trades, winning_trades, losing_trades

    # Calculate the profit/loss for the past hour and the entire day
    hourly_profit = sum([trade['profit'] for trade in trades_log if trade['hour'] == hour])
    total_profit += hourly_profit
    trades_in_hour = len([trade for trade in trades_log if trade['hour'] == hour])
    total_trades += trades_in_hour
    winning_trades_in_hour = len([trade for trade in trades_log if trade['profit'] > 0 and trade['hour'] == hour])
    losing_trades_in_hour = trades_in_hour - winning_trades_in_hour
    winning_trades += winning_trades_in_hour
    losing_trades += losing_trades_in_hour

    # AI Insights (e.g., win rate, learning strategy)
    win_rate = (winning_trades / total_trades) * 100 if total_trades > 0 else 0

    # Create the message
    message = (
        f"Hour: {hour}\n"
        f"Profit this hour: ${hourly_profit:.2f}\n"
        f"Total Profit: ${total_profit:.2f}\n"
        f"Trades this hour: {trades_in_hour}\n"
        f"Winning trades: {winning_trades_in_hour}, Losing trades: {losing_trades_in_hour}\n"
        f"Total trades today: {total_trades}, Win rate: {win_rate:.2f}%\n"
        "AI is learning from the results and adjusting the strategy."
    )

    # Send the message via Twilio
    send_sms_update(message)

# Function to simulate the trading logic every hour
def run_hourly_trading_simulation():
    trades_log = []  # To store hourly trades and their profits/losses
    for hour in range(9, 17):  # Assume trading happens from 9 AM to 4 PM
        # Simulate trades for the hour (you can replace this with your actual trading logic)
        trades_in_hour = [{'hour': hour, 'profit': random.uniform(-5, 10)} for _ in range(random.randint(1, 5))]
        trades_log.extend(trades_in_hour)

        # Calculate profit/loss and send alert for this hour
        calculate_profit_loss_and_send_alert(hour, trades_log)

        # Sleep for 1 hour (for real implementation) or use time.sleep(3600)
        time.sleep(1)  # For testing, it waits for 1 second instead of 1 hour

# Start the simulation
run_hourly_trading_simulation()

from twilio.rest import Client

# Twilio credentials (use your actual credentials)
account_sid = 'ACa5985a497c5e83be2657929f9fb6028b'  # Your account SID
auth_token = 'e3b93b3e0f6296d5aacc2c9646bc3347'  # Your auth token
client = Client(account_sid, auth_token)

# Your phone number and Twilio number
to_phone = "+16314877979"  # Replace with your phone number
from_phone = "+18775365923"  # Replace with your Twilio number

# Test SMS message
message_body = "Test SMS from Twilio. The system is working correctly."

# Send the SMS
message = client.messages.create(
    to=to_phone,
    from_=from_phone,
    body=message_body
)

print(f"Message sent with SID: {message.sid}")

from twilio.rest import Client

# Twilio credentials
account_sid = 'ACa5985a497c5e83be2657929f9fb6028b'
auth_token = 'e3b93b3e0f6296d5aacc2c9646bc3347'

client = Client(account_sid, auth_token)

# Sending a test message to your phone
message = client.messages.create(
    body="This is a test message from Day Trader AI.",
    from_='+18775365923',  # Your Twilio number
    to='+16314877979'  # Your personal number
)

print(f"Message sent with SID: {message.sid}")

!curl 'https://api.twilio.com/2010-04-01/Accounts/ACa5985a497c5e83be2657929f9fb6028b/Messages.json' -X POST \
--data-urlencode 'To=+16314877979' \
--data-urlencode 'From=+18775365923' \
--data-urlencode 'Body=test' \
-u ACa5985a497c5e83be2657929f9fb6028b:e3b93b3e0f6296d5aacc2c9646bc3347

!curl 'https://api.twilio.com/2010-04-01/Accounts/ACa5985a497c5e83be2657929f9fb6028b/Messages.json' -X POST \
--data-urlencode 'To=+16314877979' \
--data-urlencode 'From=+18775365923' \
--data-urlencode 'Body=test' \
-u ACa5985a497c5e83be2657929f9fb6028b:e3b93b3e0f6296d5aacc2c9646bc3347

import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

def send_email_report(profit, trades, performance_log):
    from_email = 'rmaherbridge@gmail.com'
    to_email = 'rmaherbridge@gmail.com'
    password = 'Medubridge1313!'

    # Setup the MIME
    message = MIMEMultipart()
    message['From'] = from_email
    message['To'] = to_email
    message['Subject'] = 'Daily Trading Report'

    body = f"Today's Profit: ${profit}\n\nTrades: {trades}\n\nPerformance: {performance_log}"
    message.attach(MIMEText(body, 'plain'))

    # SMTP session
    session = smtplib.SMTP('smtp.gmail.com', 587)
    session.starttls()  # Enable security
    session.login(from_email, password)  # Login with email and password

    text = message.as_string()
    session.sendmail(from_email, to_email, text)
    session.quit()
    print('Email Sent!')

# Example call to the function
send_email_report(profit=200, trades="Buy AAPL at $150, Sell AAPL at $155", performance_log="Great performance!")

import csv
import os

# Function to log performance
def log_performance(profit, trades, performance_log):
    file_exists = os.path.isfile('trading_performance_log.csv')

    # Open the CSV file in append mode, or create if it doesn't exist
    with open('trading_performance_log.csv', mode='a', newline='') as file:
        writer = csv.writer(file)

        # Write headers if the file is new
        if not file_exists:
            writer.writerow(['Hour', 'Profit', 'Trades', 'Performance Log'])

        # Log the current performance
        writer.writerow([get_current_time(), profit, trades, performance_log])

# Example of logging
log_performance(profit=200, trades="Buy AAPL at $150, Sell AAPL at $155", performance_log="Great performance!")

import csv
import os
from datetime import datetime

# Function to get the current time
def get_current_time():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

# Function to log performance
def log_performance(profit, trades, performance_log):
    file_exists = os.path.isfile('trading_performance_log.csv')

    # Open the CSV file in append mode, or create if it doesn't exist
    with open('trading_performance_log.csv', mode='a', newline='') as file:
        writer = csv.writer(file)

        # Write headers if the file is new
        if not file_exists:
            writer.writerow(['Hour', 'Profit', 'Trades', 'Performance Log'])

        # Log the current performance with the timestamp
        writer.writerow([get_current_time(), profit, trades, performance_log])

# Example of logging
log_performance(profit=200, trades="Buy AAPL at $150, Sell AAPL at $155", performance_log="Great performance!")

def execute_trade(data):
    # Your trading logic here
    buy_price = data['Close'][0]  # Example: replace with your actual trading logic
    sell_price = data['Close'][1]  # Example: replace with your actual trading logic

    profit = sell_price - buy_price
    trade_log = f"Buy at {buy_price}, Sell at {sell_price}"

    # Log the trade and performance after the trade
    log_performance(profit=profit, trades=trade_log, performance_log="Trade executed successfully.")

    return profit

# Example function call
execute_trade(data)

import time

# Loop to simulate running trades and logging every hour (3600 seconds)
while True:
    # Simulate executing a trade (replace with your actual trading function)
    profit = execute_trade(data)

    # Sleep for an hour (3600 seconds)
    time.sleep(3600)  # 1 hour in seconds

def execute_trade(data):
    try:
        # Replace this with actual trading logic
        buy_price = data['Close'][0]  # Example logic
        sell_price = data['Close'][1]  # Example logic

        profit = sell_price - buy_price
        trade_log = f"Buy at {buy_price}, Sell at {sell_price}"

        # Log performance after the trade
        log_performance(profit=profit, trades=trade_log, performance_log="Trade executed successfully.")

        return profit

    except Exception as e:
        print(f"Error executing trade: {e}")
        return None

# Call this function for testing
execute_trade(data)

import time

# Run this loop to log performance every hour
for i in range(3):  # Test for 3 iterations to simulate 3 hours
    profit = execute_trade(data)  # Replace with your actual data

    # Print profit after each iteration to track execution
    print(f"Iteration {i + 1}: Profit {profit}")

    # Sleep for 10 seconds (for faster testing, change to 3600 for real hourly automation)
    time.sleep(10)  # Sleep for 10 seconds (for test) or 3600 (for 1-hour interval)

import re

# Load your original script
with open('daiy_trader (8).py', 'r') as file:
    script_content = file.read()

# Remove shell commands like `!pip install`, `!ping`, and so on
cleaned_content = re.sub(r"^!.*", "", script_content, flags=re.MULTILINE)

# Remove Alpha Vantage-related code (TimeSeries and Alpha Vantage API references)
cleaned_content = re.sub(r"from alpha_vantage.*\n", "", cleaned_content)
cleaned_content = re.sub(r"ts = TimeSeries\(.*\n", "", cleaned_content)
cleaned_content = re.sub(r"data, _ = ts.get_daily\(.*\n", "", cleaned_content)
cleaned_content = re.sub(r"all_data.to_csv\(\"historical_data_alpha_vantage.csv\"\)\n", "", cleaned_content)

# Replace Alpha Vantage with Yahoo Finance code
yahoo_finance_code = '''
import yfinance as yf
import pandas as pd

# List of stock tickers you want to fetch data for
tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "FB", "NFLX", "NVDA", "BRK-B", "JPM",
           "V", "UNH", "HD", "PG", "DIS", "VZ", "MA", "INTC", "CMCSA", "CSCO",
           "PEP", "ADBE", "NKE", "T"]

# Initialize an empty DataFrame
all_data = pd.DataFrame()

# Fetch historical data using Yahoo Finance
for ticker in tickers:
    data = yf.download(ticker, start='2022-01-01', end='2024-01-01')
    data['Ticker'] = ticker
    all_data = all_data.append(data)

# Save the combined DataFrame to a CSV file
all_data.to_csv("historical_data_yahoo_finance.csv")
'''

# Append Yahoo Finance code to the cleaned script
cleaned_content += yahoo_finance_code

# Save the cleaned script as a new file
with open('cleaned_daiy_trader_yf.py', 'w') as cleaned_file:
    cleaned_file.write(cleaned_content)

print("Cleaned script saved as 'cleaned_daiy_trader_yf.py'")

import re

# Load your original script
with open('daiy_trader (8).py', 'r') as file:
    script_content = file.read()

# Remove shell commands like `!pip install`, `!ping`, and so on
cleaned_content = re.sub(r"^!.*", "", script_content, flags=re.MULTILINE)

# Remove Alpha Vantage-related code (TimeSeries and Alpha Vantage API references)
cleaned_content = re.sub(r"from alpha_vantage.*\n", "", cleaned_content)
cleaned_content = re.sub(r"ts = TimeSeries\(.*\n", "", cleaned_content)
cleaned_content = re.sub(r"data, _ = ts.get_daily\(.*\n", "", cleaned_content)
cleaned_content = re.sub(r"all_data.to_csv\(\"historical_data_alpha_vantage.csv\"\)\n", "", cleaned_content)

# Replace Alpha Vantage with Yahoo Finance code
yahoo_finance_code = '''
import yfinance as yf
import pandas as pd

# List of stock tickers you want to fetch data for
tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "FB", "NFLX", "NVDA", "BRK-B", "JPM",
           "V", "UNH", "HD", "PG", "DIS", "VZ", "MA", "INTC", "CMCSA", "CSCO",
           "PEP", "ADBE", "NKE", "T"]

# Initialize an empty DataFrame
all_data = pd.DataFrame()

# Fetch historical data using Yahoo Finance
for ticker in tickers:
    data = yf.download(ticker, start='2022-01-01', end='2024-01-01')
    data['Ticker'] = ticker
    all_data = all_data.append(data)

# Save the combined DataFrame to a CSV file
all_data.to_csv("historical_data_yahoo_finance.csv")
'''

# Append Yahoo Finance code to the cleaned script
cleaned_content += yahoo_finance_code

# Save the cleaned script as a new file
with open('cleaned_daiy_trader_yf.py', 'w') as cleaned_file:
    cleaned_file.write(cleaned_content)

print("Cleaned script saved as 'cleaned_daiy_trader_yf.py'")

import yfinance as yf
import pandas as pd

# List of stock tickers you want to fetch data for
tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "FB", "NFLX", "NVDA", "BRK-B", "JPM",
           "V", "UNH", "HD", "PG", "DIS", "VZ", "MA", "INTC", "CMCSA", "CSCO",
           "PEP", "ADBE", "NKE", "T"]

# Initialize an empty DataFrame to store all stock data
all_data = pd.DataFrame()

# Fetch historical data for each ticker
for ticker in tickers:
    stock_data = yf.download(ticker, start='2020-01-01', end='2024-01-01')  # Adjust the dates if necessary
    stock_data['Ticker'] = ticker
    all_data = pd.concat([all_data, stock_data])

# Save the data to a CSV file
all_data.to_csv("historical_data_yahoo_finance.csv")

# Updated list of stock tickers you want to fetch data for
tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "META", "NFLX", "NVDA", "BRK-B", "JPM",
           "V", "UNH", "HD", "PG", "DIS", "VZ", "MA", "INTC", "CMCSA", "CSCO",
           "PEP", "ADBE", "NKE", "T"]

import yfinance as yf
import pandas as pd

# List of stock tickers you want to fetch data for
tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "META", "NFLX", "NVDA", "BRK-B", "JPM",
           "V", "UNH", "HD", "PG", "DIS", "VZ", "MA", "INTC", "CMCSA", "CSCO",
           "PEP", "ADBE", "NKE", "T"]

# Empty list to store DataFrames
data_frames = []

# Fetch data for each ticker
for ticker in tickers:
    data

import yfinance as yf
import pandas as pd

# List of stock tickers you want to fetch data for
tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "META", "NFLX", "NVDA", "BRK-B", "JPM",
           "V", "UNH", "HD", "PG", "DIS", "VZ", "MA", "INTC", "CMCSA", "CSCO",
           "PEP", "ADBE", "NKE", "T"]

# Empty list to store DataFrames
data_frames = []

# Fetch data for each ticker using Yahoo Finance
for ticker in tickers:
    data = yf.download(ticker, period='1y')  # Fetch 1 year of historical data for the ticker
    data['Ticker'] = ticker  # Add the ticker column to the DataFrame
    data_frames.append(data)  # Append the DataFrame to the list

# Concatenate all DataFrames into one
all_data = pd.concat(data_frames)

# Save the combined DataFrame to a CSV file
all_data.to_csv("historical_data_yahoo_finance.csv")

print("Data fetched and saved to historical_data_yahoo_finance.csv")

import pandas as pd
all_data = pd.read_csv("historical_data_yahoo_finance.csv")
all_data.head()

import talib as ta

# Load the data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Calculate RSI, MACD, and Bollinger Bands
all_data['RSI'] = ta.RSI(all_data['Close'], timeperiod=14)
all_data['MACD'], all_data['MACD_Signal'], all_data['MACD_Hist'] = ta.MACD(all_data['Close'], fastperiod=12, slowperiod=26, signalperiod=9)
all_data['Upper_Band'], all_data['Middle_Band'], all_data['Lower_Band'] = ta.BBANDS(all_data['Close'], timeperiod=20)

# Display a sample of the data with the new indicators
print(all_data[['Date', 'Close', 'RSI', 'MACD', 'MACD_Signal', 'Upper_Band', 'Middle_Band', 'Lower_Band']].tail())

# Save the data with indicators back to a CSV file
all_data.to_csv("data_with_indicators.csv", index=False)

!apt-get install -y python3-dev
!pip install TA-Lib

def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    short_ema = data['Close'].ewm(span=short_window, adjust=False).mean()
    long_ema = data['Close'].ewm(span=long_window, adjust=False).mean()
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_window, adjust=False).mean()
    return macd, signal

def calculate_bollinger_bands(data, window=20, num_std_dev=2):
    rolling_mean = data['Close'].rolling(window).mean()
    rolling_std = data['Close'].rolling(window).std()
    upper_band = rolling_mean + (rolling_std * num_std_dev)
    lower_band = rolling_mean - (rolling_std * num_std_dev)
    return upper_band, lower_band

# Load your data
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Calculate indicators
all_data['RSI'] = calculate_rsi(all_data)
all_data['MACD'], all_data['MACD_Signal'] = calculate_macd(all_data)
all_data['Upper_BB'], all_data['Lower_BB'] = calculate_bollinger_bands(all_data)

# Save the data with indicators to a new CSV
all_data.to_csv("historical_data_with_indicators.csv", index=False)

print("Indicators calculated and data saved.")

import pandas as pd
import numpy as np

# Define the RSI calculation function
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Define the MACD calculation function
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    short_ema = data['Close'].ewm(span=short_window, adjust=False).mean()
    long_ema = data['Close'].ewm(span=long_window, adjust=False).mean()
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_window, adjust=False).mean()
    return macd, signal

# Define the Bollinger Bands calculation function
def calculate_bollinger_bands(data, window=20, num_std_dev=2):
    rolling_mean = data['Close'].rolling(window).mean()
    rolling_std = data['Close'].rolling(window).std()
    upper_band = rolling_mean + (rolling_std * num_std_dev)
    lower_band = rolling_mean - (rolling_std * num_std_dev)
    return upper_band, lower_band

# Load your data
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Calculate indicators
all_data['RSI'] = calculate_rsi(all_data)
all_data['MACD'], all_data['MACD_Signal'] = calculate_macd(all_data)
all_data['Upper_BB'], all_data['Lower_BB'] = calculate_bollinger_bands(all_data)

# Save the data with indicators to a new CSV
all_data.to_csv("historical_data_with_indicators.csv", index=False)

print("Indicators calculated and data saved.")

import yfinance as yf
import pandas as pd

# List of stock tickers to fetch data for
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA',
           'NVDA', 'BRK.B', 'JPM', 'V', 'UNH', 'JNJ',
           'PG', 'HD', 'DIS', 'NFLX', 'VZ', 'INTC',
           'CMCSA', 'PEP', 'T', 'MRK', 'NKE', 'ADBE', 'CSCO']

# Fetch data for each ticker
data_frames = []
for ticker in tickers:
    data = yf.download(ticker, period='1y')
    data['Ticker'] = ticker
    data_frames.append(data)

# Concatenate all DataFrames into one
all_data = pd.concat(data_frames)

# Save the combined DataFrame to a CSV file
all_data.to_csv("historical_data_yahoo_finance.csv", index=False)

print("Data fetched and saved to historical_data_yahoo_finance.csv")

import yfinance as yf
import pandas as pd

# List of stock tickers to fetch data for
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA',
           'NVDA', 'BRK-B', 'JPM', 'V', 'UNH', 'JNJ',
           'PG', 'HD', 'DIS', 'NFLX', 'VZ', 'INTC',
           'CMCSA', 'PEP', 'T', 'MRK', 'NKE', 'ADBE', 'CSCO']

# Fetch data for each ticker
data_frames = []
for ticker in tickers:
    data = yf.download(ticker, period='1y')
    data['Ticker'] = ticker
    data_frames.append(data)

# Concatenate all DataFrames into one
all_data = pd.concat(data_frames)

# Save the combined DataFrame to a CSV file
all_data.to_csv("historical_data_yahoo_finance.csv", index=False)

print("Data fetched and saved to historical_data_yahoo_finance.csv")

import pandas as pd

# Load the data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Calculate Simple Moving Average (SMA)
def calculate_sma(data, window):
    return data['Adj Close'].rolling(window=window).mean()

# Calculate Bollinger Bands
def calculate_bollinger_bands(data, window=20):
    sma = calculate_sma(data, window)
    std = data['Adj Close'].rolling(window=window).std()
    upper_band = sma + (std * 2)
    lower_band = sma - (std * 2)
    return upper_band, lower_band

# Add indicators to the data
all_data['RSI'] = calculate_rsi(all_data)
all_data['SMA_50'] = calculate_sma(all_data, 50)
all_data['SMA_200'] = calculate_sma(all_data, 200)
all_data['Upper Band'], all_data['Lower Band'] = calculate_bollinger_bands(all_data)

# Save the data with indicators
all_data.to_csv("data_with_indicators.csv", index=False)

print("Indicators calculated and saved to data_with_indicators.csv")

import pandas as pd
import numpy as np

# Q-learning parameters
q_table = {}  # Q-table to store state-action pairs
learning_rate = 0.1  # How fast the agent learns
discount_factor = 0.95  # Discount future rewards
epsilon = 0.1  # Exploration-exploitation tradeoff
actions = ["buy", "sell", "hold"]

# Initialize capital, position, and reward
capital = 200
position = 0
buy_price = 0
reward_log = []

# Function to choose action based on epsilon-greedy policy
def choose_action(state):
    if np.random.rand() < epsilon:
        return np.random.choice(actions)  # Explore: random action
    else:
        return max(q_table.get(state, {}), key=q_table.get(state, {}).get, default="hold")  # Exploit: best action

# Function to update Q-values
def update_q_table(state, action, reward, next_state):
    if state not in q_table:
        q_table[state] = {a: 0 for a in actions}  # Initialize state
    max_next = max(q_table[next_state].values(), default=0)
    q_table[state][action] = q_table[state][action] + learning_rate * (reward + discount_factor * max_next - q_table[state][action])

# Load data
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Loop through the data and apply Q-learning
for index, row in all_data.iterrows():
    state = (row['RSI'], row['Adj Close'], row['Upper Band'], row['Lower Band'])  # Define state as relevant indicators
    action = choose_action(state)  # Choose action based on the current state

    if action == "buy" and position == 0 and row['RSI'] < 30 and row['Adj Close'] <= row['Lower Band']:
        buy_price = row['Adj Close']
        position = capital / buy_price
        capital = 0
        reward_log.append(f"Bought at {buy_price} on {row['Date']}")

    elif action == "sell" and position > 0 and row['RSI'] > 70 and row['Adj Close'] >= row['Upper Band']:
        sell_price = row['Adj Close']
        capital = position * sell_price
        position = 0
        reward_log.append(f"Sold at {sell_price} on {row['Date']}")

    # Update the Q-table with rewards
    next_state = (row['RSI'], row['Adj Close'], row['Upper Band'], row['Lower Band'])
    reward = capital - buy_price if action == "sell" else 0
    update_q_table(state, action, reward, next_state)

# Final capital after all trades
if position > 0:
    capital = position * all_data.iloc[-1]['Adj Close']
    reward_log.append(f"Sold remaining stock at {all_data.iloc[-1]['Adj Close']} on {all_data.iloc[-1]['Date']}")

# Print final results
print(f"Final capital: {capital}")
print(f"Trade history: {reward_log}")

import pandas as pd
import numpy as np
import yfinance as yf

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff(1)
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    avg_gain = gain.rolling(window=window, min_periods=1).mean()
    avg_loss = loss.rolling(window=window, min_periods=1).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Load data from Yahoo Finance
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Calculate RSI and add it to the DataFrame
all_data['RSI'] = calculate_rsi(all_data)

# Check if the RSI column is calculated properly
print(all_data[['RSI', 'Adj Close']].head())  # Print to verify RSI calculation

# Now you can run the trading logic (Q-learning) after ensuring RSI is calculated

# Q-learning parameters
q_table = {}  # Q-table to store state-action pairs
learning_rate = 0.1  # How fast the agent learns
discount_factor = 0.95  # Discount future rewards
epsilon = 0.1  # Exploration-exploitation tradeoff
actions = ["buy", "sell", "hold"]

# Initialize capital, position, and reward
capital = 200
position = 0
buy_price = 0
reward_log = []

# Function to choose action based on epsilon-greedy policy
def choose_action(state):
    if np.random.rand() < epsilon:
        return np.random.choice(actions)  # Explore: random action
    else:
        return max(q_table.get(state, {}), key=q_table.get(state, {}).get, default="hold")  # Exploit: best action

# Function to update Q-values
def update_q_table(state, action, reward, next_state):
    if state not in q_table:
        q_table[state] = {a: 0 for a in actions}  # Initialize state
    max_next = max(q_table[next_state].values(), default=0)
    q_table[state][action] = q_table[state][action] + learning_rate * (reward + discount_factor * max_next - q_table[state][action])

# Loop through the data and apply Q-learning
for index, row in all_data.iterrows():
    state = (row['RSI'], row['Adj Close'])  # Use RSI and price as state
    action = choose_action(state)  # Choose action based on the current state

    if action == "buy" and position == 0 and row['RSI'] < 30:
        buy_price = row['Adj Close']
        position = capital / buy_price
        capital = 0
        reward_log.append(f"Bought at {buy_price} on {row['Date']}")

    elif action == "sell" and position > 0 and row['RSI'] > 70:
        sell_price = row['Adj Close']
        capital = position * sell_price
        position = 0
        reward_log.append(f"Sold at {sell_price} on {row['Date']}")

    # Update the Q-table with rewards
    next_state = (row['RSI'], row['Adj Close'])
    reward = capital - buy_price if action == "sell" else 0
    update_q_table(state, action, reward, next_state)

# Final capital after all trades
if position > 0:
    capital = position * all_data.iloc[-1]['Adj Close']
    reward_log.append(f"Sold remaining stock at {all_data.iloc[-1]['Adj Close']} on {all_data.iloc[-1]['Date']}")

# Print final results
print(f"Final capital: {capital}")
print(f"Trade history: {reward_log}")

import pandas as pd
import numpy as np
import yfinance as yf

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff(1)
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    avg_gain = gain.rolling(window=window, min_periods=1).mean()
    avg_loss = loss.rolling(window=window, min_periods=1).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Load data from Yahoo Finance
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Ensure the data has a 'Date' column and set it as index
if 'Date' not in all_data.columns:
    all_data['Date'] = pd.to_datetime(all_data.index)

# Set Date as index if it's not already
if 'Date' not in all_data.columns:
    all_data.set_index('Date', inplace=True)

# Calculate RSI and add it to the DataFrame
all_data['RSI'] = calculate_rsi(all_data)

# Drop NaN values from RSI if they exist
all_data.dropna(subset=['RSI'], inplace=True)

# Check the data and columns to ensure everything is correct
print(all_data[['RSI', 'Adj Close']].head())  # Check first few rows of RSI
print(all_data.columns)  # Verify that Date, RSI, and other columns are present

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff(1)  # Calculate price changes
    gain = delta.where(delta > 0, 0)   # Gains (positive price changes)
    loss = -delta.where(delta < 0, 0)  # Losses (negative price changes)

    # Calculate the rolling average of the gains and losses
    avg_gain = gain.rolling(window=window, min_periods=window).mean()
    avg_loss = loss.rolling(window=window, min_periods=window).mean()

    # Compute the relative strength (RS) and RSI
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    # Return the RSI, filling NaN values for the first window period
    rsi = rsi.fillna(50)  # Assign neutral RSI of 50 where it's NaN
    return rsi

# Load the data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Set Date as index if it's not already
if 'Date' not in all_data.columns:
    all_data['Date'] = pd.to_datetime(all_data.index)

if all_data.index.name != 'Date':
    all_data.set_index('Date', inplace=True)

# Calculate RSI and add it to the DataFrame
all_data['RSI'] = calculate_rsi(all_data)

# Drop NaN values from RSI
all_data.dropna(subset=['RSI'], inplace=True)

# Check the first few rows of the DataFrame
print(all_data[['RSI', 'Adj Close']].head())

# Load the data from the CSV file, ensuring the Date column is correctly parsed
all_data = pd.read_csv("historical_data_yahoo_finance.csv", parse_dates=['Date'])

# Set the 'Date' column as the index
if 'Date' in all_data.columns:
    all_data.set_index('Date', inplace=True)

# Verify that the Date index is now correctly set
print(all_data.index)  # This should show actual dates, not timestamps from 1970.

# Recalculate RSI if needed
all_data['RSI'] = calculate_rsi(all_data)

# Import pandas
import pandas as pd

# Load the data from the CSV file, ensuring the Date column is correctly parsed
all_data = pd.read_csv("historical_data_yahoo_finance.csv", parse_dates=['Date'])

# Set the 'Date' column as the index
if 'Date' in all_data.columns:
    all_data.set_index('Date', inplace=True)

# Verify that the Date index is now correctly set
print(all_data.index)  # This should show actual dates, not timestamps from 1970.

# Recalculate RSI if needed
all_data['RSI'] = calculate_rsi(all_data)

import yfinance as yf
import pandas as pd

# List of tickers
tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "META", "TSLA", "NVDA", "BRK-B", "JPM", "V", "UNH", "HD", "PG", "DIS", "VZ", "MA", "INTC", "CMCSA", "CSCO", "PEP", "ADBE", "NKE", "T"]

# Create an empty list to store the data for each stock
data_frames = []

# Fetch data for each ticker
for ticker in tickers:
    data = yf.download(ticker, period="1y")
    data['Ticker'] = ticker
    data_frames.append(data)

# Concatenate all DataFrames into one
all_data = pd.concat(data_frames)

# Save the combined DataFrame to a CSV file
all_data.to_csv("historical_data_yahoo_finance.csv", index=False)

print("Data fetched and saved to historical_data_yahoo_finance.csv")

import pandas as pd

# Load the data from the CSV file, ensuring the Date column is correctly parsed
all_data = pd.read_csv("historical_data_yahoo_finance.csv", parse_dates=['Date'])

# Set the 'Date' column as the index if it's not already the index
if 'Date' in all_data.columns:
    all_data.set_index('Date', inplace=True)

# Drop rows where RSI is missing, if necessary
all_data.dropna(subset=['RSI'], inplace=True)

# Check the data and columns to ensure everything is correct
print(all_data[['RSI', 'Adj Close']].head())  # Check first few rows of RSI
print(all_data.columns)  # Verify that Date, RSI, and other columns are present

import pandas as pd

# Load the data without parsing the Date column
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Print the first few rows and the column names to check the structure
print(all_data.head())
print(all_data.columns)

import pandas as pd

# Load the data
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Since no Date column exists, we'll create an artificial Date column assuming data is ordered by time
# Starting from a fixed date (for example, 2020-01-01)
all_data['Date'] = pd.date_range(start='2020-01-01', periods=len(all_data), freq='B')

# Set the 'Date' column as the index
all_data.set_index('Date', inplace=True)

# Print the first few rows to check
print(all_data.head())

# Now we can proceed with the RSI and other calculations
all_data['RSI'] = calculate_rsi(all_data)
print(all_data[['RSI', 'Adj Close']].head())

import pandas as pd

# Define the RSI calculation function
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Calculate the RSI for the data
all_data['RSI'] = calculate_rsi(all_data)

# Print the first few rows of the calculated RSI
print(all_data[['RSI', 'Adj Close']].head())

import pandas as pd

# Load the data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv", parse_dates=['Date'])

# Set the 'Date' column as the index if it's not already the index
if 'Date' in all_data.columns:
    all_data.set_index('Date', inplace=True)

# Print the first few rows to ensure it's loaded properly
print(all_data.head())

import pandas as pd

# Load the data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Print the first few rows to confirm the structure
print(all_data.head())

# Define the RSI calculation function
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Calculate the RSI for the data
all_data['RSI'] = calculate_rsi(all_data)

# Print the first few rows of the calculated RSI
print(all_data[['RSI', 'Adj Close']].head())

import pandas as pd

# Define the RSI calculation function
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    # Avoid division by zero for the first few rows
    rs = gain / loss.replace(0, 1)  # Replace zero loss with 1 to avoid division errors
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Calculate the RSI for the data
all_data['RSI'] = calculate_rsi(all_data)

# Print the first few rows of the calculated RSI
print(all_data[['RSI', 'Adj Close']].head(20))  # Display first 20 rows to check RSI values

# Initialize lists to store buy/sell signals
buy_signals = []
sell_signals = []

# Iterate over the data to generate buy/sell signals
for i in range(len(all_data)):
    if all_data['RSI'].iloc[i] < 30:
        buy_signals.append(all_data['Adj Close'].iloc[i])  # Buy signal
        sell_signals.append(None)
    elif all_data['RSI'].iloc[i] > 70:
        sell_signals.append(all_data['Adj Close'].iloc[i])  # Sell signal
        buy_signals.append(None)
    else:
        buy_signals.append(None)
        sell_signals.append(None)

# Add the signals to the DataFrame
all_data['Buy Signal'] = buy_signals
all_data['Sell Signal'] = sell_signals

# Print the first few rows to check signals
print(all_data[['RSI', 'Adj Close', 'Buy Signal', 'Sell Signal']].head(20))

import pandas as pd

# Load the historical data
all_data = pd.read_csv("historical_data_yahoo_finance.csv", parse_dates=['Date'], index_col='Date')

# Display the first few rows of the data
print(all_data.head())

import pandas as pd

# Load the historical data
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Display the first few rows to verify the data
print(all_data.head())

# Define the RSI calculation function
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Calculate the RSI for the data
all_data['RSI'] = calculate_rsi(all_data)

# Parameters
initial_balance = 200.0
balance = initial_balance
max_daily_loss = 50.0
trade_amount = 5.0  # $5 per trade
daily_loss = 0.0
profits = 0.0

# Function to calculate position size
def calculate_position(balance, trade_amount):
    return min(balance, trade_amount)

# Loop through the data and simulate trades
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']

    # Buy if RSI < 30
    if rsi < 30 and balance > trade_amount:
        position_size = calculate_position(balance, trade_amount)
        balance -= position_size
        profits += position_size * (price / 100)
        print(f"Buying at {price} with position size: {position_size}")

    # Sell if RSI > 70
    elif rsi > 70:
        balance += profits
        daily_loss += position_size * (price / 100)
        print(f"Selling at {price}, daily loss: {daily_loss}")

    # Stop trading if daily loss exceeds the max allowed
    if daily_loss >= max_daily_loss:
        print("Max daily loss reached, stopping trades for today.")
        break

# Final balance and profits
print(f"Final balance: {balance}")
print(f"Total profits: {profits}")

# Parameters
initial_balance = 200.0
balance = initial_balance
max_daily_loss = 50.0
trade_amount = 5.0  # $5 per trade
daily_loss = 0.0
profits = 0.0
position_size = 0.0  # Initialize position size

# Function to calculate position size
def calculate_position(balance, trade_amount):
    return min(balance, trade_amount)

# Loop through the data and simulate trades
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']

    # Buy if RSI < 30
    if rsi < 30 and balance > trade_amount:
        position_size = calculate_position(balance, trade_amount)
        balance -= position_size
        profits += position_size * (price / 100)
        print(f"Buying at {price} with position size: {position_size}")

    # Sell if RSI > 70
    elif rsi > 70 and position_size > 0:  # Only sell if a position was bought
        balance += profits
        daily_loss += position_size * (price / 100)
        position_size = 0  # Reset position size after selling
        print(f"Selling at {price}, daily loss: {daily_loss}")

    # Stop trading if daily loss exceeds the max allowed
    if daily_loss >= max_daily_loss:
        print("Max daily loss reached, stopping trades for today.")
        break

# Final balance and profits
print(f"Final balance: {balance}")
print(f"Total profits: {profits}")

# Set the initial balance and max loss percentage (e.g., 10% of balance)
balance = 200.0
max_loss_percentage = 0.10  # 10% of the balance

# Calculate the max daily loss based on the balance
max_daily_loss = balance * max_loss_percentage

# Initialize daily loss tracking
daily_loss = 0.0

# Simulation of trades and applying max daily loss logic
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']
    position_size = 5.0  # or dynamically adjust based on the balance

    # Check RSI to decide buy/sell
    if rsi < 30:
        print(f"Buying at {price} with position size: {position_size}")
        balance -= position_size
    elif rsi > 70:
        profits = position_size * (price / 100)  # Simplified profit calculation
        balance += profits
        daily_loss += position_size * (price / 100)
        print(f"Selling at {price}, daily loss: {daily_loss}")

    # Stop trading if max daily loss is reached
    if daily_loss >= max_daily_loss:
        print(f"Max daily loss reached: {daily_loss}, stopping trades for today.")
        break

# After trading day
print(f"Final balance: {balance}")
print(f"Total profits: {balance - 200.0}")

import pandas as pd

# Load the historical data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Ensure the necessary columns are present
print(all_data.columns)

# Calculate the RSI again (if it wasn't done before in this script)
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

all_data['RSI'] = calculate_rsi(all_data)

# Set up initial balance and limits
initial_balance = 200  # Adjust the starting balance
balance = initial_balance
max_daily_loss = 0.05 * balance  # Set the max daily loss to 5% of the balance
daily_loss = 0
profits = 0

# Simulation of trades and applying max daily loss logic
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']

    # Buy when RSI is below 40
    if rsi < 40 and daily_loss < max_daily_loss:
        position_size = balance * 0.05  # For example, using 5% of the balance per trade
        balance -= position_size
        print(f"Buying at {price} with position size: {position_size}")

    # Sell when RSI is above 60
    elif rsi > 60:
        profits += position_size * (price / 100)
        balance += profits
        print(f"Selling at {price}, current balance: {balance}")

    # Stop trading if max daily loss is reached
    if daily_loss >= max_daily_loss:
        print(f"Max daily loss of {max_daily_loss} reached, stopping for the day.")
        break

print(f"Final balance: {balance}")
print(f"Total profits: {profits}")

import yfinance as yf
import pandas as pd

# List of stock tickers you want to fetch data for
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA']

# Fetch historical data for each ticker and save into a single DataFrame
data_frames = []
for ticker in tickers:
    data = yf.download(ticker, period="1y")  # You can adjust the period as needed
    data['Ticker'] = ticker
    data_frames.append(data)

# Concatenate all DataFrames into one
all_data = pd.concat(data_frames)

# Save the combined DataFrame to a CSV file
all_data.to_csv("historical_data_yahoo_finance.csv", index=True)

print("Data fetched and saved to historical_data_yahoo_finance.csv")

import pandas as pd

# Load the historical data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Calculate the RSI
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

all_data['RSI'] = calculate_rsi(all_data)

# Set up initial balance and limits
initial_balance = 200  # Adjust the starting balance
balance = initial_balance
max_daily_loss = 0.05 * balance  # Set the max daily loss to 5% of the balance
daily_loss = 0
profits = 0

# Simulation of trades and applying max daily loss logic
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']

    # Buy when RSI is below 40
    if rsi < 40 and daily_loss < max_daily_loss:
        position_size = balance * 0.05  # For example, using 5% of the balance per trade
        balance -= position_size
        print(f"Buying at {price} with position size: {position_size}")

    # Sell when RSI is above 60
    elif rsi > 60:
        profits += position_size * (price / 100)
        balance += profits
        print(f"Selling at {price}, current balance: {balance}")

    # Stop trading if max daily loss is reached
    if daily_loss >= max_daily_loss:
        print(f"Max daily loss of {max_daily_loss} reached, stopping for the day.")
        break

print(f"Final balance: {balance}")
print(f"Total profits: {profits}")

import yfinance as yf
import pandas as pd

# Define the RSI calculation function
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Fetch historical data
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA']
data_frames = []
for ticker in tickers:
    data = yf.download(ticker, period="1y")
    data['Ticker'] = ticker
    data_frames.append(data)

all_data = pd.concat(data_frames)
all_data.to_csv("historical_data_yahoo_finance.csv", index=True)
print("Data fetched and saved to historical_data_yahoo_finance.csv")

# Load the historical data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Calculate the RSI for the data
all_data['RSI'] = calculate_rsi(all_data)

# Initialize variables for balance and profit tracking
initial_balance = 200  # Starting balance
balance = initial_balance
position_size = 0
max_daily_loss = 0.05 * balance  # Set max daily loss to 5% of the balance
daily_loss = 0
profits = 0

# Iterate through the data for trades
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']

    # Buy when RSI is below 40 and daily loss is below the limit
    if rsi < 40 and daily_loss < max_daily_loss:
        position_size = balance * 0.05  # Using 5% of the balance per trade
        balance -= position_size
        print(f"Buying at {price} with position size: {position_size}")

    # Sell when RSI is above 60
    elif rsi > 60 and position_size > 0:
        profits = position_size * (price / 100)  # Calculate profits
        balance += profits  # Add profits back to balance
        print(f"Selling at {price}, current balance: {balance}")
        position_size = 0  # Reset position size after selling

    # Check for max daily loss
    if daily_loss >= max_daily_loss:
        print(f"Max daily loss of {max_daily_loss} reached, stopping for the day.")
        break

# Final output
print(f"Final balance: {balance}")
print(f"Total profits: {profits}")

# Initialize variables for balance and profit tracking
initial_balance = 200  # Starting balance
balance = initial_balance
position_size = 0
max_daily_loss = 0.05 * balance  # Set max daily loss to 5% of the balance
daily_loss = 0
profits = 0
min_balance_threshold = 1  # Set a minimum balance to stop trading

# Simulation of trades and applying max daily loss logic
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']

    # Check if the balance is too low to continue
    if balance < min_balance_threshold:
        print(f"Balance is below the minimum threshold. Stopping trading.")
        break

    # Buy when RSI is below 40 and daily loss is below the limit
    if rsi < 40 and daily_loss < max_daily_loss:
        position_size = balance * 0.05  # Using 5% of the balance per trade
        balance -= position_size
        print(f"Buying at {price} with position size: {position_size}")

    # Sell when RSI is above 60 and there is a position to sell
    elif rsi > 60 and position_size > 0:
        profits = position_size * (price / 100)  # Calculate profits
        balance += profits  # Add profits back to balance
        print(f"Selling at {price}, current balance: {balance}")
        position_size = 0  # Reset position size after selling

    # Check for max daily loss
    if daily_loss >= max_daily_loss:
        print(f"Max daily loss of {max_daily_loss} reached, stopping for the day.")
        break

# Final output
print(f"Final balance: {balance}")
print(f"Total profits: {profits}")

# Parameters
initial_balance = 200.0
balance = initial_balance
max_daily_loss = 50.0
trade_amount = 5.0  # $5 per trade
daily_loss = 0.0
profits = 0.0
position_size = 0.0  # Initialize position size

# Function to calculate position size
def calculate_position(balance, trade_amount):
    return min(balance, trade_amount)

# Loop through the data and simulate trades
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']

    # Adjust the max_daily_loss as profits increase (e.g., 25% of profits)
    max_daily_loss = 50.0 + (0.25 * profits)

    # Buy if RSI < 30
    if rsi < 30 and balance > trade_amount:
        position_size = calculate_position(balance, trade_amount)
        balance -= position_size
        profits += position_size * (price / 100)
        print(f"Buying at {price} with position size: {position_size}")

    # Sell if RSI > 70
    elif rsi > 70 and position_size > 0:  # Only sell if a position was bought
        balance += profits
        daily_loss += position_size * (price / 100)
        position_size = 0  # Reset position size after selling
        print(f"Selling at {price}, daily loss: {daily_loss}")

    # Stop trading if daily loss exceeds the max allowed
    if daily_loss >= max_daily_loss:
        print(f"Max daily loss of {max_daily_loss} reached, stopping trades for today.")
        break

# Final balance and profits
print(f"Final balance: {balance}")
print(f"Total profits: {profits}")

# Parameters
initial_balance = 200.0
balance = initial_balance
max_daily_loss = 50.0
trade_amount = 5.0  # $5 per trade
daily_loss = 0.0
profits = 0.0
position_size = 0.0  # Initialize position size
max_loss_cap = 100.0  # Set a hard cap for daily loss

# Function to calculate position size
def calculate_position(balance, trade_amount):
    return min(balance, trade_amount)

# Loop through the data and simulate trades
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']

    # Adjust the max_daily_loss as profits increase (e.g., 10% of profits)
    max_daily_loss = min(50.0 + (0.10 * profits), max_loss_cap)

    # Buy if RSI < 30
    if rsi < 30 and balance > trade_amount:
        position_size = calculate_position(balance, trade_amount)
        balance -= position_size
        profits += position_size * (price / 100)
        print(f"Buying at {price} with position size: {position_size}")

    # Sell if RSI > 70
    elif rsi > 70 and position_size > 0:  # Only sell if a position was bought
        balance += profits
        daily_loss += position_size * (price / 100)
        position_size = 0  # Reset position size after selling
        print(f"Selling at {price}, daily loss: {daily_loss}")

    # Stop trading if daily loss exceeds the max allowed
    if daily_loss >= max_daily_loss:
        print(f"Max daily loss of {max_daily_loss} reached, stopping trades for today.")
        break

# Final balance and profits
print(f"Final balance: {balance}")
print(f"Total profits: {profits}")

# Parameters for simulation
initial_balance = 200.0
balance = initial_balance
max_daily_loss = 100.0  # Adjusting to $100 for this simulation
trade_amount = 5.0  # $5 per trade
daily_loss = 0.0
profits = 0.0
position_size = 0.0  # Initialize position size
max_days = 60  # Simulate for 60 days
days_simulated = 0

# Function to calculate position size
def calculate_position(balance, trade_amount):
    return min(balance, trade_amount)

# Loop through the data and simulate trades for 60 days
for index, row in all_data.iterrows():
    rsi = row['RSI']
    price = row['Adj Close']

    # Buy if RSI < 30
    if rsi < 30 and balance > trade_amount:
        position_size = calculate_position(balance, trade_amount)
        balance -= position_size
        profits += position_size * (price / 100)
        print(f"Buying at {price} with position size: {position_size}")

    # Sell if RSI > 70
    elif rsi > 70 and position_size > 0:
        balance += profits
        daily_loss += position_size * (price / 100)
        position_size = 0  # Reset position size after selling
        print(f"Selling at {price}, daily loss: {daily_loss}")

    # Stop trading if daily loss exceeds the max allowed
    if daily_loss >= max_daily_loss:
        print(f"Max daily loss of {max_daily_loss} reached, stopping trades for today.")
        days_simulated += 1
        daily_loss = 0  # Reset daily loss for the next day
        if days_simulated >= max_days:
            break

# Final balance and profits
print(f"Final balance after {days_simulated} days: {balance}")
print(f"Total profits after {days_simulated} days: {profits}")

import pandas as pd

# Parameters
initial_balance = 200.0
balance = initial_balance
max_daily_loss = 50.0
trade_amount = 5.0  # $5 per trade
daily_loss = 0.0
profits = 0.0
position_size = 0.0

# Function to calculate position size
def calculate_position(balance, trade_amount):
    return min(balance, trade_amount)

# Load the historical data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Loop through the data for 30 days and simulate trades
for day in range(30):
    daily_loss = 0.0  # Reset daily loss at the start of each day
    print(f"Day {day + 1}")

    for index, row in all_data.iterrows():
        rsi = row['RSI']
        price = row['Adj Close']

        # Buy if RSI < 30
        if rsi < 30 and balance > trade_amount:
            position_size = calculate_position(balance, trade_amount)
            balance -= position_size
            profits += position_size * (price / 100)
            print(f"Buying at {price} with position size: {position_size}")

        # Sell if RSI > 70
        elif rsi > 70 and position_size > 0:
            balance += profits
            daily_loss += position_size * (price / 100)
            position_size = 0  # Reset position size after selling
            print(f"Selling at {price}, daily loss: {daily_loss}")

        # Stop trading if daily loss exceeds the max allowed
        if daily_loss >= max_daily_loss:
            print(f"Max daily loss of {max_daily_loss} reached, stopping trades for today.")
            break

    # Increase the max daily loss as the balance grows
    max_daily_loss = 0.25 * balance  # 25% of the balance as max daily loss

# Final balance and profits
print(f"Final balance after 30 days: {balance}")
print(f"Total profits after 30 days: {profits}")

import pandas as pd

# Define the RSI calculation function
def calculate_rsi(data, window=14):
    delta = data['Adj Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Load the historical data from the CSV file
all_data = pd.read_csv("historical_data_yahoo_finance.csv")

# Calculate RSI if it's not already in the dataset
if 'RSI' not in all_data.columns:
    all_data['RSI'] = calculate_rsi(all_data)

# Now run the 30-day simulation
# Parameters
initial_balance = 200.0
balance = initial_balance
max_daily_loss = 50.0
trade_amount = 5.0  # $5 per trade
daily_loss = 0.0
profits = 0.0
position_size = 0.0

# Function to calculate position size
def calculate_position(balance, trade_amount):
    return min(balance, trade_amount)

# Loop through the data for 30 days and simulate trades
for day in range(30):
    daily_loss = 0.0  # Reset daily loss at the start of each day
    print(f"Day {day + 1}")

    for index, row in all_data.iterrows():
        rsi = row['RSI']
        price = row['Adj Close']

        # Buy if RSI < 30
        if rsi < 30 and balance > trade_amount:
            position_size = calculate_position(balance, trade_amount)
            balance -= position_size
            profits += position_size * (price / 100)
            print(f"Buying at {price} with position size: {position_size}")

        # Sell if RSI > 70
        elif rsi > 70 and position_size > 0:
            balance += profits
            daily_loss += position_size * (price / 100)
            position_size = 0  # Reset position size after selling
            print(f"Selling at {price}, daily loss: {daily_loss}")

        # Stop trading if daily loss exceeds the max allowed
        if daily_loss >= max_daily_loss:
            print(f"Max daily loss of {max_daily_loss} reached, stopping trades for today.")
            break

    # Increase the max daily loss as the balance grows
    max_daily_loss = 0.25 * balance  # 25% of the balance as max daily loss

# Final balance and profits
print(f"Final balance after 30 days: {balance}")
print(f"Total profits after 30 days: {profits}")